/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
  runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
  runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
  runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
  T,
  F
>;
export type Payload<
  T,
  F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
  T,
  A,
  F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
  client: string;
  engine: string;
};

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as new (
    secret: never,
  ) => typeof runtime.DbNull,
  JsonNull: runtime.NullTypes.JsonNull as new (
    secret: never,
  ) => typeof runtime.JsonNull,
  AnyNull: runtime.NullTypes.AnyNull as new (
    secret: never,
  ) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
  select: any;
  include: any;
};

type SelectAndOmit = {
  select: any;
  omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
  ? "Please either choose `select` or `include`."
  : T extends SelectAndOmit
    ? "Please either choose `select` or `omit`."
    : {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
  ? U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : U
  : T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> =
  T extends Array<any>
    ? False
    : T extends Date
      ? False
      : T extends Uint8Array
        ? False
        : T extends BigInt
          ? False
          : T extends object
            ? True
            : False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
  }[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
  1: EitherStrict<O, K>;
  0: EitherLoose<O, K>;
}[strict];

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

export type Overwrite<O extends object, O1 extends object> = {
  [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
  Overwrite<
    U,
    {
      [K in keyof U]-?: At<U, K>;
    }
  >
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
  ? AtStrict<O, K>
  : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
  1: AtStrict<O, K>;
  0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
  ? A
  : {
      [K in keyof A]: A[K];
    } & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
    ?
        | (K extends keyof O ? { [P in K]: O[P] } & O : O)
        | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
    : never
>;

type _Strict<U, _U = U> = U extends unknown
  ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
  : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
  0: 1;
  1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
    ? 1
    : 0;

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
  ? {
      [P in keyof T]: P extends keyof O ? O[P] : never;
    }
  : never;

type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> =
  IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<"OR", K>, Extends<"AND", K>>,
    Extends<"NOT", K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<
          UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
        >
      : never
    : {} extends FieldPaths<T[K]>
      ? never
      : K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
  T,
  K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
  ? never
  : T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
  ? never
  : FieldRef<Model, FieldType>;

export const ModelName = {
  User: "User",
  Organization: "Organization",
  OrgMembership: "OrgMembership",
  Event: "Event",
  EventRegistrationRequest: "EventRegistrationRequest",
  EventParticipant: "EventParticipant",
  SubmissionSchema: "SubmissionSchema",
  Team: "Team",
  TeamMember: "TeamMember",
  TeamInvite: "TeamInvite",
  TeamJoinRequest: "TeamJoinRequest",
  TeamAuditLog: "TeamAuditLog",
  Submission: "Submission",
  JudgeAssignment: "JudgeAssignment",
  Score: "Score",
  Announcement: "Announcement",
  ContactMessage: "ContactMessage",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils
  .Fn<
  { extArgs: runtime.Types.Extensions.InternalArgs },
  runtime.Types.Utils.Record<string, any>
> {
  returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
  ExtArgs extends runtime.Types.Extensions.InternalArgs =
    runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions;
  };
  meta: {
    modelProps:
      | "user"
      | "organization"
      | "orgMembership"
      | "event"
      | "eventRegistrationRequest"
      | "eventParticipant"
      | "submissionSchema"
      | "team"
      | "teamMember"
      | "teamInvite"
      | "teamJoinRequest"
      | "teamAuditLog"
      | "submission"
      | "judgeAssignment"
      | "score"
      | "announcement"
      | "contactMessage";
    txIsolationLevel: TransactionIsolationLevel;
  };
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>;
      fields: Prisma.UserFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
        };
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
        };
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
        };
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
        };
        count: {
          args: Prisma.UserCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
            | number;
        };
      };
    };
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>;
      fields: Prisma.OrganizationFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
        };
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>;
        };
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>;
        };
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[];
        };
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType>
            | number;
        };
      };
    };
    OrgMembership: {
      payload: Prisma.$OrgMembershipPayload<ExtArgs>;
      fields: Prisma.OrgMembershipFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.OrgMembershipFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.OrgMembershipFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        findFirst: {
          args: Prisma.OrgMembershipFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.OrgMembershipFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        findMany: {
          args: Prisma.OrgMembershipFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>[];
        };
        create: {
          args: Prisma.OrgMembershipCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        createMany: {
          args: Prisma.OrgMembershipCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.OrgMembershipDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        update: {
          args: Prisma.OrgMembershipUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        deleteMany: {
          args: Prisma.OrgMembershipDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.OrgMembershipUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.OrgMembershipUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
        };
        aggregate: {
          args: Prisma.OrgMembershipAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrgMembership>;
        };
        groupBy: {
          args: Prisma.OrgMembershipGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.OrgMembershipGroupByOutputType>[];
        };
        count: {
          args: Prisma.OrgMembershipCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.OrgMembershipCountAggregateOutputType>
            | number;
        };
      };
    };
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>;
      fields: Prisma.EventFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[];
        };
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>;
        };
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>;
        };
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[];
        };
        count: {
          args: Prisma.EventCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType>
            | number;
        };
      };
    };
    EventRegistrationRequest: {
      payload: Prisma.$EventRegistrationRequestPayload<ExtArgs>;
      fields: Prisma.EventRegistrationRequestFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationRequestFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationRequestFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        findFirst: {
          args: Prisma.EventRegistrationRequestFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EventRegistrationRequestFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        findMany: {
          args: Prisma.EventRegistrationRequestFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>[];
        };
        create: {
          args: Prisma.EventRegistrationRequestCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        createMany: {
          args: Prisma.EventRegistrationRequestCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.EventRegistrationRequestDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        update: {
          args: Prisma.EventRegistrationRequestUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        deleteMany: {
          args: Prisma.EventRegistrationRequestDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EventRegistrationRequestUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.EventRegistrationRequestUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
        };
        aggregate: {
          args: Prisma.EventRegistrationRequestAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistrationRequest>;
        };
        groupBy: {
          args: Prisma.EventRegistrationRequestGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationRequestGroupByOutputType>[];
        };
        count: {
          args: Prisma.EventRegistrationRequestCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EventRegistrationRequestCountAggregateOutputType>
            | number;
        };
      };
    };
    EventParticipant: {
      payload: Prisma.$EventParticipantPayload<ExtArgs>;
      fields: Prisma.EventParticipantFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.EventParticipantFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.EventParticipantFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        findFirst: {
          args: Prisma.EventParticipantFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.EventParticipantFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        findMany: {
          args: Prisma.EventParticipantFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>[];
        };
        create: {
          args: Prisma.EventParticipantCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        createMany: {
          args: Prisma.EventParticipantCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.EventParticipantDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        update: {
          args: Prisma.EventParticipantUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        deleteMany: {
          args: Prisma.EventParticipantDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.EventParticipantUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.EventParticipantUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
        };
        aggregate: {
          args: Prisma.EventParticipantAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventParticipant>;
        };
        groupBy: {
          args: Prisma.EventParticipantGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.EventParticipantGroupByOutputType>[];
        };
        count: {
          args: Prisma.EventParticipantCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.EventParticipantCountAggregateOutputType>
            | number;
        };
      };
    };
    SubmissionSchema: {
      payload: Prisma.$SubmissionSchemaPayload<ExtArgs>;
      fields: Prisma.SubmissionSchemaFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubmissionSchemaFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubmissionSchemaFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        findFirst: {
          args: Prisma.SubmissionSchemaFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubmissionSchemaFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        findMany: {
          args: Prisma.SubmissionSchemaFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>[];
        };
        create: {
          args: Prisma.SubmissionSchemaCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        createMany: {
          args: Prisma.SubmissionSchemaCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.SubmissionSchemaDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        update: {
          args: Prisma.SubmissionSchemaUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        deleteMany: {
          args: Prisma.SubmissionSchemaDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubmissionSchemaUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.SubmissionSchemaUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
        };
        aggregate: {
          args: Prisma.SubmissionSchemaAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubmissionSchema>;
        };
        groupBy: {
          args: Prisma.SubmissionSchemaGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubmissionSchemaGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubmissionSchemaCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubmissionSchemaCountAggregateOutputType>
            | number;
        };
      };
    };
    Team: {
      payload: Prisma.$TeamPayload<ExtArgs>;
      fields: Prisma.TeamFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        findFirst: {
          args: Prisma.TeamFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        findMany: {
          args: Prisma.TeamFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>[];
        };
        create: {
          args: Prisma.TeamCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        createMany: {
          args: Prisma.TeamCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.TeamDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        update: {
          args: Prisma.TeamUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        deleteMany: {
          args: Prisma.TeamDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.TeamUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamPayload>;
        };
        aggregate: {
          args: Prisma.TeamAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeam>;
        };
        groupBy: {
          args: Prisma.TeamGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeamCountAggregateOutputType>
            | number;
        };
      };
    };
    TeamMember: {
      payload: Prisma.$TeamMemberPayload<ExtArgs>;
      fields: Prisma.TeamMemberFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        findFirst: {
          args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        findMany: {
          args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
        };
        create: {
          args: Prisma.TeamMemberCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        createMany: {
          args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        update: {
          args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        deleteMany: {
          args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
        };
        aggregate: {
          args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamMember>;
        };
        groupBy: {
          args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamMemberGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamMemberCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeamMemberCountAggregateOutputType>
            | number;
        };
      };
    };
    TeamInvite: {
      payload: Prisma.$TeamInvitePayload<ExtArgs>;
      fields: Prisma.TeamInviteFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamInviteFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamInviteFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        findFirst: {
          args: Prisma.TeamInviteFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamInviteFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        findMany: {
          args: Prisma.TeamInviteFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>[];
        };
        create: {
          args: Prisma.TeamInviteCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        createMany: {
          args: Prisma.TeamInviteCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.TeamInviteDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        update: {
          args: Prisma.TeamInviteUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        deleteMany: {
          args: Prisma.TeamInviteDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamInviteUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.TeamInviteUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
        };
        aggregate: {
          args: Prisma.TeamInviteAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamInvite>;
        };
        groupBy: {
          args: Prisma.TeamInviteGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamInviteGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamInviteCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeamInviteCountAggregateOutputType>
            | number;
        };
      };
    };
    TeamJoinRequest: {
      payload: Prisma.$TeamJoinRequestPayload<ExtArgs>;
      fields: Prisma.TeamJoinRequestFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamJoinRequestFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        findFirst: {
          args: Prisma.TeamJoinRequestFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamJoinRequestFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        findMany: {
          args: Prisma.TeamJoinRequestFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>[];
        };
        create: {
          args: Prisma.TeamJoinRequestCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        createMany: {
          args: Prisma.TeamJoinRequestCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.TeamJoinRequestDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        update: {
          args: Prisma.TeamJoinRequestUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        deleteMany: {
          args: Prisma.TeamJoinRequestDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamJoinRequestUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.TeamJoinRequestUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
        };
        aggregate: {
          args: Prisma.TeamJoinRequestAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamJoinRequest>;
        };
        groupBy: {
          args: Prisma.TeamJoinRequestGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamJoinRequestGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamJoinRequestCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeamJoinRequestCountAggregateOutputType>
            | number;
        };
      };
    };
    TeamAuditLog: {
      payload: Prisma.$TeamAuditLogPayload<ExtArgs>;
      fields: Prisma.TeamAuditLogFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.TeamAuditLogFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.TeamAuditLogFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        findFirst: {
          args: Prisma.TeamAuditLogFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.TeamAuditLogFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        findMany: {
          args: Prisma.TeamAuditLogFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>[];
        };
        create: {
          args: Prisma.TeamAuditLogCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        createMany: {
          args: Prisma.TeamAuditLogCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.TeamAuditLogDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        update: {
          args: Prisma.TeamAuditLogUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        deleteMany: {
          args: Prisma.TeamAuditLogDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.TeamAuditLogUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.TeamAuditLogUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
        };
        aggregate: {
          args: Prisma.TeamAuditLogAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateTeamAuditLog>;
        };
        groupBy: {
          args: Prisma.TeamAuditLogGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.TeamAuditLogGroupByOutputType>[];
        };
        count: {
          args: Prisma.TeamAuditLogCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.TeamAuditLogCountAggregateOutputType>
            | number;
        };
      };
    };
    Submission: {
      payload: Prisma.$SubmissionPayload<ExtArgs>;
      fields: Prisma.SubmissionFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.SubmissionFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        findFirst: {
          args: Prisma.SubmissionFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        findMany: {
          args: Prisma.SubmissionFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>[];
        };
        create: {
          args: Prisma.SubmissionCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        createMany: {
          args: Prisma.SubmissionCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.SubmissionDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        update: {
          args: Prisma.SubmissionUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        deleteMany: {
          args: Prisma.SubmissionDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.SubmissionUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.SubmissionUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubmissionPayload>;
        };
        aggregate: {
          args: Prisma.SubmissionAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubmission>;
        };
        groupBy: {
          args: Prisma.SubmissionGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.SubmissionGroupByOutputType>[];
        };
        count: {
          args: Prisma.SubmissionCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.SubmissionCountAggregateOutputType>
            | number;
        };
      };
    };
    JudgeAssignment: {
      payload: Prisma.$JudgeAssignmentPayload<ExtArgs>;
      fields: Prisma.JudgeAssignmentFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.JudgeAssignmentFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.JudgeAssignmentFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        findFirst: {
          args: Prisma.JudgeAssignmentFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.JudgeAssignmentFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        findMany: {
          args: Prisma.JudgeAssignmentFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>[];
        };
        create: {
          args: Prisma.JudgeAssignmentCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        createMany: {
          args: Prisma.JudgeAssignmentCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.JudgeAssignmentDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        update: {
          args: Prisma.JudgeAssignmentUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        deleteMany: {
          args: Prisma.JudgeAssignmentDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.JudgeAssignmentUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.JudgeAssignmentUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
        };
        aggregate: {
          args: Prisma.JudgeAssignmentAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateJudgeAssignment>;
        };
        groupBy: {
          args: Prisma.JudgeAssignmentGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.JudgeAssignmentGroupByOutputType>[];
        };
        count: {
          args: Prisma.JudgeAssignmentCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.JudgeAssignmentCountAggregateOutputType>
            | number;
        };
      };
    };
    Score: {
      payload: Prisma.$ScorePayload<ExtArgs>;
      fields: Prisma.ScoreFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ScoreFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        findFirst: {
          args: Prisma.ScoreFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        findMany: {
          args: Prisma.ScoreFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[];
        };
        create: {
          args: Prisma.ScoreCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        createMany: {
          args: Prisma.ScoreCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.ScoreDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        update: {
          args: Prisma.ScoreUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        deleteMany: {
          args: Prisma.ScoreDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ScoreUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.ScoreUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>;
        };
        aggregate: {
          args: Prisma.ScoreAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateScore>;
        };
        groupBy: {
          args: Prisma.ScoreGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ScoreGroupByOutputType>[];
        };
        count: {
          args: Prisma.ScoreCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ScoreCountAggregateOutputType>
            | number;
        };
      };
    };
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>;
      fields: Prisma.AnnouncementFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
        };
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
        };
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>;
        };
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[];
        };
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType>
            | number;
        };
      };
    };
    ContactMessage: {
      payload: Prisma.$ContactMessagePayload<ExtArgs>;
      fields: Prisma.ContactMessageFieldRefs;
      operations: {
        findUnique: {
          args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null;
        };
        findUniqueOrThrow: {
          args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        findFirst: {
          args: Prisma.ContactMessageFindFirstArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null;
        };
        findFirstOrThrow: {
          args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        findMany: {
          args: Prisma.ContactMessageFindManyArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>[];
        };
        create: {
          args: Prisma.ContactMessageCreateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        createMany: {
          args: Prisma.ContactMessageCreateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        delete: {
          args: Prisma.ContactMessageDeleteArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        update: {
          args: Prisma.ContactMessageUpdateArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        deleteMany: {
          args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        updateMany: {
          args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>;
          result: BatchPayload;
        };
        upsert: {
          args: Prisma.ContactMessageUpsertArgs<ExtArgs>;
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
        };
        aggregate: {
          args: Prisma.ContactMessageAggregateArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactMessage>;
        };
        groupBy: {
          args: Prisma.ContactMessageGroupByArgs<ExtArgs>;
          result: runtime.Types.Utils.Optional<Prisma.ContactMessageGroupByOutputType>[];
        };
        count: {
          args: Prisma.ContactMessageCountArgs<ExtArgs>;
          result:
            | runtime.Types.Utils.Optional<Prisma.ContactMessageCountAggregateOutputType>
            | number;
        };
      };
    };
  };
} & {
  other: {
    payload: any;
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]];
        result: any;
      };
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]];
        result: any;
      };
    };
  };
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
  (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const UserScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  imageUrl: "imageUrl",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type UserScalarFieldEnum =
  (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const OrganizationScalarFieldEnum = {
  id: "id",
  name: "name",
  slug: "slug",
  logoUrl: "logoUrl",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type OrganizationScalarFieldEnum =
  (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

export const OrgMembershipScalarFieldEnum = {
  id: "id",
  orgId: "orgId",
  userId: "userId",
  role: "role",
  createdAt: "createdAt",
} as const;

export type OrgMembershipScalarFieldEnum =
  (typeof OrgMembershipScalarFieldEnum)[keyof typeof OrgMembershipScalarFieldEnum];

export const EventScalarFieldEnum = {
  id: "id",
  orgId: "orgId",
  name: "name",
  slug: "slug",
  type: "type",
  status: "status",
  heroTitle: "heroTitle",
  heroSubtitle: "heroSubtitle",
  rulesRich: "rulesRich",
  rubricRich: "rubricRich",
  startAt: "startAt",
  endAt: "endAt",
  submitDueAt: "submitDueAt",
  requireImages: "requireImages",
  requireVideoDemo: "requireVideoDemo",
  visibility: "visibility",
  joinMode: "joinMode",
  registrationOpensAt: "registrationOpensAt",
  registrationClosesAt: "registrationClosesAt",
  maxTeamSize: "maxTeamSize",
  lockTeamChangesAtStart: "lockTeamChangesAtStart",
  allowSelfJoinRequests: "allowSelfJoinRequests",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type EventScalarFieldEnum =
  (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

export const EventRegistrationRequestScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  message: "message",
  status: "status",
  createdAt: "createdAt",
  reviewedAt: "reviewedAt",
  reviewedByUserId: "reviewedByUserId",
} as const;

export type EventRegistrationRequestScalarFieldEnum =
  (typeof EventRegistrationRequestScalarFieldEnum)[keyof typeof EventRegistrationRequestScalarFieldEnum];

export const EventParticipantScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  status: "status",
  newsletterOptIn: "newsletterOptIn",
  contactEmail: "contactEmail",
  lookingForTeam: "lookingForTeam",
  trackPreference: "trackPreference",
  skills: "skills",
  interests: "interests",
  experienceLevel: "experienceLevel",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type EventParticipantScalarFieldEnum =
  (typeof EventParticipantScalarFieldEnum)[keyof typeof EventParticipantScalarFieldEnum];

export const SubmissionSchemaScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  fields: "fields",
} as const;

export type SubmissionSchemaScalarFieldEnum =
  (typeof SubmissionSchemaScalarFieldEnum)[keyof typeof SubmissionSchemaScalarFieldEnum];

export const TeamScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  name: "name",
  blurb: "blurb",
  track: "track",
  lookingForMembers: "lookingForMembers",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TeamScalarFieldEnum =
  (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

export const TeamMemberScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  role: "role",
} as const;

export type TeamMemberScalarFieldEnum =
  (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

export const TeamInviteScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  email: "email",
  token: "token",
  status: "status",
  message: "message",
  createdByUserId: "createdByUserId",
  createdAt: "createdAt",
  expiresAt: "expiresAt",
} as const;

export type TeamInviteScalarFieldEnum =
  (typeof TeamInviteScalarFieldEnum)[keyof typeof TeamInviteScalarFieldEnum];

export const TeamJoinRequestScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  message: "message",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type TeamJoinRequestScalarFieldEnum =
  (typeof TeamJoinRequestScalarFieldEnum)[keyof typeof TeamJoinRequestScalarFieldEnum];

export const TeamAuditLogScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  actorId: "actorId",
  targetUserId: "targetUserId",
  action: "action",
  meta: "meta",
  createdAt: "createdAt",
} as const;

export type TeamAuditLogScalarFieldEnum =
  (typeof TeamAuditLogScalarFieldEnum)[keyof typeof TeamAuditLogScalarFieldEnum];

export const SubmissionScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  authorId: "authorId",
  status: "status",
  title: "title",
  description: "description",
  content: "content",
  imageUrls: "imageUrls",
  videoUrl: "videoUrl",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  submittedAt: "submittedAt",
} as const;

export type SubmissionScalarFieldEnum =
  (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum];

export const JudgeAssignmentScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  role: "role",
} as const;

export type JudgeAssignmentScalarFieldEnum =
  (typeof JudgeAssignmentScalarFieldEnum)[keyof typeof JudgeAssignmentScalarFieldEnum];

export const ScoreScalarFieldEnum = {
  id: "id",
  submissionId: "submissionId",
  judgeId: "judgeId",
  total: "total",
  breakdown: "breakdown",
  feedback: "feedback",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
} as const;

export type ScoreScalarFieldEnum =
  (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum];

export const AnnouncementScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  title: "title",
  bodyRich: "bodyRich",
  createdAt: "createdAt",
} as const;

export type AnnouncementScalarFieldEnum =
  (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum];

export const ContactMessageScalarFieldEnum = {
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email",
  phone: "phone",
  organization: "organization",
  message: "message",
  createdAt: "createdAt",
  readAt: "readAt",
} as const;

export type ContactMessageScalarFieldEnum =
  (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum];

export const SortOrder = {
  asc: "asc",
  desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
  (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const JsonNullValueInput = {
  JsonNull: JsonNull,
} as const;

export type JsonNullValueInput =
  (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

export const NullsOrder = {
  first: "first",
  last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

export const UserOrderByRelevanceFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  imageUrl: "imageUrl",
} as const;

export type UserOrderByRelevanceFieldEnum =
  (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum];

export const OrganizationOrderByRelevanceFieldEnum = {
  id: "id",
  name: "name",
  slug: "slug",
  logoUrl: "logoUrl",
  description: "description",
} as const;

export type OrganizationOrderByRelevanceFieldEnum =
  (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum];

export const OrgMembershipOrderByRelevanceFieldEnum = {
  id: "id",
  orgId: "orgId",
  userId: "userId",
} as const;

export type OrgMembershipOrderByRelevanceFieldEnum =
  (typeof OrgMembershipOrderByRelevanceFieldEnum)[keyof typeof OrgMembershipOrderByRelevanceFieldEnum];

export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
  (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

export const QueryMode = {
  default: "default",
  insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const EventOrderByRelevanceFieldEnum = {
  id: "id",
  orgId: "orgId",
  name: "name",
  slug: "slug",
  heroTitle: "heroTitle",
  heroSubtitle: "heroSubtitle",
} as const;

export type EventOrderByRelevanceFieldEnum =
  (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum];

export const EventRegistrationRequestOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  message: "message",
  reviewedByUserId: "reviewedByUserId",
} as const;

export type EventRegistrationRequestOrderByRelevanceFieldEnum =
  (typeof EventRegistrationRequestOrderByRelevanceFieldEnum)[keyof typeof EventRegistrationRequestOrderByRelevanceFieldEnum];

export const EventParticipantOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  contactEmail: "contactEmail",
  trackPreference: "trackPreference",
  experienceLevel: "experienceLevel",
} as const;

export type EventParticipantOrderByRelevanceFieldEnum =
  (typeof EventParticipantOrderByRelevanceFieldEnum)[keyof typeof EventParticipantOrderByRelevanceFieldEnum];

export const SubmissionSchemaOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
} as const;

export type SubmissionSchemaOrderByRelevanceFieldEnum =
  (typeof SubmissionSchemaOrderByRelevanceFieldEnum)[keyof typeof SubmissionSchemaOrderByRelevanceFieldEnum];

export const TeamOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  name: "name",
  blurb: "blurb",
  track: "track",
} as const;

export type TeamOrderByRelevanceFieldEnum =
  (typeof TeamOrderByRelevanceFieldEnum)[keyof typeof TeamOrderByRelevanceFieldEnum];

export const TeamMemberOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
} as const;

export type TeamMemberOrderByRelevanceFieldEnum =
  (typeof TeamMemberOrderByRelevanceFieldEnum)[keyof typeof TeamMemberOrderByRelevanceFieldEnum];

export const TeamInviteOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  email: "email",
  token: "token",
  message: "message",
  createdByUserId: "createdByUserId",
} as const;

export type TeamInviteOrderByRelevanceFieldEnum =
  (typeof TeamInviteOrderByRelevanceFieldEnum)[keyof typeof TeamInviteOrderByRelevanceFieldEnum];

export const TeamJoinRequestOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  message: "message",
} as const;

export type TeamJoinRequestOrderByRelevanceFieldEnum =
  (typeof TeamJoinRequestOrderByRelevanceFieldEnum)[keyof typeof TeamJoinRequestOrderByRelevanceFieldEnum];

export const TeamAuditLogOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  actorId: "actorId",
  targetUserId: "targetUserId",
} as const;

export type TeamAuditLogOrderByRelevanceFieldEnum =
  (typeof TeamAuditLogOrderByRelevanceFieldEnum)[keyof typeof TeamAuditLogOrderByRelevanceFieldEnum];

export const SubmissionOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  authorId: "authorId",
  title: "title",
  description: "description",
  videoUrl: "videoUrl",
} as const;

export type SubmissionOrderByRelevanceFieldEnum =
  (typeof SubmissionOrderByRelevanceFieldEnum)[keyof typeof SubmissionOrderByRelevanceFieldEnum];

export const JudgeAssignmentOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
} as const;

export type JudgeAssignmentOrderByRelevanceFieldEnum =
  (typeof JudgeAssignmentOrderByRelevanceFieldEnum)[keyof typeof JudgeAssignmentOrderByRelevanceFieldEnum];

export const ScoreOrderByRelevanceFieldEnum = {
  id: "id",
  submissionId: "submissionId",
  judgeId: "judgeId",
  feedback: "feedback",
} as const;

export type ScoreOrderByRelevanceFieldEnum =
  (typeof ScoreOrderByRelevanceFieldEnum)[keyof typeof ScoreOrderByRelevanceFieldEnum];

export const AnnouncementOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  title: "title",
} as const;

export type AnnouncementOrderByRelevanceFieldEnum =
  (typeof AnnouncementOrderByRelevanceFieldEnum)[keyof typeof AnnouncementOrderByRelevanceFieldEnum];

export const ContactMessageOrderByRelevanceFieldEnum = {
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email",
  phone: "phone",
  organization: "organization",
  message: "message",
} as const;

export type ContactMessageOrderByRelevanceFieldEnum =
  (typeof ContactMessageOrderByRelevanceFieldEnum)[keyof typeof ContactMessageOrderByRelevanceFieldEnum];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "String"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "DateTime"
>;

/**
 * Reference to a field of type 'OrgRole'
 */
export type EnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "OrgRole"
>;

/**
 * Reference to a field of type 'EventType'
 */
export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EventType"
>;

/**
 * Reference to a field of type 'EventStatus'
 */
export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EventStatus"
>;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Json"
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "QueryMode"
>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Boolean"
>;

/**
 * Reference to a field of type 'EventVisibility'
 */
export type EnumEventVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EventVisibility"
>;

/**
 * Reference to a field of type 'EventJoinMode'
 */
export type EnumEventJoinModeFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "EventJoinMode"
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Int"
>;

/**
 * Reference to a field of type 'RegistrationRequestStatus'
 */
export type EnumRegistrationRequestStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "RegistrationRequestStatus">;

/**
 * Reference to a field of type 'ParticipantStatus'
 */
export type EnumParticipantStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "ParticipantStatus">;

/**
 * Reference to a field of type 'TeamRole'
 */
export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "TeamRole"
>;

/**
 * Reference to a field of type 'InviteStatus'
 */
export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "InviteStatus"
>;

/**
 * Reference to a field of type 'JoinRequestStatus'
 */
export type EnumJoinRequestStatusFieldRefInput<$PrismaModel> =
  FieldRefInputType<$PrismaModel, "JoinRequestStatus">;

/**
 * Reference to a field of type 'TeamAuditAction'
 */
export type EnumTeamAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "TeamAuditAction"
>;

/**
 * Reference to a field of type 'SubmissionStatus'
 */
export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "SubmissionStatus"
>;

/**
 * Reference to a field of type 'JudgeRole'
 */
export type EnumJudgeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "JudgeRole"
>;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
  $PrismaModel,
  "Float"
>;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number;
};

export const defineExtension = runtime.Extensions
  .defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
  "define",
  TypeMapCb,
  runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
  | {
      /**
       * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
       */
      adapter: runtime.SqlDriverAdapterFactory;
      accelerateUrl?: never;
    }
  | {
      /**
       * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
       */
      accelerateUrl: string;
      adapter?: never;
    }
) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   *
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   *
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   *
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[];
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number;
    timeout?: number;
    isolationLevel?: TransactionIsolationLevel;
  };
  /**
   * Global configuration for omitting model fields by default.
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig;
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   *
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit;
  organization?: Prisma.OrganizationOmit;
  orgMembership?: Prisma.OrgMembershipOmit;
  event?: Prisma.EventOmit;
  eventRegistrationRequest?: Prisma.EventRegistrationRequestOmit;
  eventParticipant?: Prisma.EventParticipantOmit;
  submissionSchema?: Prisma.SubmissionSchemaOmit;
  team?: Prisma.TeamOmit;
  teamMember?: Prisma.TeamMemberOmit;
  teamInvite?: Prisma.TeamInviteOmit;
  teamJoinRequest?: Prisma.TeamJoinRequestOmit;
  teamAuditLog?: Prisma.TeamAuditLogOmit;
  submission?: Prisma.SubmissionOmit;
  judgeAssignment?: Prisma.JudgeAssignmentOmit;
  score?: Prisma.ScoreOmit;
  announcement?: Prisma.AnnouncementOmit;
  contactMessage?: Prisma.ContactMessageOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> =
  T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

export type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

export type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};
/* End Types for Logging */

export type PrismaAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "executeRaw"
  | "queryRaw"
  | "aggregate"
  | "count"
  | "runCommandRaw"
  | "findRaw"
  | "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
  DefaultPrismaClient,
  runtime.ITXClientDenyList
>;

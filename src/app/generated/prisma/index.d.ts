/**
 * Client
 **/

import * as runtime from "./runtime/client.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Organization
 *
 */
export type Organization =
  $Result.DefaultSelection<Prisma.$OrganizationPayload>;
/**
 * Model OrgMembership
 *
 */
export type OrgMembership =
  $Result.DefaultSelection<Prisma.$OrgMembershipPayload>;
/**
 * Model Event
 *
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>;
/**
 * Model EventRegistrationRequest
 *
 */
export type EventRegistrationRequest =
  $Result.DefaultSelection<Prisma.$EventRegistrationRequestPayload>;
/**
 * Model EventParticipant
 *
 */
export type EventParticipant =
  $Result.DefaultSelection<Prisma.$EventParticipantPayload>;
/**
 * Model SubmissionSchema
 *
 */
export type SubmissionSchema =
  $Result.DefaultSelection<Prisma.$SubmissionSchemaPayload>;
/**
 * Model Team
 *
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>;
/**
 * Model TeamMember
 * TeamMember design notes:
 *   - eventId is stored directly to enforce:
 *       one-team-per-user-per-event via @@unique([eventId, userId])
 *   - LEADER transfer and kicking must be audited and optionally locked after event start.
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>;
/**
 * Model TeamInvite
 * Email-only invites:
 *   - Leader enters an email -> invite created with token
 *   - Recipient signs in -> must match User.email -> accept via /.../team/invites/:token
 *   - Acceptance must check:
 *       - Event.maxTeamSize capacity
 *       - TeamMember @@unique([eventId, userId]) (not already on a team)
 *       - Optional lockTeamChangesAtStart policy if event has started
 */
export type TeamInvite = $Result.DefaultSelection<Prisma.$TeamInvitePayload>;
/**
 * Model TeamJoinRequest
 * Join requests:
 *   - A user sees a team on Find Teams -> sends request with message
 *   - Team leader accepts/declines
 *   - Acceptance must check:
 *       - Event.maxTeamSize capacity
 *       - TeamMember @@unique([eventId, userId]) (not already on a team)
 *       - allowSelfJoinRequests policy
 */
export type TeamJoinRequest =
  $Result.DefaultSelection<Prisma.$TeamJoinRequestPayload>;
/**
 * Model TeamAuditLog
 * Audit log:
 *   - Write a row for sensitive actions:
 *       - kicking
 *       - leader transfer
 *       - invite send/revoke/accept/decline
 *       - join request lifecycle
 *   - Helps prevent repudiation and enables organizer review.
 */
export type TeamAuditLog =
  $Result.DefaultSelection<Prisma.$TeamAuditLogPayload>;
/**
 * Model Submission
 *
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>;
/**
 * Model JudgeAssignment
 *
 */
export type JudgeAssignment =
  $Result.DefaultSelection<Prisma.$JudgeAssignmentPayload>;
/**
 * Model Score
 *
 */
export type Score = $Result.DefaultSelection<Prisma.$ScorePayload>;
/**
 * Model Announcement
 *
 */
export type Announcement =
  $Result.DefaultSelection<Prisma.$AnnouncementPayload>;
/**
 * Model ContactMessage
 *
 */
export type ContactMessage =
  $Result.DefaultSelection<Prisma.$ContactMessagePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const OrgRole: {
    OWNER: "OWNER";
    ADMIN: "ADMIN";
    MEMBER: "MEMBER";
  };

  export type OrgRole = (typeof OrgRole)[keyof typeof OrgRole];

  export const EventType: {
    IDEATHON: "IDEATHON";
    HACKATHON: "HACKATHON";
  };

  export type EventType = (typeof EventType)[keyof typeof EventType];

  export const EventStatus: {
    DRAFT: "DRAFT";
    PUBLISHED: "PUBLISHED";
    ARCHIVED: "ARCHIVED";
  };

  export type EventStatus = (typeof EventStatus)[keyof typeof EventStatus];

  export const TeamRole: {
    LEADER: "LEADER";
    MEMBER: "MEMBER";
  };

  export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole];

  export const SubmissionStatus: {
    DRAFT: "DRAFT";
    SUBMITTED: "SUBMITTED";
  };

  export type SubmissionStatus =
    (typeof SubmissionStatus)[keyof typeof SubmissionStatus];

  export const JudgeRole: {
    JUDGE: "JUDGE";
    ADMIN_JUDGE: "ADMIN_JUDGE";
  };

  export type JudgeRole = (typeof JudgeRole)[keyof typeof JudgeRole];

  export const ParticipantStatus: {
    REGISTERED: "REGISTERED";
    WITHDRAWN: "WITHDRAWN";
  };

  export type ParticipantStatus =
    (typeof ParticipantStatus)[keyof typeof ParticipantStatus];

  export const InviteStatus: {
    PENDING: "PENDING";
    ACCEPTED: "ACCEPTED";
    DECLINED: "DECLINED";
    REVOKED: "REVOKED";
    EXPIRED: "EXPIRED";
  };

  export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus];

  export const JoinRequestStatus: {
    PENDING: "PENDING";
    ACCEPTED: "ACCEPTED";
    DECLINED: "DECLINED";
    CANCELLED: "CANCELLED";
  };

  export type JoinRequestStatus =
    (typeof JoinRequestStatus)[keyof typeof JoinRequestStatus];

  export const TeamAuditAction: {
    TEAM_CREATED: "TEAM_CREATED";
    TEAM_UPDATED: "TEAM_UPDATED";
    TEAM_DELETED: "TEAM_DELETED";
    INVITE_SENT: "INVITE_SENT";
    INVITE_REVOKED: "INVITE_REVOKED";
    INVITE_ACCEPTED: "INVITE_ACCEPTED";
    INVITE_DECLINED: "INVITE_DECLINED";
    JOIN_REQUEST_SENT: "JOIN_REQUEST_SENT";
    JOIN_REQUEST_ACCEPTED: "JOIN_REQUEST_ACCEPTED";
    JOIN_REQUEST_DECLINED: "JOIN_REQUEST_DECLINED";
    JOIN_REQUEST_CANCELLED: "JOIN_REQUEST_CANCELLED";
    MEMBER_LEFT: "MEMBER_LEFT";
    MEMBER_KICKED: "MEMBER_KICKED";
    LEADER_TRANSFERRED: "LEADER_TRANSFERRED";
  };

  export type TeamAuditAction =
    (typeof TeamAuditAction)[keyof typeof TeamAuditAction];

  export const RegistrationRequestStatus: {
    PENDING: "PENDING";
    APPROVED: "APPROVED";
    REJECTED: "REJECTED";
    CANCELLED: "CANCELLED";
  };

  export type RegistrationRequestStatus =
    (typeof RegistrationRequestStatus)[keyof typeof RegistrationRequestStatus];

  export const EventVisibility: {
    PUBLIC_LISTED: "PUBLIC_LISTED";
    PUBLIC_UNLISTED: "PUBLIC_UNLISTED";
    PRIVATE: "PRIVATE";
  };

  export type EventVisibility =
    (typeof EventVisibility)[keyof typeof EventVisibility];

  export const EventJoinMode: {
    OPEN: "OPEN";
    REQUEST: "REQUEST";
    INVITE_ONLY: "INVITE_ONLY";
  };

  export type EventJoinMode =
    (typeof EventJoinMode)[keyof typeof EventJoinMode];
}

export type OrgRole = $Enums.OrgRole;

export const OrgRole: typeof $Enums.OrgRole;

export type EventType = $Enums.EventType;

export const EventType: typeof $Enums.EventType;

export type EventStatus = $Enums.EventStatus;

export const EventStatus: typeof $Enums.EventStatus;

export type TeamRole = $Enums.TeamRole;

export const TeamRole: typeof $Enums.TeamRole;

export type SubmissionStatus = $Enums.SubmissionStatus;

export const SubmissionStatus: typeof $Enums.SubmissionStatus;

export type JudgeRole = $Enums.JudgeRole;

export const JudgeRole: typeof $Enums.JudgeRole;

export type ParticipantStatus = $Enums.ParticipantStatus;

export const ParticipantStatus: typeof $Enums.ParticipantStatus;

export type InviteStatus = $Enums.InviteStatus;

export const InviteStatus: typeof $Enums.InviteStatus;

export type JoinRequestStatus = $Enums.JoinRequestStatus;

export const JoinRequestStatus: typeof $Enums.JoinRequestStatus;

export type TeamAuditAction = $Enums.TeamAuditAction;

export const TeamAuditAction: typeof $Enums.TeamAuditAction;

export type RegistrationRequestStatus = $Enums.RegistrationRequestStatus;

export const RegistrationRequestStatus: typeof $Enums.RegistrationRequestStatus;

export type EventVisibility = $Enums.EventVisibility;

export const EventVisibility: typeof $Enums.EventVisibility;

export type EventJoinMode = $Enums.EventJoinMode;

export const EventJoinMode: typeof $Enums.EventJoinMode;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orgMembership`: Exposes CRUD operations for the **OrgMembership** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrgMemberships
   * const orgMemberships = await prisma.orgMembership.findMany()
   * ```
   */
  get orgMembership(): Prisma.OrgMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Events
   * const events = await prisma.event.findMany()
   * ```
   */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventRegistrationRequest`: Exposes CRUD operations for the **EventRegistrationRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more EventRegistrationRequests
   * const eventRegistrationRequests = await prisma.eventRegistrationRequest.findMany()
   * ```
   */
  get eventRegistrationRequest(): Prisma.EventRegistrationRequestDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.eventParticipant`: Exposes CRUD operations for the **EventParticipant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more EventParticipants
   * const eventParticipants = await prisma.eventParticipant.findMany()
   * ```
   */
  get eventParticipant(): Prisma.EventParticipantDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.submissionSchema`: Exposes CRUD operations for the **SubmissionSchema** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SubmissionSchemas
   * const submissionSchemas = await prisma.submissionSchema.findMany()
   * ```
   */
  get submissionSchema(): Prisma.SubmissionSchemaDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamMembers
   * const teamMembers = await prisma.teamMember.findMany()
   * ```
   */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamInvite`: Exposes CRUD operations for the **TeamInvite** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamInvites
   * const teamInvites = await prisma.teamInvite.findMany()
   * ```
   */
  get teamInvite(): Prisma.TeamInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamJoinRequest`: Exposes CRUD operations for the **TeamJoinRequest** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamJoinRequests
   * const teamJoinRequests = await prisma.teamJoinRequest.findMany()
   * ```
   */
  get teamJoinRequest(): Prisma.TeamJoinRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamAuditLog`: Exposes CRUD operations for the **TeamAuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamAuditLogs
   * const teamAuditLogs = await prisma.teamAuditLog.findMany()
   * ```
   */
  get teamAuditLog(): Prisma.TeamAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Submissions
   * const submissions = await prisma.submission.findMany()
   * ```
   */
  get submission(): Prisma.SubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.judgeAssignment`: Exposes CRUD operations for the **JudgeAssignment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more JudgeAssignments
   * const judgeAssignments = await prisma.judgeAssignment.findMany()
   * ```
   */
  get judgeAssignment(): Prisma.JudgeAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.score`: Exposes CRUD operations for the **Score** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Scores
   * const scores = await prisma.score.findMany()
   * ```
   */
  get score(): Prisma.ScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Announcements
   * const announcements = await prisma.announcement.findMany()
   * ```
   */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactMessage`: Exposes CRUD operations for the **ContactMessage** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ContactMessages
   * const contactMessages = await prisma.contactMessage.findMany()
   * ```
   */
  get contactMessage(): Prisma.ContactMessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: "User";
    Organization: "Organization";
    OrgMembership: "OrgMembership";
    Event: "Event";
    EventRegistrationRequest: "EventRegistrationRequest";
    EventParticipant: "EventParticipant";
    SubmissionSchema: "SubmissionSchema";
    Team: "Team";
    TeamMember: "TeamMember";
    TeamInvite: "TeamInvite";
    TeamJoinRequest: "TeamJoinRequest";
    TeamAuditLog: "TeamAuditLog";
    Submission: "Submission";
    JudgeAssignment: "JudgeAssignment";
    Score: "Score";
    Announcement: "Announcement";
    ContactMessage: "ContactMessage";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "user"
        | "organization"
        | "orgMembership"
        | "event"
        | "eventRegistrationRequest"
        | "eventParticipant"
        | "submissionSchema"
        | "team"
        | "teamMember"
        | "teamInvite"
        | "teamJoinRequest"
        | "teamAuditLog"
        | "submission"
        | "judgeAssignment"
        | "score"
        | "announcement"
        | "contactMessage";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>;
        fields: Prisma.OrganizationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[];
          };
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>;
          };
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrganization>;
          };
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrganizationGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<OrganizationCountAggregateOutputType>
              | number;
          };
        };
      };
      OrgMembership: {
        payload: Prisma.$OrgMembershipPayload<ExtArgs>;
        fields: Prisma.OrgMembershipFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrgMembershipFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrgMembershipFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          findFirst: {
            args: Prisma.OrgMembershipFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrgMembershipFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          findMany: {
            args: Prisma.OrgMembershipFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>[];
          };
          create: {
            args: Prisma.OrgMembershipCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          createMany: {
            args: Prisma.OrgMembershipCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.OrgMembershipDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          update: {
            args: Prisma.OrgMembershipUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          deleteMany: {
            args: Prisma.OrgMembershipDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrgMembershipUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrgMembershipUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrgMembershipPayload>;
          };
          aggregate: {
            args: Prisma.OrgMembershipAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrgMembership>;
          };
          groupBy: {
            args: Prisma.OrgMembershipGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrgMembershipGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrgMembershipCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<OrgMembershipCountAggregateOutputType>
              | number;
          };
        };
      };
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>;
        fields: Prisma.EventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[];
          };
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventPayload>;
          };
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEvent>;
          };
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventGroupByOutputType>[];
          };
          count: {
            args: Prisma.EventCountArgs<ExtArgs>;
            result: $Utils.Optional<EventCountAggregateOutputType> | number;
          };
        };
      };
      EventRegistrationRequest: {
        payload: Prisma.$EventRegistrationRequestPayload<ExtArgs>;
        fields: Prisma.EventRegistrationRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          findFirst: {
            args: Prisma.EventRegistrationRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EventRegistrationRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          findMany: {
            args: Prisma.EventRegistrationRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>[];
          };
          create: {
            args: Prisma.EventRegistrationRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          createMany: {
            args: Prisma.EventRegistrationRequestCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EventRegistrationRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          update: {
            args: Prisma.EventRegistrationRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          deleteMany: {
            args: Prisma.EventRegistrationRequestDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EventRegistrationRequestUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EventRegistrationRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationRequestPayload>;
          };
          aggregate: {
            args: Prisma.EventRegistrationRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEventRegistrationRequest>;
          };
          groupBy: {
            args: Prisma.EventRegistrationRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventRegistrationRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.EventRegistrationRequestCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<EventRegistrationRequestCountAggregateOutputType>
              | number;
          };
        };
      };
      EventParticipant: {
        payload: Prisma.$EventParticipantPayload<ExtArgs>;
        fields: Prisma.EventParticipantFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EventParticipantFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EventParticipantFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          findFirst: {
            args: Prisma.EventParticipantFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EventParticipantFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          findMany: {
            args: Prisma.EventParticipantFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>[];
          };
          create: {
            args: Prisma.EventParticipantCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          createMany: {
            args: Prisma.EventParticipantCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.EventParticipantDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          update: {
            args: Prisma.EventParticipantUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          deleteMany: {
            args: Prisma.EventParticipantDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EventParticipantUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EventParticipantUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EventParticipantPayload>;
          };
          aggregate: {
            args: Prisma.EventParticipantAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEventParticipant>;
          };
          groupBy: {
            args: Prisma.EventParticipantGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventParticipantGroupByOutputType>[];
          };
          count: {
            args: Prisma.EventParticipantCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<EventParticipantCountAggregateOutputType>
              | number;
          };
        };
      };
      SubmissionSchema: {
        payload: Prisma.$SubmissionSchemaPayload<ExtArgs>;
        fields: Prisma.SubmissionSchemaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubmissionSchemaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubmissionSchemaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          findFirst: {
            args: Prisma.SubmissionSchemaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubmissionSchemaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          findMany: {
            args: Prisma.SubmissionSchemaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>[];
          };
          create: {
            args: Prisma.SubmissionSchemaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          createMany: {
            args: Prisma.SubmissionSchemaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SubmissionSchemaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          update: {
            args: Prisma.SubmissionSchemaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          deleteMany: {
            args: Prisma.SubmissionSchemaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubmissionSchemaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SubmissionSchemaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionSchemaPayload>;
          };
          aggregate: {
            args: Prisma.SubmissionSchemaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubmissionSchema>;
          };
          groupBy: {
            args: Prisma.SubmissionSchemaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubmissionSchemaGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubmissionSchemaCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SubmissionSchemaCountAggregateOutputType>
              | number;
          };
        };
      };
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>;
        fields: Prisma.TeamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeam>;
          };
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>;
            result: $Utils.Optional<TeamCountAggregateOutputType> | number;
          };
        };
      };
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>;
        fields: Prisma.TeamMemberFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
          };
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamMember>;
          };
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamMemberGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TeamMemberCountAggregateOutputType>
              | number;
          };
        };
      };
      TeamInvite: {
        payload: Prisma.$TeamInvitePayload<ExtArgs>;
        fields: Prisma.TeamInviteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamInviteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamInviteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          findFirst: {
            args: Prisma.TeamInviteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamInviteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          findMany: {
            args: Prisma.TeamInviteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>[];
          };
          create: {
            args: Prisma.TeamInviteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          createMany: {
            args: Prisma.TeamInviteCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamInviteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          update: {
            args: Prisma.TeamInviteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          deleteMany: {
            args: Prisma.TeamInviteDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamInviteUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamInviteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamInvitePayload>;
          };
          aggregate: {
            args: Prisma.TeamInviteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamInvite>;
          };
          groupBy: {
            args: Prisma.TeamInviteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamInviteGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamInviteCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TeamInviteCountAggregateOutputType>
              | number;
          };
        };
      };
      TeamJoinRequest: {
        payload: Prisma.$TeamJoinRequestPayload<ExtArgs>;
        fields: Prisma.TeamJoinRequestFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamJoinRequestFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          findFirst: {
            args: Prisma.TeamJoinRequestFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamJoinRequestFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          findMany: {
            args: Prisma.TeamJoinRequestFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>[];
          };
          create: {
            args: Prisma.TeamJoinRequestCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          createMany: {
            args: Prisma.TeamJoinRequestCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamJoinRequestDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          update: {
            args: Prisma.TeamJoinRequestUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          deleteMany: {
            args: Prisma.TeamJoinRequestDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamJoinRequestUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamJoinRequestUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>;
          };
          aggregate: {
            args: Prisma.TeamJoinRequestAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamJoinRequest>;
          };
          groupBy: {
            args: Prisma.TeamJoinRequestGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamJoinRequestGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamJoinRequestCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TeamJoinRequestCountAggregateOutputType>
              | number;
          };
        };
      };
      TeamAuditLog: {
        payload: Prisma.$TeamAuditLogPayload<ExtArgs>;
        fields: Prisma.TeamAuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamAuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamAuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          findFirst: {
            args: Prisma.TeamAuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamAuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          findMany: {
            args: Prisma.TeamAuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>[];
          };
          create: {
            args: Prisma.TeamAuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          createMany: {
            args: Prisma.TeamAuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.TeamAuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          update: {
            args: Prisma.TeamAuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.TeamAuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamAuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamAuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamAuditLogPayload>;
          };
          aggregate: {
            args: Prisma.TeamAuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamAuditLog>;
          };
          groupBy: {
            args: Prisma.TeamAuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamAuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamAuditLogCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<TeamAuditLogCountAggregateOutputType>
              | number;
          };
        };
      };
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>;
        fields: Prisma.SubmissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[];
          };
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubmission>;
          };
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubmissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SubmissionCountAggregateOutputType>
              | number;
          };
        };
      };
      JudgeAssignment: {
        payload: Prisma.$JudgeAssignmentPayload<ExtArgs>;
        fields: Prisma.JudgeAssignmentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.JudgeAssignmentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.JudgeAssignmentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          findFirst: {
            args: Prisma.JudgeAssignmentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.JudgeAssignmentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          findMany: {
            args: Prisma.JudgeAssignmentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>[];
          };
          create: {
            args: Prisma.JudgeAssignmentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          createMany: {
            args: Prisma.JudgeAssignmentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.JudgeAssignmentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          update: {
            args: Prisma.JudgeAssignmentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          deleteMany: {
            args: Prisma.JudgeAssignmentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.JudgeAssignmentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.JudgeAssignmentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgeAssignmentPayload>;
          };
          aggregate: {
            args: Prisma.JudgeAssignmentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateJudgeAssignment>;
          };
          groupBy: {
            args: Prisma.JudgeAssignmentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<JudgeAssignmentGroupByOutputType>[];
          };
          count: {
            args: Prisma.JudgeAssignmentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<JudgeAssignmentCountAggregateOutputType>
              | number;
          };
        };
      };
      Score: {
        payload: Prisma.$ScorePayload<ExtArgs>;
        fields: Prisma.ScoreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ScoreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          findFirst: {
            args: Prisma.ScoreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          findMany: {
            args: Prisma.ScoreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[];
          };
          create: {
            args: Prisma.ScoreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          createMany: {
            args: Prisma.ScoreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ScoreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          update: {
            args: Prisma.ScoreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          deleteMany: {
            args: Prisma.ScoreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ScoreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ScoreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          aggregate: {
            args: Prisma.ScoreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateScore>;
          };
          groupBy: {
            args: Prisma.ScoreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ScoreGroupByOutputType>[];
          };
          count: {
            args: Prisma.ScoreCountArgs<ExtArgs>;
            result: $Utils.Optional<ScoreCountAggregateOutputType> | number;
          };
        };
      };
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>;
        fields: Prisma.AnnouncementFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
          };
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnnouncement>;
          };
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementGroupByOutputType>[];
          };
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnnouncementCountAggregateOutputType>
              | number;
          };
        };
      };
      ContactMessage: {
        payload: Prisma.$ContactMessagePayload<ExtArgs>;
        fields: Prisma.ContactMessageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          findFirst: {
            args: Prisma.ContactMessageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          findMany: {
            args: Prisma.ContactMessageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[];
          };
          create: {
            args: Prisma.ContactMessageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          createMany: {
            args: Prisma.ContactMessageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ContactMessageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          update: {
            args: Prisma.ContactMessageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          deleteMany: {
            args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ContactMessageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>;
          };
          aggregate: {
            args: Prisma.ContactMessageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateContactMessage>;
          };
          groupBy: {
            args: Prisma.ContactMessageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ContactMessageGroupByOutputType>[];
          };
          count: {
            args: Prisma.ContactMessageCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ContactMessageCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[];
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    organization?: OrganizationOmit;
    orgMembership?: OrgMembershipOmit;
    event?: EventOmit;
    eventRegistrationRequest?: EventRegistrationRequestOmit;
    eventParticipant?: EventParticipantOmit;
    submissionSchema?: SubmissionSchemaOmit;
    team?: TeamOmit;
    teamMember?: TeamMemberOmit;
    teamInvite?: TeamInviteOmit;
    teamJoinRequest?: TeamJoinRequestOmit;
    teamAuditLog?: TeamAuditLogOmit;
    submission?: SubmissionOmit;
    judgeAssignment?: JudgeAssignmentOmit;
    score?: ScoreOmit;
    announcement?: AnnouncementOmit;
    contactMessage?: ContactMessageOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T["level"] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    memberships: number;
    eventParticipants: number;
    teams: number;
    submissions: number;
    judgeLinks: number;
    teamInvitesCreated: number;
    teamJoinRequests: number;
    teamAuditActor: number;
    teamAuditTarget: number;
    scoresGiven: number;
    registrationRequests: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs;
    eventParticipants?: boolean | UserCountOutputTypeCountEventParticipantsArgs;
    teams?: boolean | UserCountOutputTypeCountTeamsArgs;
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs;
    judgeLinks?: boolean | UserCountOutputTypeCountJudgeLinksArgs;
    teamInvitesCreated?:
      | boolean
      | UserCountOutputTypeCountTeamInvitesCreatedArgs;
    teamJoinRequests?: boolean | UserCountOutputTypeCountTeamJoinRequestsArgs;
    teamAuditActor?: boolean | UserCountOutputTypeCountTeamAuditActorArgs;
    teamAuditTarget?: boolean | UserCountOutputTypeCountTeamAuditTargetArgs;
    scoresGiven?: boolean | UserCountOutputTypeCountScoresGivenArgs;
    registrationRequests?:
      | boolean
      | UserCountOutputTypeCountRegistrationRequestsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgMembershipWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventParticipantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventParticipantWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJudgeLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: JudgeAssignmentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamInvitesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamInviteWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamJoinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamJoinRequestWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamAuditActorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamAuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamAuditTargetArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamAuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScoresGivenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegistrationRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventRegistrationRequestWhereInput;
  };

  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    memberships: number;
    events: number;
  };

  export type OrganizationCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    memberships?: boolean | OrganizationCountOutputTypeCountMembershipsArgs;
    events?: boolean | OrganizationCountOutputTypeCountEventsArgs;
  };

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgMembershipWhereInput;
  };

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventWhereInput;
  };

  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    participants: number;
    teams: number;
    teamInvites: number;
    joinRequests: number;
    teamAuditLogs: number;
    submissions: number;
    announcements: number;
    judgeAssignments: number;
    registrationRequests: number;
  };

  export type EventCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    participants?: boolean | EventCountOutputTypeCountParticipantsArgs;
    teams?: boolean | EventCountOutputTypeCountTeamsArgs;
    teamInvites?: boolean | EventCountOutputTypeCountTeamInvitesArgs;
    joinRequests?: boolean | EventCountOutputTypeCountJoinRequestsArgs;
    teamAuditLogs?: boolean | EventCountOutputTypeCountTeamAuditLogsArgs;
    submissions?: boolean | EventCountOutputTypeCountSubmissionsArgs;
    announcements?: boolean | EventCountOutputTypeCountAnnouncementsArgs;
    judgeAssignments?: boolean | EventCountOutputTypeCountJudgeAssignmentsArgs;
    registrationRequests?:
      | boolean
      | EventCountOutputTypeCountRegistrationRequestsArgs;
  };

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountParticipantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventParticipantWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTeamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTeamInvitesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamInviteWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountJoinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamJoinRequestWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTeamAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamAuditLogWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountAnnouncementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountJudgeAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: JudgeAssignmentWhereInput;
  };

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRegistrationRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventRegistrationRequestWhereInput;
  };

  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    auditLogs: number;
    members: number;
    invites: number;
    joinRequests: number;
    submissions: number;
  };

  export type TeamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    auditLogs?: boolean | TeamCountOutputTypeCountAuditLogsArgs;
    members?: boolean | TeamCountOutputTypeCountMembersArgs;
    invites?: boolean | TeamCountOutputTypeCountInvitesArgs;
    joinRequests?: boolean | TeamCountOutputTypeCountJoinRequestsArgs;
    submissions?: boolean | TeamCountOutputTypeCountSubmissionsArgs;
  };

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamAuditLogWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInvitesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamInviteWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountJoinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamJoinRequestWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * Count Type SubmissionCountOutputType
   */

  export type SubmissionCountOutputType = {
    scores: number;
  };

  export type SubmissionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scores?: boolean | SubmissionCountOutputTypeCountScoresArgs;
  };

  // Custom InputTypes
  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionCountOutputType
     */
    select?: SubmissionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    imageUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    imageUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    name: number;
    imageUrl: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    imageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    imageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    imageUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    name: string | null;
    imageUrl: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      imageUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      memberships?: boolean | User$membershipsArgs<ExtArgs>;
      eventParticipants?: boolean | User$eventParticipantsArgs<ExtArgs>;
      teams?: boolean | User$teamsArgs<ExtArgs>;
      submissions?: boolean | User$submissionsArgs<ExtArgs>;
      judgeLinks?: boolean | User$judgeLinksArgs<ExtArgs>;
      teamInvitesCreated?: boolean | User$teamInvitesCreatedArgs<ExtArgs>;
      teamJoinRequests?: boolean | User$teamJoinRequestsArgs<ExtArgs>;
      teamAuditActor?: boolean | User$teamAuditActorArgs<ExtArgs>;
      teamAuditTarget?: boolean | User$teamAuditTargetArgs<ExtArgs>;
      scoresGiven?: boolean | User$scoresGivenArgs<ExtArgs>;
      registrationRequests?: boolean | User$registrationRequestsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    name?: boolean;
    imageUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "email" | "name" | "imageUrl" | "createdAt" | "updatedAt",
    ExtArgs["result"]["user"]
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    memberships?: boolean | User$membershipsArgs<ExtArgs>;
    eventParticipants?: boolean | User$eventParticipantsArgs<ExtArgs>;
    teams?: boolean | User$teamsArgs<ExtArgs>;
    submissions?: boolean | User$submissionsArgs<ExtArgs>;
    judgeLinks?: boolean | User$judgeLinksArgs<ExtArgs>;
    teamInvitesCreated?: boolean | User$teamInvitesCreatedArgs<ExtArgs>;
    teamJoinRequests?: boolean | User$teamJoinRequestsArgs<ExtArgs>;
    teamAuditActor?: boolean | User$teamAuditActorArgs<ExtArgs>;
    teamAuditTarget?: boolean | User$teamAuditTargetArgs<ExtArgs>;
    scoresGiven?: boolean | User$scoresGivenArgs<ExtArgs>;
    registrationRequests?: boolean | User$registrationRequestsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "User";
    objects: {
      memberships: Prisma.$OrgMembershipPayload<ExtArgs>[];
      eventParticipants: Prisma.$EventParticipantPayload<ExtArgs>[];
      teams: Prisma.$TeamMemberPayload<ExtArgs>[];
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
      judgeLinks: Prisma.$JudgeAssignmentPayload<ExtArgs>[];
      teamInvitesCreated: Prisma.$TeamInvitePayload<ExtArgs>[];
      teamJoinRequests: Prisma.$TeamJoinRequestPayload<ExtArgs>[];
      teamAuditActor: Prisma.$TeamAuditLogPayload<ExtArgs>[];
      teamAuditTarget: Prisma.$TeamAuditLogPayload<ExtArgs>[];
      scoresGiven: Prisma.$ScorePayload<ExtArgs>[];
      registrationRequests: Prisma.$EventRegistrationRequestPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        name: string | null;
        imageUrl: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["User"];
      meta: { name: "User" };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$membershipsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrgMembershipPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    eventParticipants<T extends User$eventParticipantsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$eventParticipantsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventParticipantPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teams<T extends User$teamsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamMemberPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$submissionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubmissionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    judgeLinks<T extends User$judgeLinksArgs<ExtArgs> = {}>(
      args?: Subset<T, User$judgeLinksArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$JudgeAssignmentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamInvitesCreated<T extends User$teamInvitesCreatedArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamInvitesCreatedArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamInvitePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamJoinRequests<T extends User$teamJoinRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamJoinRequestsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamJoinRequestPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamAuditActor<T extends User$teamAuditActorArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamAuditActorArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamAuditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamAuditTarget<T extends User$teamAuditTargetArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamAuditTargetArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamAuditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    scoresGiven<T extends User$scoresGivenArgs<ExtArgs> = {}>(
      args?: Subset<T, User$scoresGivenArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ScorePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    registrationRequests<T extends User$registrationRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$registrationRequestsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventRegistrationRequestPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly imageUrl: FieldRef<"User", "String">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.memberships
   */
  export type User$membershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    where?: OrgMembershipWhereInput;
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    cursor?: OrgMembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[];
  };

  /**
   * User.eventParticipants
   */
  export type User$eventParticipantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    where?: EventParticipantWhereInput;
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    cursor?: EventParticipantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EventParticipantScalarFieldEnum
      | EventParticipantScalarFieldEnum[];
  };

  /**
   * User.teams
   */
  export type User$teamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    where?: TeamMemberWhereInput;
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    cursor?: TeamMemberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * User.submissions
   */
  export type User$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * User.judgeLinks
   */
  export type User$judgeLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    where?: JudgeAssignmentWhereInput;
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    cursor?: JudgeAssignmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | JudgeAssignmentScalarFieldEnum
      | JudgeAssignmentScalarFieldEnum[];
  };

  /**
   * User.teamInvitesCreated
   */
  export type User$teamInvitesCreatedArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    where?: TeamInviteWhereInput;
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    cursor?: TeamInviteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * User.teamJoinRequests
   */
  export type User$teamJoinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    where?: TeamJoinRequestWhereInput;
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    cursor?: TeamJoinRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * User.teamAuditActor
   */
  export type User$teamAuditActorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    where?: TeamAuditLogWhereInput;
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    cursor?: TeamAuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * User.teamAuditTarget
   */
  export type User$teamAuditTargetArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    where?: TeamAuditLogWhereInput;
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    cursor?: TeamAuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * User.scoresGiven
   */
  export type User$scoresGivenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    cursor?: ScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * User.registrationRequests
   */
  export type User$registrationRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    where?: EventRegistrationRequestWhereInput;
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    cursor?: EventRegistrationRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EventRegistrationRequestScalarFieldEnum
      | EventRegistrationRequestScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  export type OrganizationMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    logoUrl: string | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrganizationMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    logoUrl: string | null;
    description: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type OrganizationCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    logoUrl: number;
    description: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type OrganizationMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    logoUrl?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrganizationMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    logoUrl?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type OrganizationCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    logoUrl?: true;
    description?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type OrganizationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Organizations
     **/
    _count?: true | OrganizationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrganizationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrganizationMaxAggregateInputType;
  };

  export type GetOrganizationAggregateType<
    T extends OrganizationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateOrganization]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>;
  };

  export type OrganizationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrganizationWhereInput;
    orderBy?:
      | OrganizationOrderByWithAggregationInput
      | OrganizationOrderByWithAggregationInput[];
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum;
    having?: OrganizationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrganizationCountAggregateInputType | true;
    _min?: OrganizationMinAggregateInputType;
    _max?: OrganizationMaxAggregateInputType;
  };

  export type OrganizationGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    logoUrl: string | null;
    description: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: OrganizationCountAggregateOutputType | null;
    _min: OrganizationMinAggregateOutputType | null;
    _max: OrganizationMaxAggregateOutputType | null;
  };

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrganizationGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof OrganizationGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>;
        }
      >
    >;

  export type OrganizationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      logoUrl?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      memberships?: boolean | Organization$membershipsArgs<ExtArgs>;
      events?: boolean | Organization$eventsArgs<ExtArgs>;
      _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["organization"]
  >;

  export type OrganizationSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    logoUrl?: boolean;
    description?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type OrganizationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "slug"
    | "logoUrl"
    | "description"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["organization"]
  >;
  export type OrganizationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    memberships?: boolean | Organization$membershipsArgs<ExtArgs>;
    events?: boolean | Organization$eventsArgs<ExtArgs>;
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $OrganizationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Organization";
    objects: {
      memberships: Prisma.$OrgMembershipPayload<ExtArgs>[];
      events: Prisma.$EventPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        logoUrl: string | null;
        description: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["organization"]
    >;
    composites: {};
  };

  type OrganizationGetPayload<
    S extends boolean | null | undefined | OrganizationDefaultArgs,
  > = $Result.GetResult<Prisma.$OrganizationPayload, S>;

  type OrganizationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrganizationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrganizationCountAggregateInputType | true;
  };

  export interface OrganizationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Organization"];
      meta: { name: "Organization" };
    };
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     *
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrganizationFindManyArgs>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     *
     */
    create<T extends OrganizationCreateArgs>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrganizationCreateManyArgs>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     *
     */
    delete<T extends OrganizationDeleteArgs>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrganizationUpdateArgs>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrganizationUpdateManyArgs>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      $Result.GetResult<
        Prisma.$OrganizationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
     **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrganizationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrganizationAggregateArgs>(
      args: Subset<T, OrganizationAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>;

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs["orderBy"] }
        : { orderBy?: OrganizationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetOrganizationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Organization model
     */
    readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    memberships<T extends Organization$membershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$membershipsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$OrgMembershipPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    events<T extends Organization$eventsArgs<ExtArgs> = {}>(
      args?: Subset<T, Organization$eventsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", "String">;
    readonly name: FieldRef<"Organization", "String">;
    readonly slug: FieldRef<"Organization", "String">;
    readonly logoUrl: FieldRef<"Organization", "String">;
    readonly description: FieldRef<"Organization", "String">;
    readonly createdAt: FieldRef<"Organization", "DateTime">;
    readonly updatedAt: FieldRef<"Organization", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Organizations to fetch.
     */
    orderBy?:
      | OrganizationOrderByWithRelationInput
      | OrganizationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Organizations.
     */
    skip?: number;
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[];
  };

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
  };

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<
      OrganizationUpdateManyMutationInput,
      OrganizationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to update.
     */
    limit?: number;
  };

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput;
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>;
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>;
  };

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput;
  };

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput;
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number;
  };

  /**
   * Organization.memberships
   */
  export type Organization$membershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    where?: OrgMembershipWhereInput;
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    cursor?: OrgMembershipWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[];
  };

  /**
   * Organization.events
   */
  export type Organization$eventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    where?: EventWhereInput;
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    cursor?: EventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null;
  };

  /**
   * Model OrgMembership
   */

  export type AggregateOrgMembership = {
    _count: OrgMembershipCountAggregateOutputType | null;
    _min: OrgMembershipMinAggregateOutputType | null;
    _max: OrgMembershipMaxAggregateOutputType | null;
  };

  export type OrgMembershipMinAggregateOutputType = {
    id: string | null;
    orgId: string | null;
    userId: string | null;
    role: $Enums.OrgRole | null;
    createdAt: Date | null;
  };

  export type OrgMembershipMaxAggregateOutputType = {
    id: string | null;
    orgId: string | null;
    userId: string | null;
    role: $Enums.OrgRole | null;
    createdAt: Date | null;
  };

  export type OrgMembershipCountAggregateOutputType = {
    id: number;
    orgId: number;
    userId: number;
    role: number;
    createdAt: number;
    _all: number;
  };

  export type OrgMembershipMinAggregateInputType = {
    id?: true;
    orgId?: true;
    userId?: true;
    role?: true;
    createdAt?: true;
  };

  export type OrgMembershipMaxAggregateInputType = {
    id?: true;
    orgId?: true;
    userId?: true;
    role?: true;
    createdAt?: true;
  };

  export type OrgMembershipCountAggregateInputType = {
    id?: true;
    orgId?: true;
    userId?: true;
    role?: true;
    createdAt?: true;
    _all?: true;
  };

  export type OrgMembershipAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgMembership to aggregate.
     */
    where?: OrgMembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrgMembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgMemberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrgMemberships
     **/
    _count?: true | OrgMembershipCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrgMembershipMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrgMembershipMaxAggregateInputType;
  };

  export type GetOrgMembershipAggregateType<
    T extends OrgMembershipAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateOrgMembership]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrgMembership[P]>
      : GetScalarType<T[P], AggregateOrgMembership[P]>;
  };

  export type OrgMembershipGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrgMembershipWhereInput;
    orderBy?:
      | OrgMembershipOrderByWithAggregationInput
      | OrgMembershipOrderByWithAggregationInput[];
    by: OrgMembershipScalarFieldEnum[] | OrgMembershipScalarFieldEnum;
    having?: OrgMembershipScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrgMembershipCountAggregateInputType | true;
    _min?: OrgMembershipMinAggregateInputType;
    _max?: OrgMembershipMaxAggregateInputType;
  };

  export type OrgMembershipGroupByOutputType = {
    id: string;
    orgId: string;
    userId: string;
    role: $Enums.OrgRole;
    createdAt: Date;
    _count: OrgMembershipCountAggregateOutputType | null;
    _min: OrgMembershipMinAggregateOutputType | null;
    _max: OrgMembershipMaxAggregateOutputType | null;
  };

  type GetOrgMembershipGroupByPayload<T extends OrgMembershipGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<OrgMembershipGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof OrgMembershipGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrgMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], OrgMembershipGroupByOutputType[P]>;
        }
      >
    >;

  export type OrgMembershipSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orgId?: boolean;
      userId?: boolean;
      role?: boolean;
      createdAt?: boolean;
      org?: boolean | OrganizationDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["orgMembership"]
  >;

  export type OrgMembershipSelectScalar = {
    id?: boolean;
    orgId?: boolean;
    userId?: boolean;
    role?: boolean;
    createdAt?: boolean;
  };

  export type OrgMembershipOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "orgId" | "userId" | "role" | "createdAt",
    ExtArgs["result"]["orgMembership"]
  >;
  export type OrgMembershipInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $OrgMembershipPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "OrgMembership";
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orgId: string;
        userId: string;
        role: $Enums.OrgRole;
        createdAt: Date;
      },
      ExtArgs["result"]["orgMembership"]
    >;
    composites: {};
  };

  type OrgMembershipGetPayload<
    S extends boolean | null | undefined | OrgMembershipDefaultArgs,
  > = $Result.GetResult<Prisma.$OrgMembershipPayload, S>;

  type OrgMembershipCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    OrgMembershipFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OrgMembershipCountAggregateInputType | true;
  };

  export interface OrgMembershipDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["OrgMembership"];
      meta: { name: "OrgMembership" };
    };
    /**
     * Find zero or one OrgMembership that matches the filter.
     * @param {OrgMembershipFindUniqueArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrgMembershipFindUniqueArgs>(
      args: SelectSubset<T, OrgMembershipFindUniqueArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one OrgMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrgMembershipFindUniqueOrThrowArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrgMembershipFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrgMembershipFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindFirstArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrgMembershipFindFirstArgs>(
      args?: SelectSubset<T, OrgMembershipFindFirstArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first OrgMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindFirstOrThrowArgs} args - Arguments to find a OrgMembership
     * @example
     * // Get one OrgMembership
     * const orgMembership = await prisma.orgMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrgMembershipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrgMembershipFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more OrgMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrgMemberships
     * const orgMemberships = await prisma.orgMembership.findMany()
     *
     * // Get first 10 OrgMemberships
     * const orgMemberships = await prisma.orgMembership.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orgMembershipWithIdOnly = await prisma.orgMembership.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrgMembershipFindManyArgs>(
      args?: SelectSubset<T, OrgMembershipFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a OrgMembership.
     * @param {OrgMembershipCreateArgs} args - Arguments to create a OrgMembership.
     * @example
     * // Create one OrgMembership
     * const OrgMembership = await prisma.orgMembership.create({
     *   data: {
     *     // ... data to create a OrgMembership
     *   }
     * })
     *
     */
    create<T extends OrgMembershipCreateArgs>(
      args: SelectSubset<T, OrgMembershipCreateArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many OrgMemberships.
     * @param {OrgMembershipCreateManyArgs} args - Arguments to create many OrgMemberships.
     * @example
     * // Create many OrgMemberships
     * const orgMembership = await prisma.orgMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrgMembershipCreateManyArgs>(
      args?: SelectSubset<T, OrgMembershipCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a OrgMembership.
     * @param {OrgMembershipDeleteArgs} args - Arguments to delete one OrgMembership.
     * @example
     * // Delete one OrgMembership
     * const OrgMembership = await prisma.orgMembership.delete({
     *   where: {
     *     // ... filter to delete one OrgMembership
     *   }
     * })
     *
     */
    delete<T extends OrgMembershipDeleteArgs>(
      args: SelectSubset<T, OrgMembershipDeleteArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one OrgMembership.
     * @param {OrgMembershipUpdateArgs} args - Arguments to update one OrgMembership.
     * @example
     * // Update one OrgMembership
     * const orgMembership = await prisma.orgMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrgMembershipUpdateArgs>(
      args: SelectSubset<T, OrgMembershipUpdateArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more OrgMemberships.
     * @param {OrgMembershipDeleteManyArgs} args - Arguments to filter OrgMemberships to delete.
     * @example
     * // Delete a few OrgMemberships
     * const { count } = await prisma.orgMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrgMembershipDeleteManyArgs>(
      args?: SelectSubset<T, OrgMembershipDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrgMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrgMemberships
     * const orgMembership = await prisma.orgMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrgMembershipUpdateManyArgs>(
      args: SelectSubset<T, OrgMembershipUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one OrgMembership.
     * @param {OrgMembershipUpsertArgs} args - Arguments to update or create a OrgMembership.
     * @example
     * // Update or create a OrgMembership
     * const orgMembership = await prisma.orgMembership.upsert({
     *   create: {
     *     // ... data to create a OrgMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrgMembership we want to update
     *   }
     * })
     */
    upsert<T extends OrgMembershipUpsertArgs>(
      args: SelectSubset<T, OrgMembershipUpsertArgs<ExtArgs>>,
    ): Prisma__OrgMembershipClient<
      $Result.GetResult<
        Prisma.$OrgMembershipPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of OrgMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipCountArgs} args - Arguments to filter OrgMemberships to count.
     * @example
     * // Count the number of OrgMemberships
     * const count = await prisma.orgMembership.count({
     *   where: {
     *     // ... the filter for the OrgMemberships we want to count
     *   }
     * })
     **/
    count<T extends OrgMembershipCountArgs>(
      args?: Subset<T, OrgMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OrgMembershipCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrgMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrgMembershipAggregateArgs>(
      args: Subset<T, OrgMembershipAggregateArgs>,
    ): Prisma.PrismaPromise<GetOrgMembershipAggregateType<T>>;

    /**
     * Group by OrgMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrgMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrgMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrgMembershipGroupByArgs["orderBy"] }
        : { orderBy?: OrgMembershipGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrgMembershipGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetOrgMembershipGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrgMembership model
     */
    readonly fields: OrgMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrgMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrgMembershipClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrgMembership model
   */
  interface OrgMembershipFieldRefs {
    readonly id: FieldRef<"OrgMembership", "String">;
    readonly orgId: FieldRef<"OrgMembership", "String">;
    readonly userId: FieldRef<"OrgMembership", "String">;
    readonly role: FieldRef<"OrgMembership", "OrgRole">;
    readonly createdAt: FieldRef<"OrgMembership", "DateTime">;
  }

  // Custom InputTypes
  /**
   * OrgMembership findUnique
   */
  export type OrgMembershipFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter, which OrgMembership to fetch.
     */
    where: OrgMembershipWhereUniqueInput;
  };

  /**
   * OrgMembership findUniqueOrThrow
   */
  export type OrgMembershipFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter, which OrgMembership to fetch.
     */
    where: OrgMembershipWhereUniqueInput;
  };

  /**
   * OrgMembership findFirst
   */
  export type OrgMembershipFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter, which OrgMembership to fetch.
     */
    where?: OrgMembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgMemberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgMemberships.
     */
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[];
  };

  /**
   * OrgMembership findFirstOrThrow
   */
  export type OrgMembershipFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter, which OrgMembership to fetch.
     */
    where?: OrgMembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgMemberships.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrgMemberships.
     */
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[];
  };

  /**
   * OrgMembership findMany
   */
  export type OrgMembershipFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter, which OrgMemberships to fetch.
     */
    where?: OrgMembershipWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrgMemberships to fetch.
     */
    orderBy?:
      | OrgMembershipOrderByWithRelationInput
      | OrgMembershipOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrgMemberships.
     */
    cursor?: OrgMembershipWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrgMemberships from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrgMemberships.
     */
    skip?: number;
    distinct?: OrgMembershipScalarFieldEnum | OrgMembershipScalarFieldEnum[];
  };

  /**
   * OrgMembership create
   */
  export type OrgMembershipCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrgMembership.
     */
    data: XOR<OrgMembershipCreateInput, OrgMembershipUncheckedCreateInput>;
  };

  /**
   * OrgMembership createMany
   */
  export type OrgMembershipCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrgMemberships.
     */
    data: OrgMembershipCreateManyInput | OrgMembershipCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrgMembership update
   */
  export type OrgMembershipUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrgMembership.
     */
    data: XOR<OrgMembershipUpdateInput, OrgMembershipUncheckedUpdateInput>;
    /**
     * Choose, which OrgMembership to update.
     */
    where: OrgMembershipWhereUniqueInput;
  };

  /**
   * OrgMembership updateMany
   */
  export type OrgMembershipUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrgMemberships.
     */
    data: XOR<
      OrgMembershipUpdateManyMutationInput,
      OrgMembershipUncheckedUpdateManyInput
    >;
    /**
     * Filter which OrgMemberships to update
     */
    where?: OrgMembershipWhereInput;
    /**
     * Limit how many OrgMemberships to update.
     */
    limit?: number;
  };

  /**
   * OrgMembership upsert
   */
  export type OrgMembershipUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrgMembership to update in case it exists.
     */
    where: OrgMembershipWhereUniqueInput;
    /**
     * In case the OrgMembership found by the `where` argument doesn't exist, create a new OrgMembership with this data.
     */
    create: XOR<OrgMembershipCreateInput, OrgMembershipUncheckedCreateInput>;
    /**
     * In case the OrgMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrgMembershipUpdateInput, OrgMembershipUncheckedUpdateInput>;
  };

  /**
   * OrgMembership delete
   */
  export type OrgMembershipDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
    /**
     * Filter which OrgMembership to delete.
     */
    where: OrgMembershipWhereUniqueInput;
  };

  /**
   * OrgMembership deleteMany
   */
  export type OrgMembershipDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrgMemberships to delete
     */
    where?: OrgMembershipWhereInput;
    /**
     * Limit how many OrgMemberships to delete.
     */
    limit?: number;
  };

  /**
   * OrgMembership without action
   */
  export type OrgMembershipDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrgMembership
     */
    select?: OrgMembershipSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the OrgMembership
     */
    omit?: OrgMembershipOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrgMembershipInclude<ExtArgs> | null;
  };

  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  export type EventAvgAggregateOutputType = {
    maxTeamSize: number | null;
  };

  export type EventSumAggregateOutputType = {
    maxTeamSize: number | null;
  };

  export type EventMinAggregateOutputType = {
    id: string | null;
    orgId: string | null;
    name: string | null;
    slug: string | null;
    type: $Enums.EventType | null;
    status: $Enums.EventStatus | null;
    heroTitle: string | null;
    heroSubtitle: string | null;
    startAt: Date | null;
    endAt: Date | null;
    submitDueAt: Date | null;
    requireImages: boolean | null;
    requireVideoDemo: boolean | null;
    visibility: $Enums.EventVisibility | null;
    joinMode: $Enums.EventJoinMode | null;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    maxTeamSize: number | null;
    lockTeamChangesAtStart: boolean | null;
    allowSelfJoinRequests: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventMaxAggregateOutputType = {
    id: string | null;
    orgId: string | null;
    name: string | null;
    slug: string | null;
    type: $Enums.EventType | null;
    status: $Enums.EventStatus | null;
    heroTitle: string | null;
    heroSubtitle: string | null;
    startAt: Date | null;
    endAt: Date | null;
    submitDueAt: Date | null;
    requireImages: boolean | null;
    requireVideoDemo: boolean | null;
    visibility: $Enums.EventVisibility | null;
    joinMode: $Enums.EventJoinMode | null;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    maxTeamSize: number | null;
    lockTeamChangesAtStart: boolean | null;
    allowSelfJoinRequests: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventCountAggregateOutputType = {
    id: number;
    orgId: number;
    name: number;
    slug: number;
    type: number;
    status: number;
    heroTitle: number;
    heroSubtitle: number;
    rulesRich: number;
    rubricRich: number;
    startAt: number;
    endAt: number;
    submitDueAt: number;
    requireImages: number;
    requireVideoDemo: number;
    visibility: number;
    joinMode: number;
    registrationOpensAt: number;
    registrationClosesAt: number;
    maxTeamSize: number;
    lockTeamChangesAtStart: number;
    allowSelfJoinRequests: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type EventAvgAggregateInputType = {
    maxTeamSize?: true;
  };

  export type EventSumAggregateInputType = {
    maxTeamSize?: true;
  };

  export type EventMinAggregateInputType = {
    id?: true;
    orgId?: true;
    name?: true;
    slug?: true;
    type?: true;
    status?: true;
    heroTitle?: true;
    heroSubtitle?: true;
    startAt?: true;
    endAt?: true;
    submitDueAt?: true;
    requireImages?: true;
    requireVideoDemo?: true;
    visibility?: true;
    joinMode?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    maxTeamSize?: true;
    lockTeamChangesAtStart?: true;
    allowSelfJoinRequests?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventMaxAggregateInputType = {
    id?: true;
    orgId?: true;
    name?: true;
    slug?: true;
    type?: true;
    status?: true;
    heroTitle?: true;
    heroSubtitle?: true;
    startAt?: true;
    endAt?: true;
    submitDueAt?: true;
    requireImages?: true;
    requireVideoDemo?: true;
    visibility?: true;
    joinMode?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    maxTeamSize?: true;
    lockTeamChangesAtStart?: true;
    allowSelfJoinRequests?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventCountAggregateInputType = {
    id?: true;
    orgId?: true;
    name?: true;
    slug?: true;
    type?: true;
    status?: true;
    heroTitle?: true;
    heroSubtitle?: true;
    rulesRich?: true;
    rubricRich?: true;
    startAt?: true;
    endAt?: true;
    submitDueAt?: true;
    requireImages?: true;
    requireVideoDemo?: true;
    visibility?: true;
    joinMode?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    maxTeamSize?: true;
    lockTeamChangesAtStart?: true;
    allowSelfJoinRequests?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type EventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Events
     **/
    _count?: true | EventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EventAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EventSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventMaxAggregateInputType;
  };

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
    [P in keyof T & keyof AggregateEvent]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>;
  };

  export type EventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventWhereInput;
    orderBy?:
      | EventOrderByWithAggregationInput
      | EventOrderByWithAggregationInput[];
    by: EventScalarFieldEnum[] | EventScalarFieldEnum;
    having?: EventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EventCountAggregateInputType | true;
    _avg?: EventAvgAggregateInputType;
    _sum?: EventSumAggregateInputType;
    _min?: EventMinAggregateInputType;
    _max?: EventMaxAggregateInputType;
  };

  export type EventGroupByOutputType = {
    id: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle: string | null;
    rulesRich: JsonValue | null;
    rubricRich: JsonValue | null;
    startAt: Date | null;
    endAt: Date | null;
    submitDueAt: Date | null;
    requireImages: boolean;
    requireVideoDemo: boolean;
    visibility: $Enums.EventVisibility;
    joinMode: $Enums.EventJoinMode;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    maxTeamSize: number;
    lockTeamChangesAtStart: boolean;
    allowSelfJoinRequests: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  type GetEventGroupByPayload<T extends EventGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EventGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof EventGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>;
        }
      >
    >;

  export type EventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orgId?: boolean;
      name?: boolean;
      slug?: boolean;
      type?: boolean;
      status?: boolean;
      heroTitle?: boolean;
      heroSubtitle?: boolean;
      rulesRich?: boolean;
      rubricRich?: boolean;
      startAt?: boolean;
      endAt?: boolean;
      submitDueAt?: boolean;
      requireImages?: boolean;
      requireVideoDemo?: boolean;
      visibility?: boolean;
      joinMode?: boolean;
      registrationOpensAt?: boolean;
      registrationClosesAt?: boolean;
      maxTeamSize?: boolean;
      lockTeamChangesAtStart?: boolean;
      allowSelfJoinRequests?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      org?: boolean | OrganizationDefaultArgs<ExtArgs>;
      submissionSchema?: boolean | Event$submissionSchemaArgs<ExtArgs>;
      participants?: boolean | Event$participantsArgs<ExtArgs>;
      teams?: boolean | Event$teamsArgs<ExtArgs>;
      teamInvites?: boolean | Event$teamInvitesArgs<ExtArgs>;
      joinRequests?: boolean | Event$joinRequestsArgs<ExtArgs>;
      teamAuditLogs?: boolean | Event$teamAuditLogsArgs<ExtArgs>;
      submissions?: boolean | Event$submissionsArgs<ExtArgs>;
      announcements?: boolean | Event$announcementsArgs<ExtArgs>;
      judgeAssignments?: boolean | Event$judgeAssignmentsArgs<ExtArgs>;
      registrationRequests?: boolean | Event$registrationRequestsArgs<ExtArgs>;
      _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["event"]
  >;

  export type EventSelectScalar = {
    id?: boolean;
    orgId?: boolean;
    name?: boolean;
    slug?: boolean;
    type?: boolean;
    status?: boolean;
    heroTitle?: boolean;
    heroSubtitle?: boolean;
    rulesRich?: boolean;
    rubricRich?: boolean;
    startAt?: boolean;
    endAt?: boolean;
    submitDueAt?: boolean;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: boolean;
    joinMode?: boolean;
    registrationOpensAt?: boolean;
    registrationClosesAt?: boolean;
    maxTeamSize?: boolean;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type EventOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "orgId"
    | "name"
    | "slug"
    | "type"
    | "status"
    | "heroTitle"
    | "heroSubtitle"
    | "rulesRich"
    | "rubricRich"
    | "startAt"
    | "endAt"
    | "submitDueAt"
    | "requireImages"
    | "requireVideoDemo"
    | "visibility"
    | "joinMode"
    | "registrationOpensAt"
    | "registrationClosesAt"
    | "maxTeamSize"
    | "lockTeamChangesAtStart"
    | "allowSelfJoinRequests"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["event"]
  >;
  export type EventInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>;
    submissionSchema?: boolean | Event$submissionSchemaArgs<ExtArgs>;
    participants?: boolean | Event$participantsArgs<ExtArgs>;
    teams?: boolean | Event$teamsArgs<ExtArgs>;
    teamInvites?: boolean | Event$teamInvitesArgs<ExtArgs>;
    joinRequests?: boolean | Event$joinRequestsArgs<ExtArgs>;
    teamAuditLogs?: boolean | Event$teamAuditLogsArgs<ExtArgs>;
    submissions?: boolean | Event$submissionsArgs<ExtArgs>;
    announcements?: boolean | Event$announcementsArgs<ExtArgs>;
    judgeAssignments?: boolean | Event$judgeAssignmentsArgs<ExtArgs>;
    registrationRequests?: boolean | Event$registrationRequestsArgs<ExtArgs>;
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $EventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Event";
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>;
      submissionSchema: Prisma.$SubmissionSchemaPayload<ExtArgs> | null;
      participants: Prisma.$EventParticipantPayload<ExtArgs>[];
      teams: Prisma.$TeamPayload<ExtArgs>[];
      teamInvites: Prisma.$TeamInvitePayload<ExtArgs>[];
      joinRequests: Prisma.$TeamJoinRequestPayload<ExtArgs>[];
      teamAuditLogs: Prisma.$TeamAuditLogPayload<ExtArgs>[];
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[];
      judgeAssignments: Prisma.$JudgeAssignmentPayload<ExtArgs>[];
      registrationRequests: Prisma.$EventRegistrationRequestPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orgId: string;
        name: string;
        slug: string;
        type: $Enums.EventType;
        status: $Enums.EventStatus;
        heroTitle: string;
        heroSubtitle: string | null;
        rulesRich: Prisma.JsonValue | null;
        rubricRich: Prisma.JsonValue | null;
        startAt: Date | null;
        endAt: Date | null;
        submitDueAt: Date | null;
        requireImages: boolean;
        requireVideoDemo: boolean;
        visibility: $Enums.EventVisibility;
        joinMode: $Enums.EventJoinMode;
        registrationOpensAt: Date | null;
        registrationClosesAt: Date | null;
        maxTeamSize: number;
        lockTeamChangesAtStart: boolean;
        allowSelfJoinRequests: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["event"]
    >;
    composites: {};
  };

  type EventGetPayload<
    S extends boolean | null | undefined | EventDefaultArgs,
  > = $Result.GetResult<Prisma.$EventPayload, S>;

  type EventCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<EventFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: EventCountAggregateInputType | true;
  };

  export interface EventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Event"];
      meta: { name: "Event" };
    };
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(
      args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(
      args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     *
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     *
     */
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     *
     */
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs<ExtArgs>>,
    ): Prisma__EventClient<
      $Result.GetResult<
        Prisma.$EventPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
     **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventAggregateArgs>(
      args: Subset<T, EventAggregateArgs>,
    ): Prisma.PrismaPromise<GetEventAggregateType<T>>;

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs["orderBy"] }
        : { orderBy?: EventGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Event model
     */
    readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>,
    ): Prisma__OrganizationClient<
      | $Result.GetResult<
          Prisma.$OrganizationPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    submissionSchema<T extends Event$submissionSchemaArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$submissionSchemaArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    participants<T extends Event$participantsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$participantsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventParticipantPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teams<T extends Event$teamsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$teamsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamInvites<T extends Event$teamInvitesArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$teamInvitesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamInvitePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    joinRequests<T extends Event$joinRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$joinRequestsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamJoinRequestPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    teamAuditLogs<T extends Event$teamAuditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$teamAuditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamAuditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    submissions<T extends Event$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$submissionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubmissionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    announcements<T extends Event$announcementsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$announcementsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    judgeAssignments<T extends Event$judgeAssignmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Event$judgeAssignmentsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$JudgeAssignmentPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    registrationRequests<
      T extends Event$registrationRequestsArgs<ExtArgs> = {},
    >(
      args?: Subset<T, Event$registrationRequestsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EventRegistrationRequestPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", "String">;
    readonly orgId: FieldRef<"Event", "String">;
    readonly name: FieldRef<"Event", "String">;
    readonly slug: FieldRef<"Event", "String">;
    readonly type: FieldRef<"Event", "EventType">;
    readonly status: FieldRef<"Event", "EventStatus">;
    readonly heroTitle: FieldRef<"Event", "String">;
    readonly heroSubtitle: FieldRef<"Event", "String">;
    readonly rulesRich: FieldRef<"Event", "Json">;
    readonly rubricRich: FieldRef<"Event", "Json">;
    readonly startAt: FieldRef<"Event", "DateTime">;
    readonly endAt: FieldRef<"Event", "DateTime">;
    readonly submitDueAt: FieldRef<"Event", "DateTime">;
    readonly requireImages: FieldRef<"Event", "Boolean">;
    readonly requireVideoDemo: FieldRef<"Event", "Boolean">;
    readonly visibility: FieldRef<"Event", "EventVisibility">;
    readonly joinMode: FieldRef<"Event", "EventJoinMode">;
    readonly registrationOpensAt: FieldRef<"Event", "DateTime">;
    readonly registrationClosesAt: FieldRef<"Event", "DateTime">;
    readonly maxTeamSize: FieldRef<"Event", "Int">;
    readonly lockTeamChangesAtStart: FieldRef<"Event", "Boolean">;
    readonly allowSelfJoinRequests: FieldRef<"Event", "Boolean">;
    readonly createdAt: FieldRef<"Event", "DateTime">;
    readonly updatedAt: FieldRef<"Event", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event findMany
   */
  export type EventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Events.
     */
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * Event create
   */
  export type EventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>;
  };

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Event update
   */
  export type EventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>;
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to update.
     */
    limit?: number;
  };

  /**
   * Event upsert
   */
  export type EventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput;
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>;
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>;
  };

  /**
   * Event delete
   */
  export type EventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput;
  };

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput;
    /**
     * Limit how many Events to delete.
     */
    limit?: number;
  };

  /**
   * Event.submissionSchema
   */
  export type Event$submissionSchemaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    where?: SubmissionSchemaWhereInput;
  };

  /**
   * Event.participants
   */
  export type Event$participantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    where?: EventParticipantWhereInput;
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    cursor?: EventParticipantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EventParticipantScalarFieldEnum
      | EventParticipantScalarFieldEnum[];
  };

  /**
   * Event.teams
   */
  export type Event$teamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    cursor?: TeamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Event.teamInvites
   */
  export type Event$teamInvitesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    where?: TeamInviteWhereInput;
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    cursor?: TeamInviteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * Event.joinRequests
   */
  export type Event$joinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    where?: TeamJoinRequestWhereInput;
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    cursor?: TeamJoinRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * Event.teamAuditLogs
   */
  export type Event$teamAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    where?: TeamAuditLogWhereInput;
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    cursor?: TeamAuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * Event.submissions
   */
  export type Event$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Event.announcements
   */
  export type Event$announcementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    where?: AnnouncementWhereInput;
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    cursor?: AnnouncementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Event.judgeAssignments
   */
  export type Event$judgeAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    where?: JudgeAssignmentWhereInput;
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    cursor?: JudgeAssignmentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | JudgeAssignmentScalarFieldEnum
      | JudgeAssignmentScalarFieldEnum[];
  };

  /**
   * Event.registrationRequests
   */
  export type Event$registrationRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    where?: EventRegistrationRequestWhereInput;
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    cursor?: EventRegistrationRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EventRegistrationRequestScalarFieldEnum
      | EventRegistrationRequestScalarFieldEnum[];
  };

  /**
   * Event without action
   */
  export type EventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null;
  };

  /**
   * Model EventRegistrationRequest
   */

  export type AggregateEventRegistrationRequest = {
    _count: EventRegistrationRequestCountAggregateOutputType | null;
    _min: EventRegistrationRequestMinAggregateOutputType | null;
    _max: EventRegistrationRequestMaxAggregateOutputType | null;
  };

  export type EventRegistrationRequestMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    message: string | null;
    status: $Enums.RegistrationRequestStatus | null;
    createdAt: Date | null;
    reviewedAt: Date | null;
    reviewedByUserId: string | null;
  };

  export type EventRegistrationRequestMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    message: string | null;
    status: $Enums.RegistrationRequestStatus | null;
    createdAt: Date | null;
    reviewedAt: Date | null;
    reviewedByUserId: string | null;
  };

  export type EventRegistrationRequestCountAggregateOutputType = {
    id: number;
    eventId: number;
    userId: number;
    message: number;
    status: number;
    createdAt: number;
    reviewedAt: number;
    reviewedByUserId: number;
    _all: number;
  };

  export type EventRegistrationRequestMinAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    reviewedAt?: true;
    reviewedByUserId?: true;
  };

  export type EventRegistrationRequestMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    reviewedAt?: true;
    reviewedByUserId?: true;
  };

  export type EventRegistrationRequestCountAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    reviewedAt?: true;
    reviewedByUserId?: true;
    _all?: true;
  };

  export type EventRegistrationRequestAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EventRegistrationRequest to aggregate.
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventRegistrationRequests to fetch.
     */
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EventRegistrationRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventRegistrationRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventRegistrationRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EventRegistrationRequests
     **/
    _count?: true | EventRegistrationRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventRegistrationRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventRegistrationRequestMaxAggregateInputType;
  };

  export type GetEventRegistrationRequestAggregateType<
    T extends EventRegistrationRequestAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateEventRegistrationRequest]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistrationRequest[P]>
      : GetScalarType<T[P], AggregateEventRegistrationRequest[P]>;
  };

  export type EventRegistrationRequestGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventRegistrationRequestWhereInput;
    orderBy?:
      | EventRegistrationRequestOrderByWithAggregationInput
      | EventRegistrationRequestOrderByWithAggregationInput[];
    by:
      | EventRegistrationRequestScalarFieldEnum[]
      | EventRegistrationRequestScalarFieldEnum;
    having?: EventRegistrationRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EventRegistrationRequestCountAggregateInputType | true;
    _min?: EventRegistrationRequestMinAggregateInputType;
    _max?: EventRegistrationRequestMaxAggregateInputType;
  };

  export type EventRegistrationRequestGroupByOutputType = {
    id: string;
    eventId: string;
    userId: string;
    message: string | null;
    status: $Enums.RegistrationRequestStatus;
    createdAt: Date;
    reviewedAt: Date | null;
    reviewedByUserId: string | null;
    _count: EventRegistrationRequestCountAggregateOutputType | null;
    _min: EventRegistrationRequestMinAggregateOutputType | null;
    _max: EventRegistrationRequestMaxAggregateOutputType | null;
  };

  type GetEventRegistrationRequestGroupByPayload<
    T extends EventRegistrationRequestGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRegistrationRequestGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof EventRegistrationRequestGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EventRegistrationRequestGroupByOutputType[P]>
          : GetScalarType<T[P], EventRegistrationRequestGroupByOutputType[P]>;
      }
    >
  >;

  export type EventRegistrationRequestSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      message?: boolean;
      status?: boolean;
      createdAt?: boolean;
      reviewedAt?: boolean;
      reviewedByUserId?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["eventRegistrationRequest"]
  >;

  export type EventRegistrationRequestSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    userId?: boolean;
    message?: boolean;
    status?: boolean;
    createdAt?: boolean;
    reviewedAt?: boolean;
    reviewedByUserId?: boolean;
  };

  export type EventRegistrationRequestOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "userId"
    | "message"
    | "status"
    | "createdAt"
    | "reviewedAt"
    | "reviewedByUserId",
    ExtArgs["result"]["eventRegistrationRequest"]
  >;
  export type EventRegistrationRequestInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $EventRegistrationRequestPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "EventRegistrationRequest";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        userId: string;
        message: string | null;
        status: $Enums.RegistrationRequestStatus;
        createdAt: Date;
        reviewedAt: Date | null;
        reviewedByUserId: string | null;
      },
      ExtArgs["result"]["eventRegistrationRequest"]
    >;
    composites: {};
  };

  type EventRegistrationRequestGetPayload<
    S extends boolean | null | undefined | EventRegistrationRequestDefaultArgs,
  > = $Result.GetResult<Prisma.$EventRegistrationRequestPayload, S>;

  type EventRegistrationRequestCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    EventRegistrationRequestFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: EventRegistrationRequestCountAggregateInputType | true;
  };

  export interface EventRegistrationRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["EventRegistrationRequest"];
      meta: { name: "EventRegistrationRequest" };
    };
    /**
     * Find zero or one EventRegistrationRequest that matches the filter.
     * @param {EventRegistrationRequestFindUniqueArgs} args - Arguments to find a EventRegistrationRequest
     * @example
     * // Get one EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRegistrationRequestFindUniqueArgs>(
      args: SelectSubset<T, EventRegistrationRequestFindUniqueArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one EventRegistrationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventRegistrationRequestFindUniqueOrThrowArgs} args - Arguments to find a EventRegistrationRequest
     * @example
     * // Get one EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRegistrationRequestFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        EventRegistrationRequestFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EventRegistrationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestFindFirstArgs} args - Arguments to find a EventRegistrationRequest
     * @example
     * // Get one EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRegistrationRequestFindFirstArgs>(
      args?: SelectSubset<T, EventRegistrationRequestFindFirstArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EventRegistrationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestFindFirstOrThrowArgs} args - Arguments to find a EventRegistrationRequest
     * @example
     * // Get one EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRegistrationRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        EventRegistrationRequestFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more EventRegistrationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrationRequests
     * const eventRegistrationRequests = await prisma.eventRegistrationRequest.findMany()
     *
     * // Get first 10 EventRegistrationRequests
     * const eventRegistrationRequests = await prisma.eventRegistrationRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const eventRegistrationRequestWithIdOnly = await prisma.eventRegistrationRequest.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EventRegistrationRequestFindManyArgs>(
      args?: SelectSubset<T, EventRegistrationRequestFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a EventRegistrationRequest.
     * @param {EventRegistrationRequestCreateArgs} args - Arguments to create a EventRegistrationRequest.
     * @example
     * // Create one EventRegistrationRequest
     * const EventRegistrationRequest = await prisma.eventRegistrationRequest.create({
     *   data: {
     *     // ... data to create a EventRegistrationRequest
     *   }
     * })
     *
     */
    create<T extends EventRegistrationRequestCreateArgs>(
      args: SelectSubset<T, EventRegistrationRequestCreateArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many EventRegistrationRequests.
     * @param {EventRegistrationRequestCreateManyArgs} args - Arguments to create many EventRegistrationRequests.
     * @example
     * // Create many EventRegistrationRequests
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EventRegistrationRequestCreateManyArgs>(
      args?: SelectSubset<T, EventRegistrationRequestCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a EventRegistrationRequest.
     * @param {EventRegistrationRequestDeleteArgs} args - Arguments to delete one EventRegistrationRequest.
     * @example
     * // Delete one EventRegistrationRequest
     * const EventRegistrationRequest = await prisma.eventRegistrationRequest.delete({
     *   where: {
     *     // ... filter to delete one EventRegistrationRequest
     *   }
     * })
     *
     */
    delete<T extends EventRegistrationRequestDeleteArgs>(
      args: SelectSubset<T, EventRegistrationRequestDeleteArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one EventRegistrationRequest.
     * @param {EventRegistrationRequestUpdateArgs} args - Arguments to update one EventRegistrationRequest.
     * @example
     * // Update one EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EventRegistrationRequestUpdateArgs>(
      args: SelectSubset<T, EventRegistrationRequestUpdateArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more EventRegistrationRequests.
     * @param {EventRegistrationRequestDeleteManyArgs} args - Arguments to filter EventRegistrationRequests to delete.
     * @example
     * // Delete a few EventRegistrationRequests
     * const { count } = await prisma.eventRegistrationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EventRegistrationRequestDeleteManyArgs>(
      args?: SelectSubset<T, EventRegistrationRequestDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EventRegistrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrationRequests
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EventRegistrationRequestUpdateManyArgs>(
      args: SelectSubset<T, EventRegistrationRequestUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one EventRegistrationRequest.
     * @param {EventRegistrationRequestUpsertArgs} args - Arguments to update or create a EventRegistrationRequest.
     * @example
     * // Update or create a EventRegistrationRequest
     * const eventRegistrationRequest = await prisma.eventRegistrationRequest.upsert({
     *   create: {
     *     // ... data to create a EventRegistrationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistrationRequest we want to update
     *   }
     * })
     */
    upsert<T extends EventRegistrationRequestUpsertArgs>(
      args: SelectSubset<T, EventRegistrationRequestUpsertArgs<ExtArgs>>,
    ): Prisma__EventRegistrationRequestClient<
      $Result.GetResult<
        Prisma.$EventRegistrationRequestPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of EventRegistrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestCountArgs} args - Arguments to filter EventRegistrationRequests to count.
     * @example
     * // Count the number of EventRegistrationRequests
     * const count = await prisma.eventRegistrationRequest.count({
     *   where: {
     *     // ... the filter for the EventRegistrationRequests we want to count
     *   }
     * })
     **/
    count<T extends EventRegistrationRequestCountArgs>(
      args?: Subset<T, EventRegistrationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              EventRegistrationRequestCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a EventRegistrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventRegistrationRequestAggregateArgs>(
      args: Subset<T, EventRegistrationRequestAggregateArgs>,
    ): Prisma.PrismaPromise<GetEventRegistrationRequestAggregateType<T>>;

    /**
     * Group by EventRegistrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EventRegistrationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationRequestGroupByArgs["orderBy"] }
        : { orderBy?: EventRegistrationRequestGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        EventRegistrationRequestGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetEventRegistrationRequestGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the EventRegistrationRequest model
     */
    readonly fields: EventRegistrationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistrationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRegistrationRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the EventRegistrationRequest model
   */
  interface EventRegistrationRequestFieldRefs {
    readonly id: FieldRef<"EventRegistrationRequest", "String">;
    readonly eventId: FieldRef<"EventRegistrationRequest", "String">;
    readonly userId: FieldRef<"EventRegistrationRequest", "String">;
    readonly message: FieldRef<"EventRegistrationRequest", "String">;
    readonly status: FieldRef<
      "EventRegistrationRequest",
      "RegistrationRequestStatus"
    >;
    readonly createdAt: FieldRef<"EventRegistrationRequest", "DateTime">;
    readonly reviewedAt: FieldRef<"EventRegistrationRequest", "DateTime">;
    readonly reviewedByUserId: FieldRef<"EventRegistrationRequest", "String">;
  }

  // Custom InputTypes
  /**
   * EventRegistrationRequest findUnique
   */
  export type EventRegistrationRequestFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter, which EventRegistrationRequest to fetch.
     */
    where: EventRegistrationRequestWhereUniqueInput;
  };

  /**
   * EventRegistrationRequest findUniqueOrThrow
   */
  export type EventRegistrationRequestFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter, which EventRegistrationRequest to fetch.
     */
    where: EventRegistrationRequestWhereUniqueInput;
  };

  /**
   * EventRegistrationRequest findFirst
   */
  export type EventRegistrationRequestFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter, which EventRegistrationRequest to fetch.
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventRegistrationRequests to fetch.
     */
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EventRegistrationRequests.
     */
    cursor?: EventRegistrationRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventRegistrationRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventRegistrationRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EventRegistrationRequests.
     */
    distinct?:
      | EventRegistrationRequestScalarFieldEnum
      | EventRegistrationRequestScalarFieldEnum[];
  };

  /**
   * EventRegistrationRequest findFirstOrThrow
   */
  export type EventRegistrationRequestFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter, which EventRegistrationRequest to fetch.
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventRegistrationRequests to fetch.
     */
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EventRegistrationRequests.
     */
    cursor?: EventRegistrationRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventRegistrationRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventRegistrationRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EventRegistrationRequests.
     */
    distinct?:
      | EventRegistrationRequestScalarFieldEnum
      | EventRegistrationRequestScalarFieldEnum[];
  };

  /**
   * EventRegistrationRequest findMany
   */
  export type EventRegistrationRequestFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter, which EventRegistrationRequests to fetch.
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventRegistrationRequests to fetch.
     */
    orderBy?:
      | EventRegistrationRequestOrderByWithRelationInput
      | EventRegistrationRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EventRegistrationRequests.
     */
    cursor?: EventRegistrationRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventRegistrationRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventRegistrationRequests.
     */
    skip?: number;
    distinct?:
      | EventRegistrationRequestScalarFieldEnum
      | EventRegistrationRequestScalarFieldEnum[];
  };

  /**
   * EventRegistrationRequest create
   */
  export type EventRegistrationRequestCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a EventRegistrationRequest.
     */
    data: XOR<
      EventRegistrationRequestCreateInput,
      EventRegistrationRequestUncheckedCreateInput
    >;
  };

  /**
   * EventRegistrationRequest createMany
   */
  export type EventRegistrationRequestCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many EventRegistrationRequests.
     */
    data:
      | EventRegistrationRequestCreateManyInput
      | EventRegistrationRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EventRegistrationRequest update
   */
  export type EventRegistrationRequestUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a EventRegistrationRequest.
     */
    data: XOR<
      EventRegistrationRequestUpdateInput,
      EventRegistrationRequestUncheckedUpdateInput
    >;
    /**
     * Choose, which EventRegistrationRequest to update.
     */
    where: EventRegistrationRequestWhereUniqueInput;
  };

  /**
   * EventRegistrationRequest updateMany
   */
  export type EventRegistrationRequestUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update EventRegistrationRequests.
     */
    data: XOR<
      EventRegistrationRequestUpdateManyMutationInput,
      EventRegistrationRequestUncheckedUpdateManyInput
    >;
    /**
     * Filter which EventRegistrationRequests to update
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * Limit how many EventRegistrationRequests to update.
     */
    limit?: number;
  };

  /**
   * EventRegistrationRequest upsert
   */
  export type EventRegistrationRequestUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the EventRegistrationRequest to update in case it exists.
     */
    where: EventRegistrationRequestWhereUniqueInput;
    /**
     * In case the EventRegistrationRequest found by the `where` argument doesn't exist, create a new EventRegistrationRequest with this data.
     */
    create: XOR<
      EventRegistrationRequestCreateInput,
      EventRegistrationRequestUncheckedCreateInput
    >;
    /**
     * In case the EventRegistrationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      EventRegistrationRequestUpdateInput,
      EventRegistrationRequestUncheckedUpdateInput
    >;
  };

  /**
   * EventRegistrationRequest delete
   */
  export type EventRegistrationRequestDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
    /**
     * Filter which EventRegistrationRequest to delete.
     */
    where: EventRegistrationRequestWhereUniqueInput;
  };

  /**
   * EventRegistrationRequest deleteMany
   */
  export type EventRegistrationRequestDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EventRegistrationRequests to delete
     */
    where?: EventRegistrationRequestWhereInput;
    /**
     * Limit how many EventRegistrationRequests to delete.
     */
    limit?: number;
  };

  /**
   * EventRegistrationRequest without action
   */
  export type EventRegistrationRequestDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventRegistrationRequest
     */
    select?: EventRegistrationRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventRegistrationRequest
     */
    omit?: EventRegistrationRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationRequestInclude<ExtArgs> | null;
  };

  /**
   * Model EventParticipant
   */

  export type AggregateEventParticipant = {
    _count: EventParticipantCountAggregateOutputType | null;
    _min: EventParticipantMinAggregateOutputType | null;
    _max: EventParticipantMaxAggregateOutputType | null;
  };

  export type EventParticipantMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    status: $Enums.ParticipantStatus | null;
    newsletterOptIn: boolean | null;
    contactEmail: string | null;
    lookingForTeam: boolean | null;
    trackPreference: string | null;
    experienceLevel: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventParticipantMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    status: $Enums.ParticipantStatus | null;
    newsletterOptIn: boolean | null;
    contactEmail: string | null;
    lookingForTeam: boolean | null;
    trackPreference: string | null;
    experienceLevel: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type EventParticipantCountAggregateOutputType = {
    id: number;
    eventId: number;
    userId: number;
    status: number;
    newsletterOptIn: number;
    contactEmail: number;
    lookingForTeam: number;
    trackPreference: number;
    skills: number;
    interests: number;
    experienceLevel: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type EventParticipantMinAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    status?: true;
    newsletterOptIn?: true;
    contactEmail?: true;
    lookingForTeam?: true;
    trackPreference?: true;
    experienceLevel?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventParticipantMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    status?: true;
    newsletterOptIn?: true;
    contactEmail?: true;
    lookingForTeam?: true;
    trackPreference?: true;
    experienceLevel?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type EventParticipantCountAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    status?: true;
    newsletterOptIn?: true;
    contactEmail?: true;
    lookingForTeam?: true;
    trackPreference?: true;
    skills?: true;
    interests?: true;
    experienceLevel?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type EventParticipantAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EventParticipant to aggregate.
     */
    where?: EventParticipantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EventParticipantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventParticipants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EventParticipants
     **/
    _count?: true | EventParticipantCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventParticipantMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventParticipantMaxAggregateInputType;
  };

  export type GetEventParticipantAggregateType<
    T extends EventParticipantAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateEventParticipant]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventParticipant[P]>
      : GetScalarType<T[P], AggregateEventParticipant[P]>;
  };

  export type EventParticipantGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EventParticipantWhereInput;
    orderBy?:
      | EventParticipantOrderByWithAggregationInput
      | EventParticipantOrderByWithAggregationInput[];
    by: EventParticipantScalarFieldEnum[] | EventParticipantScalarFieldEnum;
    having?: EventParticipantScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EventParticipantCountAggregateInputType | true;
    _min?: EventParticipantMinAggregateInputType;
    _max?: EventParticipantMaxAggregateInputType;
  };

  export type EventParticipantGroupByOutputType = {
    id: string;
    eventId: string;
    userId: string;
    status: $Enums.ParticipantStatus;
    newsletterOptIn: boolean;
    contactEmail: string | null;
    lookingForTeam: boolean;
    trackPreference: string | null;
    skills: JsonValue | null;
    interests: JsonValue | null;
    experienceLevel: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: EventParticipantCountAggregateOutputType | null;
    _min: EventParticipantMinAggregateOutputType | null;
    _max: EventParticipantMaxAggregateOutputType | null;
  };

  type GetEventParticipantGroupByPayload<
    T extends EventParticipantGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventParticipantGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof EventParticipantGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>
          : GetScalarType<T[P], EventParticipantGroupByOutputType[P]>;
      }
    >
  >;

  export type EventParticipantSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      status?: boolean;
      newsletterOptIn?: boolean;
      contactEmail?: boolean;
      lookingForTeam?: boolean;
      trackPreference?: boolean;
      skills?: boolean;
      interests?: boolean;
      experienceLevel?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["eventParticipant"]
  >;

  export type EventParticipantSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    userId?: boolean;
    status?: boolean;
    newsletterOptIn?: boolean;
    contactEmail?: boolean;
    lookingForTeam?: boolean;
    trackPreference?: boolean;
    skills?: boolean;
    interests?: boolean;
    experienceLevel?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type EventParticipantOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "userId"
    | "status"
    | "newsletterOptIn"
    | "contactEmail"
    | "lookingForTeam"
    | "trackPreference"
    | "skills"
    | "interests"
    | "experienceLevel"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["eventParticipant"]
  >;
  export type EventParticipantInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $EventParticipantPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "EventParticipant";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        userId: string;
        status: $Enums.ParticipantStatus;
        newsletterOptIn: boolean;
        contactEmail: string | null;
        lookingForTeam: boolean;
        trackPreference: string | null;
        skills: Prisma.JsonValue | null;
        interests: Prisma.JsonValue | null;
        experienceLevel: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["eventParticipant"]
    >;
    composites: {};
  };

  type EventParticipantGetPayload<
    S extends boolean | null | undefined | EventParticipantDefaultArgs,
  > = $Result.GetResult<Prisma.$EventParticipantPayload, S>;

  type EventParticipantCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    EventParticipantFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: EventParticipantCountAggregateInputType | true;
  };

  export interface EventParticipantDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["EventParticipant"];
      meta: { name: "EventParticipant" };
    };
    /**
     * Find zero or one EventParticipant that matches the filter.
     * @param {EventParticipantFindUniqueArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventParticipantFindUniqueArgs>(
      args: SelectSubset<T, EventParticipantFindUniqueArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one EventParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventParticipantFindUniqueOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventParticipantFindUniqueOrThrowArgs>(
      args: SelectSubset<T, EventParticipantFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EventParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventParticipantFindFirstArgs>(
      args?: SelectSubset<T, EventParticipantFindFirstArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first EventParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindFirstOrThrowArgs} args - Arguments to find a EventParticipant
     * @example
     * // Get one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventParticipantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventParticipantFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more EventParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany()
     *
     * // Get first 10 EventParticipants
     * const eventParticipants = await prisma.eventParticipant.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const eventParticipantWithIdOnly = await prisma.eventParticipant.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EventParticipantFindManyArgs>(
      args?: SelectSubset<T, EventParticipantFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a EventParticipant.
     * @param {EventParticipantCreateArgs} args - Arguments to create a EventParticipant.
     * @example
     * // Create one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.create({
     *   data: {
     *     // ... data to create a EventParticipant
     *   }
     * })
     *
     */
    create<T extends EventParticipantCreateArgs>(
      args: SelectSubset<T, EventParticipantCreateArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many EventParticipants.
     * @param {EventParticipantCreateManyArgs} args - Arguments to create many EventParticipants.
     * @example
     * // Create many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EventParticipantCreateManyArgs>(
      args?: SelectSubset<T, EventParticipantCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a EventParticipant.
     * @param {EventParticipantDeleteArgs} args - Arguments to delete one EventParticipant.
     * @example
     * // Delete one EventParticipant
     * const EventParticipant = await prisma.eventParticipant.delete({
     *   where: {
     *     // ... filter to delete one EventParticipant
     *   }
     * })
     *
     */
    delete<T extends EventParticipantDeleteArgs>(
      args: SelectSubset<T, EventParticipantDeleteArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one EventParticipant.
     * @param {EventParticipantUpdateArgs} args - Arguments to update one EventParticipant.
     * @example
     * // Update one EventParticipant
     * const eventParticipant = await prisma.eventParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EventParticipantUpdateArgs>(
      args: SelectSubset<T, EventParticipantUpdateArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more EventParticipants.
     * @param {EventParticipantDeleteManyArgs} args - Arguments to filter EventParticipants to delete.
     * @example
     * // Delete a few EventParticipants
     * const { count } = await prisma.eventParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EventParticipantDeleteManyArgs>(
      args?: SelectSubset<T, EventParticipantDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventParticipants
     * const eventParticipant = await prisma.eventParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EventParticipantUpdateManyArgs>(
      args: SelectSubset<T, EventParticipantUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one EventParticipant.
     * @param {EventParticipantUpsertArgs} args - Arguments to update or create a EventParticipant.
     * @example
     * // Update or create a EventParticipant
     * const eventParticipant = await prisma.eventParticipant.upsert({
     *   create: {
     *     // ... data to create a EventParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventParticipant we want to update
     *   }
     * })
     */
    upsert<T extends EventParticipantUpsertArgs>(
      args: SelectSubset<T, EventParticipantUpsertArgs<ExtArgs>>,
    ): Prisma__EventParticipantClient<
      $Result.GetResult<
        Prisma.$EventParticipantPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of EventParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantCountArgs} args - Arguments to filter EventParticipants to count.
     * @example
     * // Count the number of EventParticipants
     * const count = await prisma.eventParticipant.count({
     *   where: {
     *     // ... the filter for the EventParticipants we want to count
     *   }
     * })
     **/
    count<T extends EventParticipantCountArgs>(
      args?: Subset<T, EventParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EventParticipantCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventParticipantAggregateArgs>(
      args: Subset<T, EventParticipantAggregateArgs>,
    ): Prisma.PrismaPromise<GetEventParticipantAggregateType<T>>;

    /**
     * Group by EventParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EventParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventParticipantGroupByArgs["orderBy"] }
        : { orderBy?: EventParticipantGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, EventParticipantGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetEventParticipantGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the EventParticipant model
     */
    readonly fields: EventParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventParticipantClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the EventParticipant model
   */
  interface EventParticipantFieldRefs {
    readonly id: FieldRef<"EventParticipant", "String">;
    readonly eventId: FieldRef<"EventParticipant", "String">;
    readonly userId: FieldRef<"EventParticipant", "String">;
    readonly status: FieldRef<"EventParticipant", "ParticipantStatus">;
    readonly newsletterOptIn: FieldRef<"EventParticipant", "Boolean">;
    readonly contactEmail: FieldRef<"EventParticipant", "String">;
    readonly lookingForTeam: FieldRef<"EventParticipant", "Boolean">;
    readonly trackPreference: FieldRef<"EventParticipant", "String">;
    readonly skills: FieldRef<"EventParticipant", "Json">;
    readonly interests: FieldRef<"EventParticipant", "Json">;
    readonly experienceLevel: FieldRef<"EventParticipant", "String">;
    readonly createdAt: FieldRef<"EventParticipant", "DateTime">;
    readonly updatedAt: FieldRef<"EventParticipant", "DateTime">;
  }

  // Custom InputTypes
  /**
   * EventParticipant findUnique
   */
  export type EventParticipantFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput;
  };

  /**
   * EventParticipant findUniqueOrThrow
   */
  export type EventParticipantFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter, which EventParticipant to fetch.
     */
    where: EventParticipantWhereUniqueInput;
  };

  /**
   * EventParticipant findFirst
   */
  export type EventParticipantFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventParticipants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EventParticipants.
     */
    distinct?:
      | EventParticipantScalarFieldEnum
      | EventParticipantScalarFieldEnum[];
  };

  /**
   * EventParticipant findFirstOrThrow
   */
  export type EventParticipantFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter, which EventParticipant to fetch.
     */
    where?: EventParticipantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventParticipants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EventParticipants.
     */
    distinct?:
      | EventParticipantScalarFieldEnum
      | EventParticipantScalarFieldEnum[];
  };

  /**
   * EventParticipant findMany
   */
  export type EventParticipantFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter, which EventParticipants to fetch.
     */
    where?: EventParticipantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EventParticipants to fetch.
     */
    orderBy?:
      | EventParticipantOrderByWithRelationInput
      | EventParticipantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EventParticipants.
     */
    cursor?: EventParticipantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EventParticipants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EventParticipants.
     */
    skip?: number;
    distinct?:
      | EventParticipantScalarFieldEnum
      | EventParticipantScalarFieldEnum[];
  };

  /**
   * EventParticipant create
   */
  export type EventParticipantCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * The data needed to create a EventParticipant.
     */
    data: XOR<
      EventParticipantCreateInput,
      EventParticipantUncheckedCreateInput
    >;
  };

  /**
   * EventParticipant createMany
   */
  export type EventParticipantCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many EventParticipants.
     */
    data: EventParticipantCreateManyInput | EventParticipantCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EventParticipant update
   */
  export type EventParticipantUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * The data needed to update a EventParticipant.
     */
    data: XOR<
      EventParticipantUpdateInput,
      EventParticipantUncheckedUpdateInput
    >;
    /**
     * Choose, which EventParticipant to update.
     */
    where: EventParticipantWhereUniqueInput;
  };

  /**
   * EventParticipant updateMany
   */
  export type EventParticipantUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update EventParticipants.
     */
    data: XOR<
      EventParticipantUpdateManyMutationInput,
      EventParticipantUncheckedUpdateManyInput
    >;
    /**
     * Filter which EventParticipants to update
     */
    where?: EventParticipantWhereInput;
    /**
     * Limit how many EventParticipants to update.
     */
    limit?: number;
  };

  /**
   * EventParticipant upsert
   */
  export type EventParticipantUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * The filter to search for the EventParticipant to update in case it exists.
     */
    where: EventParticipantWhereUniqueInput;
    /**
     * In case the EventParticipant found by the `where` argument doesn't exist, create a new EventParticipant with this data.
     */
    create: XOR<
      EventParticipantCreateInput,
      EventParticipantUncheckedCreateInput
    >;
    /**
     * In case the EventParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      EventParticipantUpdateInput,
      EventParticipantUncheckedUpdateInput
    >;
  };

  /**
   * EventParticipant delete
   */
  export type EventParticipantDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
    /**
     * Filter which EventParticipant to delete.
     */
    where: EventParticipantWhereUniqueInput;
  };

  /**
   * EventParticipant deleteMany
   */
  export type EventParticipantDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EventParticipants to delete
     */
    where?: EventParticipantWhereInput;
    /**
     * Limit how many EventParticipants to delete.
     */
    limit?: number;
  };

  /**
   * EventParticipant without action
   */
  export type EventParticipantDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EventParticipant
     */
    select?: EventParticipantSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the EventParticipant
     */
    omit?: EventParticipantOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventParticipantInclude<ExtArgs> | null;
  };

  /**
   * Model SubmissionSchema
   */

  export type AggregateSubmissionSchema = {
    _count: SubmissionSchemaCountAggregateOutputType | null;
    _min: SubmissionSchemaMinAggregateOutputType | null;
    _max: SubmissionSchemaMaxAggregateOutputType | null;
  };

  export type SubmissionSchemaMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
  };

  export type SubmissionSchemaMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
  };

  export type SubmissionSchemaCountAggregateOutputType = {
    id: number;
    eventId: number;
    fields: number;
    _all: number;
  };

  export type SubmissionSchemaMinAggregateInputType = {
    id?: true;
    eventId?: true;
  };

  export type SubmissionSchemaMaxAggregateInputType = {
    id?: true;
    eventId?: true;
  };

  export type SubmissionSchemaCountAggregateInputType = {
    id?: true;
    eventId?: true;
    fields?: true;
    _all?: true;
  };

  export type SubmissionSchemaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SubmissionSchema to aggregate.
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubmissionSchemas to fetch.
     */
    orderBy?:
      | SubmissionSchemaOrderByWithRelationInput
      | SubmissionSchemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubmissionSchemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubmissionSchemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubmissionSchemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SubmissionSchemas
     **/
    _count?: true | SubmissionSchemaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubmissionSchemaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubmissionSchemaMaxAggregateInputType;
  };

  export type GetSubmissionSchemaAggregateType<
    T extends SubmissionSchemaAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateSubmissionSchema]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionSchema[P]>
      : GetScalarType<T[P], AggregateSubmissionSchema[P]>;
  };

  export type SubmissionSchemaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionSchemaWhereInput;
    orderBy?:
      | SubmissionSchemaOrderByWithAggregationInput
      | SubmissionSchemaOrderByWithAggregationInput[];
    by: SubmissionSchemaScalarFieldEnum[] | SubmissionSchemaScalarFieldEnum;
    having?: SubmissionSchemaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubmissionSchemaCountAggregateInputType | true;
    _min?: SubmissionSchemaMinAggregateInputType;
    _max?: SubmissionSchemaMaxAggregateInputType;
  };

  export type SubmissionSchemaGroupByOutputType = {
    id: string;
    eventId: string;
    fields: JsonValue;
    _count: SubmissionSchemaCountAggregateOutputType | null;
    _min: SubmissionSchemaMinAggregateOutputType | null;
    _max: SubmissionSchemaMaxAggregateOutputType | null;
  };

  type GetSubmissionSchemaGroupByPayload<
    T extends SubmissionSchemaGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionSchemaGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof SubmissionSchemaGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SubmissionSchemaGroupByOutputType[P]>
          : GetScalarType<T[P], SubmissionSchemaGroupByOutputType[P]>;
      }
    >
  >;

  export type SubmissionSchemaSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      fields?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["submissionSchema"]
  >;

  export type SubmissionSchemaSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    fields?: boolean;
  };

  export type SubmissionSchemaOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "eventId" | "fields",
    ExtArgs["result"]["submissionSchema"]
  >;
  export type SubmissionSchemaInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
  };

  export type $SubmissionSchemaPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "SubmissionSchema";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        fields: Prisma.JsonValue;
      },
      ExtArgs["result"]["submissionSchema"]
    >;
    composites: {};
  };

  type SubmissionSchemaGetPayload<
    S extends boolean | null | undefined | SubmissionSchemaDefaultArgs,
  > = $Result.GetResult<Prisma.$SubmissionSchemaPayload, S>;

  type SubmissionSchemaCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SubmissionSchemaFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SubmissionSchemaCountAggregateInputType | true;
  };

  export interface SubmissionSchemaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["SubmissionSchema"];
      meta: { name: "SubmissionSchema" };
    };
    /**
     * Find zero or one SubmissionSchema that matches the filter.
     * @param {SubmissionSchemaFindUniqueArgs} args - Arguments to find a SubmissionSchema
     * @example
     * // Get one SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionSchemaFindUniqueArgs>(
      args: SelectSubset<T, SubmissionSchemaFindUniqueArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SubmissionSchema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionSchemaFindUniqueOrThrowArgs} args - Arguments to find a SubmissionSchema
     * @example
     * // Get one SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionSchemaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubmissionSchemaFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SubmissionSchema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaFindFirstArgs} args - Arguments to find a SubmissionSchema
     * @example
     * // Get one SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionSchemaFindFirstArgs>(
      args?: SelectSubset<T, SubmissionSchemaFindFirstArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SubmissionSchema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaFindFirstOrThrowArgs} args - Arguments to find a SubmissionSchema
     * @example
     * // Get one SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionSchemaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubmissionSchemaFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SubmissionSchemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionSchemas
     * const submissionSchemas = await prisma.submissionSchema.findMany()
     *
     * // Get first 10 SubmissionSchemas
     * const submissionSchemas = await prisma.submissionSchema.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const submissionSchemaWithIdOnly = await prisma.submissionSchema.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubmissionSchemaFindManyArgs>(
      args?: SelectSubset<T, SubmissionSchemaFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SubmissionSchema.
     * @param {SubmissionSchemaCreateArgs} args - Arguments to create a SubmissionSchema.
     * @example
     * // Create one SubmissionSchema
     * const SubmissionSchema = await prisma.submissionSchema.create({
     *   data: {
     *     // ... data to create a SubmissionSchema
     *   }
     * })
     *
     */
    create<T extends SubmissionSchemaCreateArgs>(
      args: SelectSubset<T, SubmissionSchemaCreateArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SubmissionSchemas.
     * @param {SubmissionSchemaCreateManyArgs} args - Arguments to create many SubmissionSchemas.
     * @example
     * // Create many SubmissionSchemas
     * const submissionSchema = await prisma.submissionSchema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubmissionSchemaCreateManyArgs>(
      args?: SelectSubset<T, SubmissionSchemaCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a SubmissionSchema.
     * @param {SubmissionSchemaDeleteArgs} args - Arguments to delete one SubmissionSchema.
     * @example
     * // Delete one SubmissionSchema
     * const SubmissionSchema = await prisma.submissionSchema.delete({
     *   where: {
     *     // ... filter to delete one SubmissionSchema
     *   }
     * })
     *
     */
    delete<T extends SubmissionSchemaDeleteArgs>(
      args: SelectSubset<T, SubmissionSchemaDeleteArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SubmissionSchema.
     * @param {SubmissionSchemaUpdateArgs} args - Arguments to update one SubmissionSchema.
     * @example
     * // Update one SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubmissionSchemaUpdateArgs>(
      args: SelectSubset<T, SubmissionSchemaUpdateArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SubmissionSchemas.
     * @param {SubmissionSchemaDeleteManyArgs} args - Arguments to filter SubmissionSchemas to delete.
     * @example
     * // Delete a few SubmissionSchemas
     * const { count } = await prisma.submissionSchema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubmissionSchemaDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionSchemaDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SubmissionSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionSchemas
     * const submissionSchema = await prisma.submissionSchema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubmissionSchemaUpdateManyArgs>(
      args: SelectSubset<T, SubmissionSchemaUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one SubmissionSchema.
     * @param {SubmissionSchemaUpsertArgs} args - Arguments to update or create a SubmissionSchema.
     * @example
     * // Update or create a SubmissionSchema
     * const submissionSchema = await prisma.submissionSchema.upsert({
     *   create: {
     *     // ... data to create a SubmissionSchema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionSchema we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionSchemaUpsertArgs>(
      args: SelectSubset<T, SubmissionSchemaUpsertArgs<ExtArgs>>,
    ): Prisma__SubmissionSchemaClient<
      $Result.GetResult<
        Prisma.$SubmissionSchemaPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SubmissionSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaCountArgs} args - Arguments to filter SubmissionSchemas to count.
     * @example
     * // Count the number of SubmissionSchemas
     * const count = await prisma.submissionSchema.count({
     *   where: {
     *     // ... the filter for the SubmissionSchemas we want to count
     *   }
     * })
     **/
    count<T extends SubmissionSchemaCountArgs>(
      args?: Subset<T, SubmissionSchemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubmissionSchemaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SubmissionSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubmissionSchemaAggregateArgs>(
      args: Subset<T, SubmissionSchemaAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubmissionSchemaAggregateType<T>>;

    /**
     * Group by SubmissionSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionSchemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubmissionSchemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionSchemaGroupByArgs["orderBy"] }
        : { orderBy?: SubmissionSchemaGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubmissionSchemaGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSubmissionSchemaGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SubmissionSchema model
     */
    readonly fields: SubmissionSchemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionSchema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionSchemaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SubmissionSchema model
   */
  interface SubmissionSchemaFieldRefs {
    readonly id: FieldRef<"SubmissionSchema", "String">;
    readonly eventId: FieldRef<"SubmissionSchema", "String">;
    readonly fields: FieldRef<"SubmissionSchema", "Json">;
  }

  // Custom InputTypes
  /**
   * SubmissionSchema findUnique
   */
  export type SubmissionSchemaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter, which SubmissionSchema to fetch.
     */
    where: SubmissionSchemaWhereUniqueInput;
  };

  /**
   * SubmissionSchema findUniqueOrThrow
   */
  export type SubmissionSchemaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter, which SubmissionSchema to fetch.
     */
    where: SubmissionSchemaWhereUniqueInput;
  };

  /**
   * SubmissionSchema findFirst
   */
  export type SubmissionSchemaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter, which SubmissionSchema to fetch.
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubmissionSchemas to fetch.
     */
    orderBy?:
      | SubmissionSchemaOrderByWithRelationInput
      | SubmissionSchemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SubmissionSchemas.
     */
    cursor?: SubmissionSchemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubmissionSchemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubmissionSchemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SubmissionSchemas.
     */
    distinct?:
      | SubmissionSchemaScalarFieldEnum
      | SubmissionSchemaScalarFieldEnum[];
  };

  /**
   * SubmissionSchema findFirstOrThrow
   */
  export type SubmissionSchemaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter, which SubmissionSchema to fetch.
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubmissionSchemas to fetch.
     */
    orderBy?:
      | SubmissionSchemaOrderByWithRelationInput
      | SubmissionSchemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SubmissionSchemas.
     */
    cursor?: SubmissionSchemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubmissionSchemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubmissionSchemas.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SubmissionSchemas.
     */
    distinct?:
      | SubmissionSchemaScalarFieldEnum
      | SubmissionSchemaScalarFieldEnum[];
  };

  /**
   * SubmissionSchema findMany
   */
  export type SubmissionSchemaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter, which SubmissionSchemas to fetch.
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubmissionSchemas to fetch.
     */
    orderBy?:
      | SubmissionSchemaOrderByWithRelationInput
      | SubmissionSchemaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SubmissionSchemas.
     */
    cursor?: SubmissionSchemaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubmissionSchemas from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubmissionSchemas.
     */
    skip?: number;
    distinct?:
      | SubmissionSchemaScalarFieldEnum
      | SubmissionSchemaScalarFieldEnum[];
  };

  /**
   * SubmissionSchema create
   */
  export type SubmissionSchemaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * The data needed to create a SubmissionSchema.
     */
    data: XOR<
      SubmissionSchemaCreateInput,
      SubmissionSchemaUncheckedCreateInput
    >;
  };

  /**
   * SubmissionSchema createMany
   */
  export type SubmissionSchemaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SubmissionSchemas.
     */
    data: SubmissionSchemaCreateManyInput | SubmissionSchemaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SubmissionSchema update
   */
  export type SubmissionSchemaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * The data needed to update a SubmissionSchema.
     */
    data: XOR<
      SubmissionSchemaUpdateInput,
      SubmissionSchemaUncheckedUpdateInput
    >;
    /**
     * Choose, which SubmissionSchema to update.
     */
    where: SubmissionSchemaWhereUniqueInput;
  };

  /**
   * SubmissionSchema updateMany
   */
  export type SubmissionSchemaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SubmissionSchemas.
     */
    data: XOR<
      SubmissionSchemaUpdateManyMutationInput,
      SubmissionSchemaUncheckedUpdateManyInput
    >;
    /**
     * Filter which SubmissionSchemas to update
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * Limit how many SubmissionSchemas to update.
     */
    limit?: number;
  };

  /**
   * SubmissionSchema upsert
   */
  export type SubmissionSchemaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * The filter to search for the SubmissionSchema to update in case it exists.
     */
    where: SubmissionSchemaWhereUniqueInput;
    /**
     * In case the SubmissionSchema found by the `where` argument doesn't exist, create a new SubmissionSchema with this data.
     */
    create: XOR<
      SubmissionSchemaCreateInput,
      SubmissionSchemaUncheckedCreateInput
    >;
    /**
     * In case the SubmissionSchema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      SubmissionSchemaUpdateInput,
      SubmissionSchemaUncheckedUpdateInput
    >;
  };

  /**
   * SubmissionSchema delete
   */
  export type SubmissionSchemaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
    /**
     * Filter which SubmissionSchema to delete.
     */
    where: SubmissionSchemaWhereUniqueInput;
  };

  /**
   * SubmissionSchema deleteMany
   */
  export type SubmissionSchemaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SubmissionSchemas to delete
     */
    where?: SubmissionSchemaWhereInput;
    /**
     * Limit how many SubmissionSchemas to delete.
     */
    limit?: number;
  };

  /**
   * SubmissionSchema without action
   */
  export type SubmissionSchemaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionSchema
     */
    select?: SubmissionSchemaSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubmissionSchema
     */
    omit?: SubmissionSchemaOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionSchemaInclude<ExtArgs> | null;
  };

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  export type TeamMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    name: string | null;
    blurb: string | null;
    track: string | null;
    lookingForMembers: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    name: string | null;
    blurb: string | null;
    track: string | null;
    lookingForMembers: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamCountAggregateOutputType = {
    id: number;
    eventId: number;
    name: number;
    blurb: number;
    track: number;
    lookingForMembers: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TeamMinAggregateInputType = {
    id?: true;
    eventId?: true;
    name?: true;
    blurb?: true;
    track?: true;
    lookingForMembers?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    name?: true;
    blurb?: true;
    track?: true;
    lookingForMembers?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamCountAggregateInputType = {
    id?: true;
    eventId?: true;
    name?: true;
    blurb?: true;
    track?: true;
    lookingForMembers?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TeamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Teams
     **/
    _count?: true | TeamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMaxAggregateInputType;
  };

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
    [P in keyof T & keyof AggregateTeam]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>;
  };

  export type TeamGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
    orderBy?:
      | TeamOrderByWithAggregationInput
      | TeamOrderByWithAggregationInput[];
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum;
    having?: TeamScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamCountAggregateInputType | true;
    _min?: TeamMinAggregateInputType;
    _max?: TeamMaxAggregateInputType;
  };

  export type TeamGroupByOutputType = {
    id: string;
    eventId: string;
    name: string;
    blurb: string | null;
    track: string | null;
    lookingForMembers: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TeamGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
          : GetScalarType<T[P], TeamGroupByOutputType[P]>;
      }
    >
  >;

  export type TeamSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      name?: boolean;
      blurb?: boolean;
      track?: boolean;
      lookingForMembers?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      auditLogs?: boolean | Team$auditLogsArgs<ExtArgs>;
      members?: boolean | Team$membersArgs<ExtArgs>;
      invites?: boolean | Team$invitesArgs<ExtArgs>;
      joinRequests?: boolean | Team$joinRequestsArgs<ExtArgs>;
      submissions?: boolean | Team$submissionsArgs<ExtArgs>;
      _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["team"]
  >;

  export type TeamSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    name?: boolean;
    blurb?: boolean;
    track?: boolean;
    lookingForMembers?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TeamOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "name"
    | "blurb"
    | "track"
    | "lookingForMembers"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["team"]
  >;
  export type TeamInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    auditLogs?: boolean | Team$auditLogsArgs<ExtArgs>;
    members?: boolean | Team$membersArgs<ExtArgs>;
    invites?: boolean | Team$invitesArgs<ExtArgs>;
    joinRequests?: boolean | Team$joinRequestsArgs<ExtArgs>;
    submissions?: boolean | Team$submissionsArgs<ExtArgs>;
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $TeamPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Team";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      auditLogs: Prisma.$TeamAuditLogPayload<ExtArgs>[];
      members: Prisma.$TeamMemberPayload<ExtArgs>[];
      invites: Prisma.$TeamInvitePayload<ExtArgs>[];
      joinRequests: Prisma.$TeamJoinRequestPayload<ExtArgs>[];
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        name: string;
        blurb: string | null;
        track: string | null;
        lookingForMembers: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["team"]
    >;
    composites: {};
  };

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> =
    $Result.GetResult<Prisma.$TeamPayload, S>;

  type TeamCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<TeamFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: TeamCountAggregateInputType | true;
  };

  export interface TeamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Team"];
      meta: { name: "Team" };
    };
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(
      args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(
      args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     *
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     *
     */
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamCreateManyArgs>(
      args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     *
     */
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
     **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamAggregateArgs>(
      args: Subset<T, TeamAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamAggregateType<T>>;

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs["orderBy"] }
        : { orderBy?: TeamGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetTeamGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Team model
     */
    readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    auditLogs<T extends Team$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$auditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamAuditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    members<T extends Team$membersArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$membersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamMemberPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    invites<T extends Team$invitesArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$invitesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamInvitePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    joinRequests<T extends Team$joinRequestsArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$joinRequestsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$TeamJoinRequestPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    submissions<T extends Team$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$submissionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$SubmissionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", "String">;
    readonly eventId: FieldRef<"Team", "String">;
    readonly name: FieldRef<"Team", "String">;
    readonly blurb: FieldRef<"Team", "String">;
    readonly track: FieldRef<"Team", "String">;
    readonly lookingForMembers: FieldRef<"Team", "Boolean">;
    readonly createdAt: FieldRef<"Team", "DateTime">;
    readonly updatedAt: FieldRef<"Team", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team create
   */
  export type TeamCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
  };

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Team update
   */
  export type TeamUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput;
    /**
     * Limit how many Teams to update.
     */
    limit?: number;
  };

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput;
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
  };

  /**
   * Team delete
   */
  export type TeamDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput;
    /**
     * Limit how many Teams to delete.
     */
    limit?: number;
  };

  /**
   * Team.auditLogs
   */
  export type Team$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    where?: TeamAuditLogWhereInput;
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    cursor?: TeamAuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * Team.members
   */
  export type Team$membersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    where?: TeamMemberWhereInput;
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    cursor?: TeamMemberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * Team.invites
   */
  export type Team$invitesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    where?: TeamInviteWhereInput;
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    cursor?: TeamInviteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * Team.joinRequests
   */
  export type Team$joinRequestsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    where?: TeamJoinRequestWhereInput;
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    cursor?: TeamJoinRequestWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * Team.submissions
   */
  export type Team$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Team without action
   */
  export type TeamDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
  };

  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  export type TeamMemberMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    userId: string | null;
    role: $Enums.TeamRole | null;
  };

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    userId: string | null;
    role: $Enums.TeamRole | null;
  };

  export type TeamMemberCountAggregateOutputType = {
    id: number;
    eventId: number;
    teamId: number;
    userId: number;
    role: number;
    _all: number;
  };

  export type TeamMemberMinAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    role?: true;
  };

  export type TeamMemberMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    role?: true;
  };

  export type TeamMemberCountAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    role?: true;
    _all?: true;
  };

  export type TeamMemberAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamMembers
     **/
    _count?: true | TeamMemberCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMemberMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamMember]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>;
  };

  export type TeamMemberGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
    orderBy?:
      | TeamMemberOrderByWithAggregationInput
      | TeamMemberOrderByWithAggregationInput[];
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum;
    having?: TeamMemberScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamMemberCountAggregateInputType | true;
    _min?: TeamMemberMinAggregateInputType;
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type TeamMemberGroupByOutputType = {
    id: string;
    eventId: string;
    teamId: string;
    userId: string;
    role: $Enums.TeamRole;
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TeamMemberGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof TeamMemberGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>;
        }
      >
    >;

  export type TeamMemberSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      teamId?: boolean;
      userId?: boolean;
      role?: boolean;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["teamMember"]
  >;

  export type TeamMemberSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    teamId?: boolean;
    userId?: boolean;
    role?: boolean;
  };

  export type TeamMemberOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "eventId" | "teamId" | "userId" | "role",
    ExtArgs["result"]["teamMember"]
  >;
  export type TeamMemberInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TeamMemberPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TeamMember";
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        teamId: string;
        userId: string;
        role: $Enums.TeamRole;
      },
      ExtArgs["result"]["teamMember"]
    >;
    composites: {};
  };

  type TeamMemberGetPayload<
    S extends boolean | null | undefined | TeamMemberDefaultArgs,
  > = $Result.GetResult<Prisma.$TeamMemberPayload, S>;

  type TeamMemberCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TeamMemberFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TeamMemberCountAggregateInputType | true;
  };

  export interface TeamMemberDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TeamMember"];
      meta: { name: "TeamMember" };
    };
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     *
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamMemberFindManyArgs>(
      args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     *
     */
    create<T extends TeamMemberCreateArgs>(
      args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamMemberCreateManyArgs>(
      args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     *
     */
    delete<T extends TeamMemberDeleteArgs>(
      args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamMemberUpdateArgs>(
      args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(
      args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(
      args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(
      args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>,
    ): Prisma__TeamMemberClient<
      $Result.GetResult<
        Prisma.$TeamMemberPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
     **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamMemberCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamMemberAggregateArgs>(
      args: Subset<T, TeamMemberAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>;

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs["orderBy"] }
        : { orderBy?: TeamMemberGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTeamMemberGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamMember model
     */
    readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", "String">;
    readonly eventId: FieldRef<"TeamMember", "String">;
    readonly teamId: FieldRef<"TeamMember", "String">;
    readonly userId: FieldRef<"TeamMember", "String">;
    readonly role: FieldRef<"TeamMember", "TeamRole">;
  }

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?:
      | TeamMemberOrderByWithRelationInput
      | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
  };

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<
      TeamMemberUpdateManyMutationInput,
      TeamMemberUncheckedUpdateManyInput
    >;
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput;
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number;
  };

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput;
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
  };

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput;
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number;
  };

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
  };

  /**
   * Model TeamInvite
   */

  export type AggregateTeamInvite = {
    _count: TeamInviteCountAggregateOutputType | null;
    _min: TeamInviteMinAggregateOutputType | null;
    _max: TeamInviteMaxAggregateOutputType | null;
  };

  export type TeamInviteMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    email: string | null;
    token: string | null;
    status: $Enums.InviteStatus | null;
    message: string | null;
    createdByUserId: string | null;
    createdAt: Date | null;
    expiresAt: Date | null;
  };

  export type TeamInviteMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    email: string | null;
    token: string | null;
    status: $Enums.InviteStatus | null;
    message: string | null;
    createdByUserId: string | null;
    createdAt: Date | null;
    expiresAt: Date | null;
  };

  export type TeamInviteCountAggregateOutputType = {
    id: number;
    eventId: number;
    teamId: number;
    email: number;
    token: number;
    status: number;
    message: number;
    createdByUserId: number;
    createdAt: number;
    expiresAt: number;
    _all: number;
  };

  export type TeamInviteMinAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    email?: true;
    token?: true;
    status?: true;
    message?: true;
    createdByUserId?: true;
    createdAt?: true;
    expiresAt?: true;
  };

  export type TeamInviteMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    email?: true;
    token?: true;
    status?: true;
    message?: true;
    createdByUserId?: true;
    createdAt?: true;
    expiresAt?: true;
  };

  export type TeamInviteCountAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    email?: true;
    token?: true;
    status?: true;
    message?: true;
    createdByUserId?: true;
    createdAt?: true;
    expiresAt?: true;
    _all?: true;
  };

  export type TeamInviteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamInvite to aggregate.
     */
    where?: TeamInviteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamInviteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamInvites.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamInvites
     **/
    _count?: true | TeamInviteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamInviteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamInviteMaxAggregateInputType;
  };

  export type GetTeamInviteAggregateType<T extends TeamInviteAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamInvite]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamInvite[P]>
      : GetScalarType<T[P], AggregateTeamInvite[P]>;
  };

  export type TeamInviteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamInviteWhereInput;
    orderBy?:
      | TeamInviteOrderByWithAggregationInput
      | TeamInviteOrderByWithAggregationInput[];
    by: TeamInviteScalarFieldEnum[] | TeamInviteScalarFieldEnum;
    having?: TeamInviteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamInviteCountAggregateInputType | true;
    _min?: TeamInviteMinAggregateInputType;
    _max?: TeamInviteMaxAggregateInputType;
  };

  export type TeamInviteGroupByOutputType = {
    id: string;
    eventId: string;
    teamId: string;
    email: string;
    token: string;
    status: $Enums.InviteStatus;
    message: string | null;
    createdByUserId: string;
    createdAt: Date;
    expiresAt: Date | null;
    _count: TeamInviteCountAggregateOutputType | null;
    _min: TeamInviteMinAggregateOutputType | null;
    _max: TeamInviteMaxAggregateOutputType | null;
  };

  type GetTeamInviteGroupByPayload<T extends TeamInviteGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TeamInviteGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof TeamInviteGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamInviteGroupByOutputType[P]>
            : GetScalarType<T[P], TeamInviteGroupByOutputType[P]>;
        }
      >
    >;

  export type TeamInviteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      teamId?: boolean;
      email?: boolean;
      token?: boolean;
      status?: boolean;
      message?: boolean;
      createdByUserId?: boolean;
      createdAt?: boolean;
      expiresAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      creator?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["teamInvite"]
  >;

  export type TeamInviteSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    teamId?: boolean;
    email?: boolean;
    token?: boolean;
    status?: boolean;
    message?: boolean;
    createdByUserId?: boolean;
    createdAt?: boolean;
    expiresAt?: boolean;
  };

  export type TeamInviteOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "teamId"
    | "email"
    | "token"
    | "status"
    | "message"
    | "createdByUserId"
    | "createdAt"
    | "expiresAt",
    ExtArgs["result"]["teamInvite"]
  >;
  export type TeamInviteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    creator?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TeamInvitePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TeamInvite";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs>;
      creator: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        teamId: string;
        email: string;
        token: string;
        status: $Enums.InviteStatus;
        message: string | null;
        createdByUserId: string;
        createdAt: Date;
        expiresAt: Date | null;
      },
      ExtArgs["result"]["teamInvite"]
    >;
    composites: {};
  };

  type TeamInviteGetPayload<
    S extends boolean | null | undefined | TeamInviteDefaultArgs,
  > = $Result.GetResult<Prisma.$TeamInvitePayload, S>;

  type TeamInviteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TeamInviteFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TeamInviteCountAggregateInputType | true;
  };

  export interface TeamInviteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TeamInvite"];
      meta: { name: "TeamInvite" };
    };
    /**
     * Find zero or one TeamInvite that matches the filter.
     * @param {TeamInviteFindUniqueArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamInviteFindUniqueArgs>(
      args: SelectSubset<T, TeamInviteFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TeamInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamInviteFindUniqueOrThrowArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamInviteFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamInviteFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindFirstArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamInviteFindFirstArgs>(
      args?: SelectSubset<T, TeamInviteFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindFirstOrThrowArgs} args - Arguments to find a TeamInvite
     * @example
     * // Get one TeamInvite
     * const teamInvite = await prisma.teamInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamInviteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamInviteFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TeamInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamInvites
     * const teamInvites = await prisma.teamInvite.findMany()
     *
     * // Get first 10 TeamInvites
     * const teamInvites = await prisma.teamInvite.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamInviteWithIdOnly = await prisma.teamInvite.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamInviteFindManyArgs>(
      args?: SelectSubset<T, TeamInviteFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TeamInvite.
     * @param {TeamInviteCreateArgs} args - Arguments to create a TeamInvite.
     * @example
     * // Create one TeamInvite
     * const TeamInvite = await prisma.teamInvite.create({
     *   data: {
     *     // ... data to create a TeamInvite
     *   }
     * })
     *
     */
    create<T extends TeamInviteCreateArgs>(
      args: SelectSubset<T, TeamInviteCreateArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TeamInvites.
     * @param {TeamInviteCreateManyArgs} args - Arguments to create many TeamInvites.
     * @example
     * // Create many TeamInvites
     * const teamInvite = await prisma.teamInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamInviteCreateManyArgs>(
      args?: SelectSubset<T, TeamInviteCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TeamInvite.
     * @param {TeamInviteDeleteArgs} args - Arguments to delete one TeamInvite.
     * @example
     * // Delete one TeamInvite
     * const TeamInvite = await prisma.teamInvite.delete({
     *   where: {
     *     // ... filter to delete one TeamInvite
     *   }
     * })
     *
     */
    delete<T extends TeamInviteDeleteArgs>(
      args: SelectSubset<T, TeamInviteDeleteArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TeamInvite.
     * @param {TeamInviteUpdateArgs} args - Arguments to update one TeamInvite.
     * @example
     * // Update one TeamInvite
     * const teamInvite = await prisma.teamInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamInviteUpdateArgs>(
      args: SelectSubset<T, TeamInviteUpdateArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TeamInvites.
     * @param {TeamInviteDeleteManyArgs} args - Arguments to filter TeamInvites to delete.
     * @example
     * // Delete a few TeamInvites
     * const { count } = await prisma.teamInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamInviteDeleteManyArgs>(
      args?: SelectSubset<T, TeamInviteDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamInvites
     * const teamInvite = await prisma.teamInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamInviteUpdateManyArgs>(
      args: SelectSubset<T, TeamInviteUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamInvite.
     * @param {TeamInviteUpsertArgs} args - Arguments to update or create a TeamInvite.
     * @example
     * // Update or create a TeamInvite
     * const teamInvite = await prisma.teamInvite.upsert({
     *   create: {
     *     // ... data to create a TeamInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamInvite we want to update
     *   }
     * })
     */
    upsert<T extends TeamInviteUpsertArgs>(
      args: SelectSubset<T, TeamInviteUpsertArgs<ExtArgs>>,
    ): Prisma__TeamInviteClient<
      $Result.GetResult<
        Prisma.$TeamInvitePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TeamInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteCountArgs} args - Arguments to filter TeamInvites to count.
     * @example
     * // Count the number of TeamInvites
     * const count = await prisma.teamInvite.count({
     *   where: {
     *     // ... the filter for the TeamInvites we want to count
     *   }
     * })
     **/
    count<T extends TeamInviteCountArgs>(
      args?: Subset<T, TeamInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamInviteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamInviteAggregateArgs>(
      args: Subset<T, TeamInviteAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamInviteAggregateType<T>>;

    /**
     * Group by TeamInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamInviteGroupByArgs["orderBy"] }
        : { orderBy?: TeamInviteGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamInviteGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTeamInviteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamInvite model
     */
    readonly fields: TeamInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamInviteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamInvite model
   */
  interface TeamInviteFieldRefs {
    readonly id: FieldRef<"TeamInvite", "String">;
    readonly eventId: FieldRef<"TeamInvite", "String">;
    readonly teamId: FieldRef<"TeamInvite", "String">;
    readonly email: FieldRef<"TeamInvite", "String">;
    readonly token: FieldRef<"TeamInvite", "String">;
    readonly status: FieldRef<"TeamInvite", "InviteStatus">;
    readonly message: FieldRef<"TeamInvite", "String">;
    readonly createdByUserId: FieldRef<"TeamInvite", "String">;
    readonly createdAt: FieldRef<"TeamInvite", "DateTime">;
    readonly expiresAt: FieldRef<"TeamInvite", "DateTime">;
  }

  // Custom InputTypes
  /**
   * TeamInvite findUnique
   */
  export type TeamInviteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter, which TeamInvite to fetch.
     */
    where: TeamInviteWhereUniqueInput;
  };

  /**
   * TeamInvite findUniqueOrThrow
   */
  export type TeamInviteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter, which TeamInvite to fetch.
     */
    where: TeamInviteWhereUniqueInput;
  };

  /**
   * TeamInvite findFirst
   */
  export type TeamInviteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter, which TeamInvite to fetch.
     */
    where?: TeamInviteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamInvites.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamInvites.
     */
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * TeamInvite findFirstOrThrow
   */
  export type TeamInviteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter, which TeamInvite to fetch.
     */
    where?: TeamInviteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamInvites.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamInvites.
     */
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * TeamInvite findMany
   */
  export type TeamInviteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter, which TeamInvites to fetch.
     */
    where?: TeamInviteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamInvites to fetch.
     */
    orderBy?:
      | TeamInviteOrderByWithRelationInput
      | TeamInviteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamInvites.
     */
    cursor?: TeamInviteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamInvites from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamInvites.
     */
    skip?: number;
    distinct?: TeamInviteScalarFieldEnum | TeamInviteScalarFieldEnum[];
  };

  /**
   * TeamInvite create
   */
  export type TeamInviteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamInvite.
     */
    data: XOR<TeamInviteCreateInput, TeamInviteUncheckedCreateInput>;
  };

  /**
   * TeamInvite createMany
   */
  export type TeamInviteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamInvites.
     */
    data: TeamInviteCreateManyInput | TeamInviteCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamInvite update
   */
  export type TeamInviteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamInvite.
     */
    data: XOR<TeamInviteUpdateInput, TeamInviteUncheckedUpdateInput>;
    /**
     * Choose, which TeamInvite to update.
     */
    where: TeamInviteWhereUniqueInput;
  };

  /**
   * TeamInvite updateMany
   */
  export type TeamInviteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamInvites.
     */
    data: XOR<
      TeamInviteUpdateManyMutationInput,
      TeamInviteUncheckedUpdateManyInput
    >;
    /**
     * Filter which TeamInvites to update
     */
    where?: TeamInviteWhereInput;
    /**
     * Limit how many TeamInvites to update.
     */
    limit?: number;
  };

  /**
   * TeamInvite upsert
   */
  export type TeamInviteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamInvite to update in case it exists.
     */
    where: TeamInviteWhereUniqueInput;
    /**
     * In case the TeamInvite found by the `where` argument doesn't exist, create a new TeamInvite with this data.
     */
    create: XOR<TeamInviteCreateInput, TeamInviteUncheckedCreateInput>;
    /**
     * In case the TeamInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamInviteUpdateInput, TeamInviteUncheckedUpdateInput>;
  };

  /**
   * TeamInvite delete
   */
  export type TeamInviteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
    /**
     * Filter which TeamInvite to delete.
     */
    where: TeamInviteWhereUniqueInput;
  };

  /**
   * TeamInvite deleteMany
   */
  export type TeamInviteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamInvites to delete
     */
    where?: TeamInviteWhereInput;
    /**
     * Limit how many TeamInvites to delete.
     */
    limit?: number;
  };

  /**
   * TeamInvite without action
   */
  export type TeamInviteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamInvite
     */
    select?: TeamInviteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamInvite
     */
    omit?: TeamInviteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInviteInclude<ExtArgs> | null;
  };

  /**
   * Model TeamJoinRequest
   */

  export type AggregateTeamJoinRequest = {
    _count: TeamJoinRequestCountAggregateOutputType | null;
    _min: TeamJoinRequestMinAggregateOutputType | null;
    _max: TeamJoinRequestMaxAggregateOutputType | null;
  };

  export type TeamJoinRequestMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    userId: string | null;
    message: string | null;
    status: $Enums.JoinRequestStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamJoinRequestMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    userId: string | null;
    message: string | null;
    status: $Enums.JoinRequestStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamJoinRequestCountAggregateOutputType = {
    id: number;
    eventId: number;
    teamId: number;
    userId: number;
    message: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TeamJoinRequestMinAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamJoinRequestMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamJoinRequestCountAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    userId?: true;
    message?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TeamJoinRequestAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamJoinRequest to aggregate.
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamJoinRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamJoinRequests
     **/
    _count?: true | TeamJoinRequestCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamJoinRequestMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamJoinRequestMaxAggregateInputType;
  };

  export type GetTeamJoinRequestAggregateType<
    T extends TeamJoinRequestAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTeamJoinRequest]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamJoinRequest[P]>
      : GetScalarType<T[P], AggregateTeamJoinRequest[P]>;
  };

  export type TeamJoinRequestGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamJoinRequestWhereInput;
    orderBy?:
      | TeamJoinRequestOrderByWithAggregationInput
      | TeamJoinRequestOrderByWithAggregationInput[];
    by: TeamJoinRequestScalarFieldEnum[] | TeamJoinRequestScalarFieldEnum;
    having?: TeamJoinRequestScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamJoinRequestCountAggregateInputType | true;
    _min?: TeamJoinRequestMinAggregateInputType;
    _max?: TeamJoinRequestMaxAggregateInputType;
  };

  export type TeamJoinRequestGroupByOutputType = {
    id: string;
    eventId: string;
    teamId: string;
    userId: string;
    message: string | null;
    status: $Enums.JoinRequestStatus;
    createdAt: Date;
    updatedAt: Date;
    _count: TeamJoinRequestCountAggregateOutputType | null;
    _min: TeamJoinRequestMinAggregateOutputType | null;
    _max: TeamJoinRequestMaxAggregateOutputType | null;
  };

  type GetTeamJoinRequestGroupByPayload<T extends TeamJoinRequestGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TeamJoinRequestGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof TeamJoinRequestGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamJoinRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TeamJoinRequestGroupByOutputType[P]>;
        }
      >
    >;

  export type TeamJoinRequestSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      teamId?: boolean;
      userId?: boolean;
      message?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["teamJoinRequest"]
  >;

  export type TeamJoinRequestSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    teamId?: boolean;
    userId?: boolean;
    message?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TeamJoinRequestOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "teamId"
    | "userId"
    | "message"
    | "status"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["teamJoinRequest"]
  >;
  export type TeamJoinRequestInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TeamJoinRequestPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TeamJoinRequest";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        teamId: string;
        userId: string;
        message: string | null;
        status: $Enums.JoinRequestStatus;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["teamJoinRequest"]
    >;
    composites: {};
  };

  type TeamJoinRequestGetPayload<
    S extends boolean | null | undefined | TeamJoinRequestDefaultArgs,
  > = $Result.GetResult<Prisma.$TeamJoinRequestPayload, S>;

  type TeamJoinRequestCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TeamJoinRequestFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TeamJoinRequestCountAggregateInputType | true;
  };

  export interface TeamJoinRequestDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TeamJoinRequest"];
      meta: { name: "TeamJoinRequest" };
    };
    /**
     * Find zero or one TeamJoinRequest that matches the filter.
     * @param {TeamJoinRequestFindUniqueArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamJoinRequestFindUniqueArgs>(
      args: SelectSubset<T, TeamJoinRequestFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TeamJoinRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamJoinRequestFindUniqueOrThrowArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamJoinRequestFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamJoinRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindFirstArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamJoinRequestFindFirstArgs>(
      args?: SelectSubset<T, TeamJoinRequestFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamJoinRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindFirstOrThrowArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamJoinRequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamJoinRequestFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TeamJoinRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamJoinRequests
     * const teamJoinRequests = await prisma.teamJoinRequest.findMany()
     *
     * // Get first 10 TeamJoinRequests
     * const teamJoinRequests = await prisma.teamJoinRequest.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamJoinRequestWithIdOnly = await prisma.teamJoinRequest.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamJoinRequestFindManyArgs>(
      args?: SelectSubset<T, TeamJoinRequestFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TeamJoinRequest.
     * @param {TeamJoinRequestCreateArgs} args - Arguments to create a TeamJoinRequest.
     * @example
     * // Create one TeamJoinRequest
     * const TeamJoinRequest = await prisma.teamJoinRequest.create({
     *   data: {
     *     // ... data to create a TeamJoinRequest
     *   }
     * })
     *
     */
    create<T extends TeamJoinRequestCreateArgs>(
      args: SelectSubset<T, TeamJoinRequestCreateArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TeamJoinRequests.
     * @param {TeamJoinRequestCreateManyArgs} args - Arguments to create many TeamJoinRequests.
     * @example
     * // Create many TeamJoinRequests
     * const teamJoinRequest = await prisma.teamJoinRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamJoinRequestCreateManyArgs>(
      args?: SelectSubset<T, TeamJoinRequestCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TeamJoinRequest.
     * @param {TeamJoinRequestDeleteArgs} args - Arguments to delete one TeamJoinRequest.
     * @example
     * // Delete one TeamJoinRequest
     * const TeamJoinRequest = await prisma.teamJoinRequest.delete({
     *   where: {
     *     // ... filter to delete one TeamJoinRequest
     *   }
     * })
     *
     */
    delete<T extends TeamJoinRequestDeleteArgs>(
      args: SelectSubset<T, TeamJoinRequestDeleteArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TeamJoinRequest.
     * @param {TeamJoinRequestUpdateArgs} args - Arguments to update one TeamJoinRequest.
     * @example
     * // Update one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamJoinRequestUpdateArgs>(
      args: SelectSubset<T, TeamJoinRequestUpdateArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TeamJoinRequests.
     * @param {TeamJoinRequestDeleteManyArgs} args - Arguments to filter TeamJoinRequests to delete.
     * @example
     * // Delete a few TeamJoinRequests
     * const { count } = await prisma.teamJoinRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamJoinRequestDeleteManyArgs>(
      args?: SelectSubset<T, TeamJoinRequestDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamJoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamJoinRequests
     * const teamJoinRequest = await prisma.teamJoinRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamJoinRequestUpdateManyArgs>(
      args: SelectSubset<T, TeamJoinRequestUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamJoinRequest.
     * @param {TeamJoinRequestUpsertArgs} args - Arguments to update or create a TeamJoinRequest.
     * @example
     * // Update or create a TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.upsert({
     *   create: {
     *     // ... data to create a TeamJoinRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamJoinRequest we want to update
     *   }
     * })
     */
    upsert<T extends TeamJoinRequestUpsertArgs>(
      args: SelectSubset<T, TeamJoinRequestUpsertArgs<ExtArgs>>,
    ): Prisma__TeamJoinRequestClient<
      $Result.GetResult<
        Prisma.$TeamJoinRequestPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TeamJoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestCountArgs} args - Arguments to filter TeamJoinRequests to count.
     * @example
     * // Count the number of TeamJoinRequests
     * const count = await prisma.teamJoinRequest.count({
     *   where: {
     *     // ... the filter for the TeamJoinRequests we want to count
     *   }
     * })
     **/
    count<T extends TeamJoinRequestCountArgs>(
      args?: Subset<T, TeamJoinRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamJoinRequestCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamJoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamJoinRequestAggregateArgs>(
      args: Subset<T, TeamJoinRequestAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamJoinRequestAggregateType<T>>;

    /**
     * Group by TeamJoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamJoinRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamJoinRequestGroupByArgs["orderBy"] }
        : { orderBy?: TeamJoinRequestGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamJoinRequestGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTeamJoinRequestGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamJoinRequest model
     */
    readonly fields: TeamJoinRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamJoinRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamJoinRequestClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamJoinRequest model
   */
  interface TeamJoinRequestFieldRefs {
    readonly id: FieldRef<"TeamJoinRequest", "String">;
    readonly eventId: FieldRef<"TeamJoinRequest", "String">;
    readonly teamId: FieldRef<"TeamJoinRequest", "String">;
    readonly userId: FieldRef<"TeamJoinRequest", "String">;
    readonly message: FieldRef<"TeamJoinRequest", "String">;
    readonly status: FieldRef<"TeamJoinRequest", "JoinRequestStatus">;
    readonly createdAt: FieldRef<"TeamJoinRequest", "DateTime">;
    readonly updatedAt: FieldRef<"TeamJoinRequest", "DateTime">;
  }

  // Custom InputTypes
  /**
   * TeamJoinRequest findUnique
   */
  export type TeamJoinRequestFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where: TeamJoinRequestWhereUniqueInput;
  };

  /**
   * TeamJoinRequest findUniqueOrThrow
   */
  export type TeamJoinRequestFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where: TeamJoinRequestWhereUniqueInput;
  };

  /**
   * TeamJoinRequest findFirst
   */
  export type TeamJoinRequestFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamJoinRequests.
     */
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * TeamJoinRequest findFirstOrThrow
   */
  export type TeamJoinRequestFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamJoinRequests.
     */
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * TeamJoinRequest findMany
   */
  export type TeamJoinRequestFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter, which TeamJoinRequests to fetch.
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?:
      | TeamJoinRequestOrderByWithRelationInput
      | TeamJoinRequestOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number;
    distinct?:
      | TeamJoinRequestScalarFieldEnum
      | TeamJoinRequestScalarFieldEnum[];
  };

  /**
   * TeamJoinRequest create
   */
  export type TeamJoinRequestCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamJoinRequest.
     */
    data: XOR<TeamJoinRequestCreateInput, TeamJoinRequestUncheckedCreateInput>;
  };

  /**
   * TeamJoinRequest createMany
   */
  export type TeamJoinRequestCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamJoinRequests.
     */
    data: TeamJoinRequestCreateManyInput | TeamJoinRequestCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamJoinRequest update
   */
  export type TeamJoinRequestUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamJoinRequest.
     */
    data: XOR<TeamJoinRequestUpdateInput, TeamJoinRequestUncheckedUpdateInput>;
    /**
     * Choose, which TeamJoinRequest to update.
     */
    where: TeamJoinRequestWhereUniqueInput;
  };

  /**
   * TeamJoinRequest updateMany
   */
  export type TeamJoinRequestUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamJoinRequests.
     */
    data: XOR<
      TeamJoinRequestUpdateManyMutationInput,
      TeamJoinRequestUncheckedUpdateManyInput
    >;
    /**
     * Filter which TeamJoinRequests to update
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * Limit how many TeamJoinRequests to update.
     */
    limit?: number;
  };

  /**
   * TeamJoinRequest upsert
   */
  export type TeamJoinRequestUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamJoinRequest to update in case it exists.
     */
    where: TeamJoinRequestWhereUniqueInput;
    /**
     * In case the TeamJoinRequest found by the `where` argument doesn't exist, create a new TeamJoinRequest with this data.
     */
    create: XOR<
      TeamJoinRequestCreateInput,
      TeamJoinRequestUncheckedCreateInput
    >;
    /**
     * In case the TeamJoinRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      TeamJoinRequestUpdateInput,
      TeamJoinRequestUncheckedUpdateInput
    >;
  };

  /**
   * TeamJoinRequest delete
   */
  export type TeamJoinRequestDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
    /**
     * Filter which TeamJoinRequest to delete.
     */
    where: TeamJoinRequestWhereUniqueInput;
  };

  /**
   * TeamJoinRequest deleteMany
   */
  export type TeamJoinRequestDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamJoinRequests to delete
     */
    where?: TeamJoinRequestWhereInput;
    /**
     * Limit how many TeamJoinRequests to delete.
     */
    limit?: number;
  };

  /**
   * TeamJoinRequest without action
   */
  export type TeamJoinRequestDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamJoinRequest
     */
    omit?: TeamJoinRequestOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null;
  };

  /**
   * Model TeamAuditLog
   */

  export type AggregateTeamAuditLog = {
    _count: TeamAuditLogCountAggregateOutputType | null;
    _min: TeamAuditLogMinAggregateOutputType | null;
    _max: TeamAuditLogMaxAggregateOutputType | null;
  };

  export type TeamAuditLogMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    actorId: string | null;
    targetUserId: string | null;
    action: $Enums.TeamAuditAction | null;
    createdAt: Date | null;
  };

  export type TeamAuditLogMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    actorId: string | null;
    targetUserId: string | null;
    action: $Enums.TeamAuditAction | null;
    createdAt: Date | null;
  };

  export type TeamAuditLogCountAggregateOutputType = {
    id: number;
    eventId: number;
    teamId: number;
    actorId: number;
    targetUserId: number;
    action: number;
    meta: number;
    createdAt: number;
    _all: number;
  };

  export type TeamAuditLogMinAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    actorId?: true;
    targetUserId?: true;
    action?: true;
    createdAt?: true;
  };

  export type TeamAuditLogMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    actorId?: true;
    targetUserId?: true;
    action?: true;
    createdAt?: true;
  };

  export type TeamAuditLogCountAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    actorId?: true;
    targetUserId?: true;
    action?: true;
    meta?: true;
    createdAt?: true;
    _all?: true;
  };

  export type TeamAuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamAuditLog to aggregate.
     */
    where?: TeamAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamAuditLogs to fetch.
     */
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamAuditLogs
     **/
    _count?: true | TeamAuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamAuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamAuditLogMaxAggregateInputType;
  };

  export type GetTeamAuditLogAggregateType<
    T extends TeamAuditLogAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateTeamAuditLog]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamAuditLog[P]>
      : GetScalarType<T[P], AggregateTeamAuditLog[P]>;
  };

  export type TeamAuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamAuditLogWhereInput;
    orderBy?:
      | TeamAuditLogOrderByWithAggregationInput
      | TeamAuditLogOrderByWithAggregationInput[];
    by: TeamAuditLogScalarFieldEnum[] | TeamAuditLogScalarFieldEnum;
    having?: TeamAuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamAuditLogCountAggregateInputType | true;
    _min?: TeamAuditLogMinAggregateInputType;
    _max?: TeamAuditLogMaxAggregateInputType;
  };

  export type TeamAuditLogGroupByOutputType = {
    id: string;
    eventId: string;
    teamId: string;
    actorId: string | null;
    targetUserId: string | null;
    action: $Enums.TeamAuditAction;
    meta: JsonValue | null;
    createdAt: Date;
    _count: TeamAuditLogCountAggregateOutputType | null;
    _min: TeamAuditLogMinAggregateOutputType | null;
    _max: TeamAuditLogMaxAggregateOutputType | null;
  };

  type GetTeamAuditLogGroupByPayload<T extends TeamAuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<TeamAuditLogGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof TeamAuditLogGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], TeamAuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type TeamAuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      teamId?: boolean;
      actorId?: boolean;
      targetUserId?: boolean;
      action?: boolean;
      meta?: boolean;
      createdAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      actor?: boolean | TeamAuditLog$actorArgs<ExtArgs>;
      targetUser?: boolean | TeamAuditLog$targetUserArgs<ExtArgs>;
    },
    ExtArgs["result"]["teamAuditLog"]
  >;

  export type TeamAuditLogSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    teamId?: boolean;
    actorId?: boolean;
    targetUserId?: boolean;
    action?: boolean;
    meta?: boolean;
    createdAt?: boolean;
  };

  export type TeamAuditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "teamId"
    | "actorId"
    | "targetUserId"
    | "action"
    | "meta"
    | "createdAt",
    ExtArgs["result"]["teamAuditLog"]
  >;
  export type TeamAuditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    actor?: boolean | TeamAuditLog$actorArgs<ExtArgs>;
    targetUser?: boolean | TeamAuditLog$targetUserArgs<ExtArgs>;
  };

  export type $TeamAuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "TeamAuditLog";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs>;
      actor: Prisma.$UserPayload<ExtArgs> | null;
      targetUser: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        teamId: string;
        actorId: string | null;
        targetUserId: string | null;
        action: $Enums.TeamAuditAction;
        meta: Prisma.JsonValue | null;
        createdAt: Date;
      },
      ExtArgs["result"]["teamAuditLog"]
    >;
    composites: {};
  };

  type TeamAuditLogGetPayload<
    S extends boolean | null | undefined | TeamAuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$TeamAuditLogPayload, S>;

  type TeamAuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    TeamAuditLogFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TeamAuditLogCountAggregateInputType | true;
  };

  export interface TeamAuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["TeamAuditLog"];
      meta: { name: "TeamAuditLog" };
    };
    /**
     * Find zero or one TeamAuditLog that matches the filter.
     * @param {TeamAuditLogFindUniqueArgs} args - Arguments to find a TeamAuditLog
     * @example
     * // Get one TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamAuditLogFindUniqueArgs>(
      args: SelectSubset<T, TeamAuditLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one TeamAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamAuditLogFindUniqueOrThrowArgs} args - Arguments to find a TeamAuditLog
     * @example
     * // Get one TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamAuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamAuditLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogFindFirstArgs} args - Arguments to find a TeamAuditLog
     * @example
     * // Get one TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamAuditLogFindFirstArgs>(
      args?: SelectSubset<T, TeamAuditLogFindFirstArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first TeamAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogFindFirstOrThrowArgs} args - Arguments to find a TeamAuditLog
     * @example
     * // Get one TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamAuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamAuditLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more TeamAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamAuditLogs
     * const teamAuditLogs = await prisma.teamAuditLog.findMany()
     *
     * // Get first 10 TeamAuditLogs
     * const teamAuditLogs = await prisma.teamAuditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamAuditLogWithIdOnly = await prisma.teamAuditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamAuditLogFindManyArgs>(
      args?: SelectSubset<T, TeamAuditLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a TeamAuditLog.
     * @param {TeamAuditLogCreateArgs} args - Arguments to create a TeamAuditLog.
     * @example
     * // Create one TeamAuditLog
     * const TeamAuditLog = await prisma.teamAuditLog.create({
     *   data: {
     *     // ... data to create a TeamAuditLog
     *   }
     * })
     *
     */
    create<T extends TeamAuditLogCreateArgs>(
      args: SelectSubset<T, TeamAuditLogCreateArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many TeamAuditLogs.
     * @param {TeamAuditLogCreateManyArgs} args - Arguments to create many TeamAuditLogs.
     * @example
     * // Create many TeamAuditLogs
     * const teamAuditLog = await prisma.teamAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamAuditLogCreateManyArgs>(
      args?: SelectSubset<T, TeamAuditLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a TeamAuditLog.
     * @param {TeamAuditLogDeleteArgs} args - Arguments to delete one TeamAuditLog.
     * @example
     * // Delete one TeamAuditLog
     * const TeamAuditLog = await prisma.teamAuditLog.delete({
     *   where: {
     *     // ... filter to delete one TeamAuditLog
     *   }
     * })
     *
     */
    delete<T extends TeamAuditLogDeleteArgs>(
      args: SelectSubset<T, TeamAuditLogDeleteArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one TeamAuditLog.
     * @param {TeamAuditLogUpdateArgs} args - Arguments to update one TeamAuditLog.
     * @example
     * // Update one TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamAuditLogUpdateArgs>(
      args: SelectSubset<T, TeamAuditLogUpdateArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more TeamAuditLogs.
     * @param {TeamAuditLogDeleteManyArgs} args - Arguments to filter TeamAuditLogs to delete.
     * @example
     * // Delete a few TeamAuditLogs
     * const { count } = await prisma.teamAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamAuditLogDeleteManyArgs>(
      args?: SelectSubset<T, TeamAuditLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamAuditLogs
     * const teamAuditLog = await prisma.teamAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamAuditLogUpdateManyArgs>(
      args: SelectSubset<T, TeamAuditLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamAuditLog.
     * @param {TeamAuditLogUpsertArgs} args - Arguments to update or create a TeamAuditLog.
     * @example
     * // Update or create a TeamAuditLog
     * const teamAuditLog = await prisma.teamAuditLog.upsert({
     *   create: {
     *     // ... data to create a TeamAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends TeamAuditLogUpsertArgs>(
      args: SelectSubset<T, TeamAuditLogUpsertArgs<ExtArgs>>,
    ): Prisma__TeamAuditLogClient<
      $Result.GetResult<
        Prisma.$TeamAuditLogPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of TeamAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogCountArgs} args - Arguments to filter TeamAuditLogs to count.
     * @example
     * // Count the number of TeamAuditLogs
     * const count = await prisma.teamAuditLog.count({
     *   where: {
     *     // ... the filter for the TeamAuditLogs we want to count
     *   }
     * })
     **/
    count<T extends TeamAuditLogCountArgs>(
      args?: Subset<T, TeamAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TeamAuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamAuditLogAggregateArgs>(
      args: Subset<T, TeamAuditLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetTeamAuditLogAggregateType<T>>;

    /**
     * Group by TeamAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamAuditLogGroupByArgs["orderBy"] }
        : { orderBy?: TeamAuditLogGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamAuditLogGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetTeamAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamAuditLog model
     */
    readonly fields: TeamAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamAuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      | $Result.GetResult<
          Prisma.$TeamPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    actor<T extends TeamAuditLog$actorArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamAuditLog$actorArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    targetUser<T extends TeamAuditLog$targetUserArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamAuditLog$targetUserArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamAuditLog model
   */
  interface TeamAuditLogFieldRefs {
    readonly id: FieldRef<"TeamAuditLog", "String">;
    readonly eventId: FieldRef<"TeamAuditLog", "String">;
    readonly teamId: FieldRef<"TeamAuditLog", "String">;
    readonly actorId: FieldRef<"TeamAuditLog", "String">;
    readonly targetUserId: FieldRef<"TeamAuditLog", "String">;
    readonly action: FieldRef<"TeamAuditLog", "TeamAuditAction">;
    readonly meta: FieldRef<"TeamAuditLog", "Json">;
    readonly createdAt: FieldRef<"TeamAuditLog", "DateTime">;
  }

  // Custom InputTypes
  /**
   * TeamAuditLog findUnique
   */
  export type TeamAuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which TeamAuditLog to fetch.
     */
    where: TeamAuditLogWhereUniqueInput;
  };

  /**
   * TeamAuditLog findUniqueOrThrow
   */
  export type TeamAuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which TeamAuditLog to fetch.
     */
    where: TeamAuditLogWhereUniqueInput;
  };

  /**
   * TeamAuditLog findFirst
   */
  export type TeamAuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which TeamAuditLog to fetch.
     */
    where?: TeamAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamAuditLogs to fetch.
     */
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamAuditLogs.
     */
    cursor?: TeamAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamAuditLogs.
     */
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * TeamAuditLog findFirstOrThrow
   */
  export type TeamAuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which TeamAuditLog to fetch.
     */
    where?: TeamAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamAuditLogs to fetch.
     */
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamAuditLogs.
     */
    cursor?: TeamAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamAuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamAuditLogs.
     */
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * TeamAuditLog findMany
   */
  export type TeamAuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which TeamAuditLogs to fetch.
     */
    where?: TeamAuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamAuditLogs to fetch.
     */
    orderBy?:
      | TeamAuditLogOrderByWithRelationInput
      | TeamAuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamAuditLogs.
     */
    cursor?: TeamAuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamAuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamAuditLogs.
     */
    skip?: number;
    distinct?: TeamAuditLogScalarFieldEnum | TeamAuditLogScalarFieldEnum[];
  };

  /**
   * TeamAuditLog create
   */
  export type TeamAuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamAuditLog.
     */
    data: XOR<TeamAuditLogCreateInput, TeamAuditLogUncheckedCreateInput>;
  };

  /**
   * TeamAuditLog createMany
   */
  export type TeamAuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamAuditLogs.
     */
    data: TeamAuditLogCreateManyInput | TeamAuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamAuditLog update
   */
  export type TeamAuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamAuditLog.
     */
    data: XOR<TeamAuditLogUpdateInput, TeamAuditLogUncheckedUpdateInput>;
    /**
     * Choose, which TeamAuditLog to update.
     */
    where: TeamAuditLogWhereUniqueInput;
  };

  /**
   * TeamAuditLog updateMany
   */
  export type TeamAuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamAuditLogs.
     */
    data: XOR<
      TeamAuditLogUpdateManyMutationInput,
      TeamAuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which TeamAuditLogs to update
     */
    where?: TeamAuditLogWhereInput;
    /**
     * Limit how many TeamAuditLogs to update.
     */
    limit?: number;
  };

  /**
   * TeamAuditLog upsert
   */
  export type TeamAuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamAuditLog to update in case it exists.
     */
    where: TeamAuditLogWhereUniqueInput;
    /**
     * In case the TeamAuditLog found by the `where` argument doesn't exist, create a new TeamAuditLog with this data.
     */
    create: XOR<TeamAuditLogCreateInput, TeamAuditLogUncheckedCreateInput>;
    /**
     * In case the TeamAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamAuditLogUpdateInput, TeamAuditLogUncheckedUpdateInput>;
  };

  /**
   * TeamAuditLog delete
   */
  export type TeamAuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
    /**
     * Filter which TeamAuditLog to delete.
     */
    where: TeamAuditLogWhereUniqueInput;
  };

  /**
   * TeamAuditLog deleteMany
   */
  export type TeamAuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamAuditLogs to delete
     */
    where?: TeamAuditLogWhereInput;
    /**
     * Limit how many TeamAuditLogs to delete.
     */
    limit?: number;
  };

  /**
   * TeamAuditLog.actor
   */
  export type TeamAuditLog$actorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * TeamAuditLog.targetUser
   */
  export type TeamAuditLog$targetUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * TeamAuditLog without action
   */
  export type TeamAuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamAuditLog
     */
    select?: TeamAuditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the TeamAuditLog
     */
    omit?: TeamAuditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null;
    _min: SubmissionMinAggregateOutputType | null;
    _max: SubmissionMaxAggregateOutputType | null;
  };

  export type SubmissionMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    authorId: string | null;
    status: $Enums.SubmissionStatus | null;
    title: string | null;
    description: string | null;
    videoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    submittedAt: Date | null;
  };

  export type SubmissionMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    teamId: string | null;
    authorId: string | null;
    status: $Enums.SubmissionStatus | null;
    title: string | null;
    description: string | null;
    videoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    submittedAt: Date | null;
  };

  export type SubmissionCountAggregateOutputType = {
    id: number;
    eventId: number;
    teamId: number;
    authorId: number;
    status: number;
    title: number;
    description: number;
    content: number;
    imageUrls: number;
    videoUrl: number;
    createdAt: number;
    updatedAt: number;
    submittedAt: number;
    _all: number;
  };

  export type SubmissionMinAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    authorId?: true;
    status?: true;
    title?: true;
    description?: true;
    videoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    submittedAt?: true;
  };

  export type SubmissionMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    authorId?: true;
    status?: true;
    title?: true;
    description?: true;
    videoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    submittedAt?: true;
  };

  export type SubmissionCountAggregateInputType = {
    id?: true;
    eventId?: true;
    teamId?: true;
    authorId?: true;
    status?: true;
    title?: true;
    description?: true;
    content?: true;
    imageUrls?: true;
    videoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    submittedAt?: true;
    _all?: true;
  };

  export type SubmissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Submissions
     **/
    _count?: true | SubmissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubmissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubmissionMaxAggregateInputType;
  };

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
    [P in keyof T & keyof AggregateSubmission]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>;
  };

  export type SubmissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
    orderBy?:
      | SubmissionOrderByWithAggregationInput
      | SubmissionOrderByWithAggregationInput[];
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum;
    having?: SubmissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubmissionCountAggregateInputType | true;
    _min?: SubmissionMinAggregateInputType;
    _max?: SubmissionMaxAggregateInputType;
  };

  export type SubmissionGroupByOutputType = {
    id: string;
    eventId: string;
    teamId: string | null;
    authorId: string | null;
    status: $Enums.SubmissionStatus;
    title: string;
    description: string | null;
    content: JsonValue | null;
    imageUrls: JsonValue | null;
    videoUrl: string | null;
    createdAt: Date;
    updatedAt: Date;
    submittedAt: Date | null;
    _count: SubmissionCountAggregateOutputType | null;
    _min: SubmissionMinAggregateOutputType | null;
    _max: SubmissionMaxAggregateOutputType | null;
  };

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubmissionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SubmissionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>;
        }
      >
    >;

  export type SubmissionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      teamId?: boolean;
      authorId?: boolean;
      status?: boolean;
      title?: boolean;
      description?: boolean;
      content?: boolean;
      imageUrls?: boolean;
      videoUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      submittedAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      team?: boolean | Submission$teamArgs<ExtArgs>;
      author?: boolean | Submission$authorArgs<ExtArgs>;
      scores?: boolean | Submission$scoresArgs<ExtArgs>;
      _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["submission"]
  >;

  export type SubmissionSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    teamId?: boolean;
    authorId?: boolean;
    status?: boolean;
    title?: boolean;
    description?: boolean;
    content?: boolean;
    imageUrls?: boolean;
    videoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    submittedAt?: boolean;
  };

  export type SubmissionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "eventId"
    | "teamId"
    | "authorId"
    | "status"
    | "title"
    | "description"
    | "content"
    | "imageUrls"
    | "videoUrl"
    | "createdAt"
    | "updatedAt"
    | "submittedAt",
    ExtArgs["result"]["submission"]
  >;
  export type SubmissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    team?: boolean | Submission$teamArgs<ExtArgs>;
    author?: boolean | Submission$authorArgs<ExtArgs>;
    scores?: boolean | Submission$scoresArgs<ExtArgs>;
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $SubmissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Submission";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs> | null;
      author: Prisma.$UserPayload<ExtArgs> | null;
      scores: Prisma.$ScorePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        teamId: string | null;
        authorId: string | null;
        status: $Enums.SubmissionStatus;
        title: string;
        description: string | null;
        content: Prisma.JsonValue | null;
        imageUrls: Prisma.JsonValue | null;
        videoUrl: string | null;
        createdAt: Date;
        updatedAt: Date;
        submittedAt: Date | null;
      },
      ExtArgs["result"]["submission"]
    >;
    composites: {};
  };

  type SubmissionGetPayload<
    S extends boolean | null | undefined | SubmissionDefaultArgs,
  > = $Result.GetResult<Prisma.$SubmissionPayload, S>;

  type SubmissionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SubmissionFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SubmissionCountAggregateInputType | true;
  };

  export interface SubmissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Submission"];
      meta: { name: "Submission" };
    };
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(
      args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(
      args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     *
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubmissionFindManyArgs>(
      args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     *
     */
    create<T extends SubmissionCreateArgs>(
      args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubmissionCreateManyArgs>(
      args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     *
     */
    delete<T extends SubmissionDeleteArgs>(
      args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubmissionUpdateArgs>(
      args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubmissionUpdateManyArgs>(
      args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(
      args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      $Result.GetResult<
        Prisma.$SubmissionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
     **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubmissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubmissionAggregateArgs>(
      args: Subset<T, SubmissionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>;

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs["orderBy"] }
        : { orderBy?: SubmissionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSubmissionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Submission model
     */
    readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    team<T extends Submission$teamArgs<ExtArgs> = {}>(
      args?: Subset<T, Submission$teamArgs<ExtArgs>>,
    ): Prisma__TeamClient<
      $Result.GetResult<
        Prisma.$TeamPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    author<T extends Submission$authorArgs<ExtArgs> = {}>(
      args?: Subset<T, Submission$authorArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    scores<T extends Submission$scoresArgs<ExtArgs> = {}>(
      args?: Subset<T, Submission$scoresArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ScorePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Submission model
   */
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", "String">;
    readonly eventId: FieldRef<"Submission", "String">;
    readonly teamId: FieldRef<"Submission", "String">;
    readonly authorId: FieldRef<"Submission", "String">;
    readonly status: FieldRef<"Submission", "SubmissionStatus">;
    readonly title: FieldRef<"Submission", "String">;
    readonly description: FieldRef<"Submission", "String">;
    readonly content: FieldRef<"Submission", "Json">;
    readonly imageUrls: FieldRef<"Submission", "Json">;
    readonly videoUrl: FieldRef<"Submission", "String">;
    readonly createdAt: FieldRef<"Submission", "DateTime">;
    readonly updatedAt: FieldRef<"Submission", "DateTime">;
    readonly submittedAt: FieldRef<"Submission", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?:
      | SubmissionOrderByWithRelationInput
      | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>;
  };

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>;
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<
      SubmissionUpdateManyMutationInput,
      SubmissionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput;
    /**
     * Limit how many Submissions to update.
     */
    limit?: number;
  };

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput;
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>;
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>;
  };

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput;
    /**
     * Limit how many Submissions to delete.
     */
    limit?: number;
  };

  /**
   * Submission.team
   */
  export type Submission$teamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
  };

  /**
   * Submission.author
   */
  export type Submission$authorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Submission.scores
   */
  export type Submission$scoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    cursor?: ScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Submission
     */
    omit?: SubmissionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
  };

  /**
   * Model JudgeAssignment
   */

  export type AggregateJudgeAssignment = {
    _count: JudgeAssignmentCountAggregateOutputType | null;
    _min: JudgeAssignmentMinAggregateOutputType | null;
    _max: JudgeAssignmentMaxAggregateOutputType | null;
  };

  export type JudgeAssignmentMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    role: $Enums.JudgeRole | null;
  };

  export type JudgeAssignmentMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    userId: string | null;
    role: $Enums.JudgeRole | null;
  };

  export type JudgeAssignmentCountAggregateOutputType = {
    id: number;
    eventId: number;
    userId: number;
    role: number;
    _all: number;
  };

  export type JudgeAssignmentMinAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    role?: true;
  };

  export type JudgeAssignmentMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    role?: true;
  };

  export type JudgeAssignmentCountAggregateInputType = {
    id?: true;
    eventId?: true;
    userId?: true;
    role?: true;
    _all?: true;
  };

  export type JudgeAssignmentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which JudgeAssignment to aggregate.
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JudgeAssignments to fetch.
     */
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: JudgeAssignmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JudgeAssignments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JudgeAssignments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned JudgeAssignments
     **/
    _count?: true | JudgeAssignmentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: JudgeAssignmentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: JudgeAssignmentMaxAggregateInputType;
  };

  export type GetJudgeAssignmentAggregateType<
    T extends JudgeAssignmentAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateJudgeAssignment]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudgeAssignment[P]>
      : GetScalarType<T[P], AggregateJudgeAssignment[P]>;
  };

  export type JudgeAssignmentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: JudgeAssignmentWhereInput;
    orderBy?:
      | JudgeAssignmentOrderByWithAggregationInput
      | JudgeAssignmentOrderByWithAggregationInput[];
    by: JudgeAssignmentScalarFieldEnum[] | JudgeAssignmentScalarFieldEnum;
    having?: JudgeAssignmentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: JudgeAssignmentCountAggregateInputType | true;
    _min?: JudgeAssignmentMinAggregateInputType;
    _max?: JudgeAssignmentMaxAggregateInputType;
  };

  export type JudgeAssignmentGroupByOutputType = {
    id: string;
    eventId: string;
    userId: string;
    role: $Enums.JudgeRole;
    _count: JudgeAssignmentCountAggregateOutputType | null;
    _min: JudgeAssignmentMinAggregateOutputType | null;
    _max: JudgeAssignmentMaxAggregateOutputType | null;
  };

  type GetJudgeAssignmentGroupByPayload<T extends JudgeAssignmentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<JudgeAssignmentGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof JudgeAssignmentGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JudgeAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], JudgeAssignmentGroupByOutputType[P]>;
        }
      >
    >;

  export type JudgeAssignmentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      userId?: boolean;
      role?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["judgeAssignment"]
  >;

  export type JudgeAssignmentSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    userId?: boolean;
    role?: boolean;
  };

  export type JudgeAssignmentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "eventId" | "userId" | "role",
    ExtArgs["result"]["judgeAssignment"]
  >;
  export type JudgeAssignmentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $JudgeAssignmentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "JudgeAssignment";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        userId: string;
        role: $Enums.JudgeRole;
      },
      ExtArgs["result"]["judgeAssignment"]
    >;
    composites: {};
  };

  type JudgeAssignmentGetPayload<
    S extends boolean | null | undefined | JudgeAssignmentDefaultArgs,
  > = $Result.GetResult<Prisma.$JudgeAssignmentPayload, S>;

  type JudgeAssignmentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    JudgeAssignmentFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: JudgeAssignmentCountAggregateInputType | true;
  };

  export interface JudgeAssignmentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["JudgeAssignment"];
      meta: { name: "JudgeAssignment" };
    };
    /**
     * Find zero or one JudgeAssignment that matches the filter.
     * @param {JudgeAssignmentFindUniqueArgs} args - Arguments to find a JudgeAssignment
     * @example
     * // Get one JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JudgeAssignmentFindUniqueArgs>(
      args: SelectSubset<T, JudgeAssignmentFindUniqueArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one JudgeAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JudgeAssignmentFindUniqueOrThrowArgs} args - Arguments to find a JudgeAssignment
     * @example
     * // Get one JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JudgeAssignmentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, JudgeAssignmentFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first JudgeAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentFindFirstArgs} args - Arguments to find a JudgeAssignment
     * @example
     * // Get one JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JudgeAssignmentFindFirstArgs>(
      args?: SelectSubset<T, JudgeAssignmentFindFirstArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first JudgeAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentFindFirstOrThrowArgs} args - Arguments to find a JudgeAssignment
     * @example
     * // Get one JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JudgeAssignmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JudgeAssignmentFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more JudgeAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JudgeAssignments
     * const judgeAssignments = await prisma.judgeAssignment.findMany()
     *
     * // Get first 10 JudgeAssignments
     * const judgeAssignments = await prisma.judgeAssignment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const judgeAssignmentWithIdOnly = await prisma.judgeAssignment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends JudgeAssignmentFindManyArgs>(
      args?: SelectSubset<T, JudgeAssignmentFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a JudgeAssignment.
     * @param {JudgeAssignmentCreateArgs} args - Arguments to create a JudgeAssignment.
     * @example
     * // Create one JudgeAssignment
     * const JudgeAssignment = await prisma.judgeAssignment.create({
     *   data: {
     *     // ... data to create a JudgeAssignment
     *   }
     * })
     *
     */
    create<T extends JudgeAssignmentCreateArgs>(
      args: SelectSubset<T, JudgeAssignmentCreateArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many JudgeAssignments.
     * @param {JudgeAssignmentCreateManyArgs} args - Arguments to create many JudgeAssignments.
     * @example
     * // Create many JudgeAssignments
     * const judgeAssignment = await prisma.judgeAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends JudgeAssignmentCreateManyArgs>(
      args?: SelectSubset<T, JudgeAssignmentCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a JudgeAssignment.
     * @param {JudgeAssignmentDeleteArgs} args - Arguments to delete one JudgeAssignment.
     * @example
     * // Delete one JudgeAssignment
     * const JudgeAssignment = await prisma.judgeAssignment.delete({
     *   where: {
     *     // ... filter to delete one JudgeAssignment
     *   }
     * })
     *
     */
    delete<T extends JudgeAssignmentDeleteArgs>(
      args: SelectSubset<T, JudgeAssignmentDeleteArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one JudgeAssignment.
     * @param {JudgeAssignmentUpdateArgs} args - Arguments to update one JudgeAssignment.
     * @example
     * // Update one JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends JudgeAssignmentUpdateArgs>(
      args: SelectSubset<T, JudgeAssignmentUpdateArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more JudgeAssignments.
     * @param {JudgeAssignmentDeleteManyArgs} args - Arguments to filter JudgeAssignments to delete.
     * @example
     * // Delete a few JudgeAssignments
     * const { count } = await prisma.judgeAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends JudgeAssignmentDeleteManyArgs>(
      args?: SelectSubset<T, JudgeAssignmentDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more JudgeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JudgeAssignments
     * const judgeAssignment = await prisma.judgeAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends JudgeAssignmentUpdateManyArgs>(
      args: SelectSubset<T, JudgeAssignmentUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one JudgeAssignment.
     * @param {JudgeAssignmentUpsertArgs} args - Arguments to update or create a JudgeAssignment.
     * @example
     * // Update or create a JudgeAssignment
     * const judgeAssignment = await prisma.judgeAssignment.upsert({
     *   create: {
     *     // ... data to create a JudgeAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JudgeAssignment we want to update
     *   }
     * })
     */
    upsert<T extends JudgeAssignmentUpsertArgs>(
      args: SelectSubset<T, JudgeAssignmentUpsertArgs<ExtArgs>>,
    ): Prisma__JudgeAssignmentClient<
      $Result.GetResult<
        Prisma.$JudgeAssignmentPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of JudgeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentCountArgs} args - Arguments to filter JudgeAssignments to count.
     * @example
     * // Count the number of JudgeAssignments
     * const count = await prisma.judgeAssignment.count({
     *   where: {
     *     // ... the filter for the JudgeAssignments we want to count
     *   }
     * })
     **/
    count<T extends JudgeAssignmentCountArgs>(
      args?: Subset<T, JudgeAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], JudgeAssignmentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a JudgeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends JudgeAssignmentAggregateArgs>(
      args: Subset<T, JudgeAssignmentAggregateArgs>,
    ): Prisma.PrismaPromise<GetJudgeAssignmentAggregateType<T>>;

    /**
     * Group by JudgeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends JudgeAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JudgeAssignmentGroupByArgs["orderBy"] }
        : { orderBy?: JudgeAssignmentGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, JudgeAssignmentGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetJudgeAssignmentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the JudgeAssignment model
     */
    readonly fields: JudgeAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JudgeAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JudgeAssignmentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the JudgeAssignment model
   */
  interface JudgeAssignmentFieldRefs {
    readonly id: FieldRef<"JudgeAssignment", "String">;
    readonly eventId: FieldRef<"JudgeAssignment", "String">;
    readonly userId: FieldRef<"JudgeAssignment", "String">;
    readonly role: FieldRef<"JudgeAssignment", "JudgeRole">;
  }

  // Custom InputTypes
  /**
   * JudgeAssignment findUnique
   */
  export type JudgeAssignmentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter, which JudgeAssignment to fetch.
     */
    where: JudgeAssignmentWhereUniqueInput;
  };

  /**
   * JudgeAssignment findUniqueOrThrow
   */
  export type JudgeAssignmentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter, which JudgeAssignment to fetch.
     */
    where: JudgeAssignmentWhereUniqueInput;
  };

  /**
   * JudgeAssignment findFirst
   */
  export type JudgeAssignmentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter, which JudgeAssignment to fetch.
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JudgeAssignments to fetch.
     */
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JudgeAssignments.
     */
    cursor?: JudgeAssignmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JudgeAssignments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JudgeAssignments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JudgeAssignments.
     */
    distinct?:
      | JudgeAssignmentScalarFieldEnum
      | JudgeAssignmentScalarFieldEnum[];
  };

  /**
   * JudgeAssignment findFirstOrThrow
   */
  export type JudgeAssignmentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter, which JudgeAssignment to fetch.
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JudgeAssignments to fetch.
     */
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for JudgeAssignments.
     */
    cursor?: JudgeAssignmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JudgeAssignments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JudgeAssignments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of JudgeAssignments.
     */
    distinct?:
      | JudgeAssignmentScalarFieldEnum
      | JudgeAssignmentScalarFieldEnum[];
  };

  /**
   * JudgeAssignment findMany
   */
  export type JudgeAssignmentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter, which JudgeAssignments to fetch.
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of JudgeAssignments to fetch.
     */
    orderBy?:
      | JudgeAssignmentOrderByWithRelationInput
      | JudgeAssignmentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing JudgeAssignments.
     */
    cursor?: JudgeAssignmentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` JudgeAssignments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` JudgeAssignments.
     */
    skip?: number;
    distinct?:
      | JudgeAssignmentScalarFieldEnum
      | JudgeAssignmentScalarFieldEnum[];
  };

  /**
   * JudgeAssignment create
   */
  export type JudgeAssignmentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * The data needed to create a JudgeAssignment.
     */
    data: XOR<JudgeAssignmentCreateInput, JudgeAssignmentUncheckedCreateInput>;
  };

  /**
   * JudgeAssignment createMany
   */
  export type JudgeAssignmentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many JudgeAssignments.
     */
    data: JudgeAssignmentCreateManyInput | JudgeAssignmentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * JudgeAssignment update
   */
  export type JudgeAssignmentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * The data needed to update a JudgeAssignment.
     */
    data: XOR<JudgeAssignmentUpdateInput, JudgeAssignmentUncheckedUpdateInput>;
    /**
     * Choose, which JudgeAssignment to update.
     */
    where: JudgeAssignmentWhereUniqueInput;
  };

  /**
   * JudgeAssignment updateMany
   */
  export type JudgeAssignmentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update JudgeAssignments.
     */
    data: XOR<
      JudgeAssignmentUpdateManyMutationInput,
      JudgeAssignmentUncheckedUpdateManyInput
    >;
    /**
     * Filter which JudgeAssignments to update
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * Limit how many JudgeAssignments to update.
     */
    limit?: number;
  };

  /**
   * JudgeAssignment upsert
   */
  export type JudgeAssignmentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * The filter to search for the JudgeAssignment to update in case it exists.
     */
    where: JudgeAssignmentWhereUniqueInput;
    /**
     * In case the JudgeAssignment found by the `where` argument doesn't exist, create a new JudgeAssignment with this data.
     */
    create: XOR<
      JudgeAssignmentCreateInput,
      JudgeAssignmentUncheckedCreateInput
    >;
    /**
     * In case the JudgeAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      JudgeAssignmentUpdateInput,
      JudgeAssignmentUncheckedUpdateInput
    >;
  };

  /**
   * JudgeAssignment delete
   */
  export type JudgeAssignmentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
    /**
     * Filter which JudgeAssignment to delete.
     */
    where: JudgeAssignmentWhereUniqueInput;
  };

  /**
   * JudgeAssignment deleteMany
   */
  export type JudgeAssignmentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which JudgeAssignments to delete
     */
    where?: JudgeAssignmentWhereInput;
    /**
     * Limit how many JudgeAssignments to delete.
     */
    limit?: number;
  };

  /**
   * JudgeAssignment without action
   */
  export type JudgeAssignmentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeAssignment
     */
    select?: JudgeAssignmentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the JudgeAssignment
     */
    omit?: JudgeAssignmentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeAssignmentInclude<ExtArgs> | null;
  };

  /**
   * Model Score
   */

  export type AggregateScore = {
    _count: ScoreCountAggregateOutputType | null;
    _avg: ScoreAvgAggregateOutputType | null;
    _sum: ScoreSumAggregateOutputType | null;
    _min: ScoreMinAggregateOutputType | null;
    _max: ScoreMaxAggregateOutputType | null;
  };

  export type ScoreAvgAggregateOutputType = {
    total: number | null;
  };

  export type ScoreSumAggregateOutputType = {
    total: number | null;
  };

  export type ScoreMinAggregateOutputType = {
    id: string | null;
    submissionId: string | null;
    judgeId: string | null;
    total: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ScoreMaxAggregateOutputType = {
    id: string | null;
    submissionId: string | null;
    judgeId: string | null;
    total: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ScoreCountAggregateOutputType = {
    id: number;
    submissionId: number;
    judgeId: number;
    total: number;
    breakdown: number;
    feedback: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ScoreAvgAggregateInputType = {
    total?: true;
  };

  export type ScoreSumAggregateInputType = {
    total?: true;
  };

  export type ScoreMinAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    total?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ScoreMaxAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    total?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ScoreCountAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    total?: true;
    breakdown?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ScoreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Score to aggregate.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Scores
     **/
    _count?: true | ScoreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ScoreAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ScoreSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ScoreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ScoreMaxAggregateInputType;
  };

  export type GetScoreAggregateType<T extends ScoreAggregateArgs> = {
    [P in keyof T & keyof AggregateScore]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScore[P]>
      : GetScalarType<T[P], AggregateScore[P]>;
  };

  export type ScoreGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
    orderBy?:
      | ScoreOrderByWithAggregationInput
      | ScoreOrderByWithAggregationInput[];
    by: ScoreScalarFieldEnum[] | ScoreScalarFieldEnum;
    having?: ScoreScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ScoreCountAggregateInputType | true;
    _avg?: ScoreAvgAggregateInputType;
    _sum?: ScoreSumAggregateInputType;
    _min?: ScoreMinAggregateInputType;
    _max?: ScoreMaxAggregateInputType;
  };

  export type ScoreGroupByOutputType = {
    id: string;
    submissionId: string;
    judgeId: string;
    total: number | null;
    breakdown: JsonValue | null;
    feedback: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ScoreCountAggregateOutputType | null;
    _avg: ScoreAvgAggregateOutputType | null;
    _sum: ScoreSumAggregateOutputType | null;
    _min: ScoreMinAggregateOutputType | null;
    _max: ScoreMaxAggregateOutputType | null;
  };

  type GetScoreGroupByPayload<T extends ScoreGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ScoreGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ScoreGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ScoreGroupByOutputType[P]>;
        }
      >
    >;

  export type ScoreSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      submissionId?: boolean;
      judgeId?: boolean;
      total?: boolean;
      breakdown?: boolean;
      feedback?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
      judge?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["score"]
  >;

  export type ScoreSelectScalar = {
    id?: boolean;
    submissionId?: boolean;
    judgeId?: boolean;
    total?: boolean;
    breakdown?: boolean;
    feedback?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ScoreOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "submissionId"
    | "judgeId"
    | "total"
    | "breakdown"
    | "feedback"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["score"]
  >;
  export type ScoreInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
    judge?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ScorePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Score";
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>;
      judge: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        submissionId: string;
        judgeId: string;
        total: number | null;
        breakdown: Prisma.JsonValue | null;
        feedback: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["score"]
    >;
    composites: {};
  };

  type ScoreGetPayload<
    S extends boolean | null | undefined | ScoreDefaultArgs,
  > = $Result.GetResult<Prisma.$ScorePayload, S>;

  type ScoreCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ScoreFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ScoreCountAggregateInputType | true;
  };

  export interface ScoreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Score"];
      meta: { name: "Score" };
    };
    /**
     * Find zero or one Score that matches the filter.
     * @param {ScoreFindUniqueArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoreFindUniqueArgs>(
      args: SelectSubset<T, ScoreFindUniqueArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Score that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScoreFindUniqueOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ScoreFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Score that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoreFindFirstArgs>(
      args?: SelectSubset<T, ScoreFindFirstArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Score that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScoreFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scores
     * const scores = await prisma.score.findMany()
     *
     * // Get first 10 Scores
     * const scores = await prisma.score.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const scoreWithIdOnly = await prisma.score.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ScoreFindManyArgs>(
      args?: SelectSubset<T, ScoreFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Score.
     * @param {ScoreCreateArgs} args - Arguments to create a Score.
     * @example
     * // Create one Score
     * const Score = await prisma.score.create({
     *   data: {
     *     // ... data to create a Score
     *   }
     * })
     *
     */
    create<T extends ScoreCreateArgs>(
      args: SelectSubset<T, ScoreCreateArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Scores.
     * @param {ScoreCreateManyArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ScoreCreateManyArgs>(
      args?: SelectSubset<T, ScoreCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Score.
     * @param {ScoreDeleteArgs} args - Arguments to delete one Score.
     * @example
     * // Delete one Score
     * const Score = await prisma.score.delete({
     *   where: {
     *     // ... filter to delete one Score
     *   }
     * })
     *
     */
    delete<T extends ScoreDeleteArgs>(
      args: SelectSubset<T, ScoreDeleteArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Score.
     * @param {ScoreUpdateArgs} args - Arguments to update one Score.
     * @example
     * // Update one Score
     * const score = await prisma.score.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ScoreUpdateArgs>(
      args: SelectSubset<T, ScoreUpdateArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Scores.
     * @param {ScoreDeleteManyArgs} args - Arguments to filter Scores to delete.
     * @example
     * // Delete a few Scores
     * const { count } = await prisma.score.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ScoreDeleteManyArgs>(
      args?: SelectSubset<T, ScoreDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scores
     * const score = await prisma.score.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ScoreUpdateManyArgs>(
      args: SelectSubset<T, ScoreUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Score.
     * @param {ScoreUpsertArgs} args - Arguments to update or create a Score.
     * @example
     * // Update or create a Score
     * const score = await prisma.score.upsert({
     *   create: {
     *     // ... data to create a Score
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Score we want to update
     *   }
     * })
     */
    upsert<T extends ScoreUpsertArgs>(
      args: SelectSubset<T, ScoreUpsertArgs<ExtArgs>>,
    ): Prisma__ScoreClient<
      $Result.GetResult<
        Prisma.$ScorePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreCountArgs} args - Arguments to filter Scores to count.
     * @example
     * // Count the number of Scores
     * const count = await prisma.score.count({
     *   where: {
     *     // ... the filter for the Scores we want to count
     *   }
     * })
     **/
    count<T extends ScoreCountArgs>(
      args?: Subset<T, ScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ScoreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ScoreAggregateArgs>(
      args: Subset<T, ScoreAggregateArgs>,
    ): Prisma.PrismaPromise<GetScoreAggregateType<T>>;

    /**
     * Group by Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreGroupByArgs["orderBy"] }
        : { orderBy?: ScoreGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ScoreGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetScoreGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Score model
     */
    readonly fields: ScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Score.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>,
    ): Prisma__SubmissionClient<
      | $Result.GetResult<
          Prisma.$SubmissionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    judge<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Score model
   */
  interface ScoreFieldRefs {
    readonly id: FieldRef<"Score", "String">;
    readonly submissionId: FieldRef<"Score", "String">;
    readonly judgeId: FieldRef<"Score", "String">;
    readonly total: FieldRef<"Score", "Float">;
    readonly breakdown: FieldRef<"Score", "Json">;
    readonly feedback: FieldRef<"Score", "String">;
    readonly createdAt: FieldRef<"Score", "DateTime">;
    readonly updatedAt: FieldRef<"Score", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Score findUnique
   */
  export type ScoreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score findUniqueOrThrow
   */
  export type ScoreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score findFirst
   */
  export type ScoreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score findFirstOrThrow
   */
  export type ScoreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score findMany
   */
  export type ScoreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Scores to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score create
   */
  export type ScoreCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * The data needed to create a Score.
     */
    data: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>;
  };

  /**
   * Score createMany
   */
  export type ScoreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Score update
   */
  export type ScoreUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * The data needed to update a Score.
     */
    data: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>;
    /**
     * Choose, which Score to update.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score updateMany
   */
  export type ScoreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Scores.
     */
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyInput>;
    /**
     * Filter which Scores to update
     */
    where?: ScoreWhereInput;
    /**
     * Limit how many Scores to update.
     */
    limit?: number;
  };

  /**
   * Score upsert
   */
  export type ScoreUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * The filter to search for the Score to update in case it exists.
     */
    where: ScoreWhereUniqueInput;
    /**
     * In case the Score found by the `where` argument doesn't exist, create a new Score with this data.
     */
    create: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>;
    /**
     * In case the Score was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>;
  };

  /**
   * Score delete
   */
  export type ScoreDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter which Score to delete.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score deleteMany
   */
  export type ScoreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Scores to delete
     */
    where?: ScoreWhereInput;
    /**
     * Limit how many Scores to delete.
     */
    limit?: number;
  };

  /**
   * Score without action
   */
  export type ScoreDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
  };

  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  export type AnnouncementMinAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    title: string | null;
    createdAt: Date | null;
  };

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null;
    eventId: string | null;
    title: string | null;
    createdAt: Date | null;
  };

  export type AnnouncementCountAggregateOutputType = {
    id: number;
    eventId: number;
    title: number;
    bodyRich: number;
    createdAt: number;
    _all: number;
  };

  export type AnnouncementMinAggregateInputType = {
    id?: true;
    eventId?: true;
    title?: true;
    createdAt?: true;
  };

  export type AnnouncementMaxAggregateInputType = {
    id?: true;
    eventId?: true;
    title?: true;
    createdAt?: true;
  };

  export type AnnouncementCountAggregateInputType = {
    id?: true;
    eventId?: true;
    title?: true;
    bodyRich?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AnnouncementAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Announcements
     **/
    _count?: true | AnnouncementCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnnouncementMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type GetAnnouncementAggregateType<
    T extends AnnouncementAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnnouncement]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>;
  };

  export type AnnouncementGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
    orderBy?:
      | AnnouncementOrderByWithAggregationInput
      | AnnouncementOrderByWithAggregationInput[];
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum;
    having?: AnnouncementScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnnouncementCountAggregateInputType | true;
    _min?: AnnouncementMinAggregateInputType;
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type AnnouncementGroupByOutputType = {
    id: string;
    eventId: string;
    title: string;
    bodyRich: JsonValue | null;
    createdAt: Date;
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AnnouncementGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof AnnouncementGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>;
        }
      >
    >;

  export type AnnouncementSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      eventId?: boolean;
      title?: boolean;
      bodyRich?: boolean;
      createdAt?: boolean;
      event?: boolean | EventDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["announcement"]
  >;

  export type AnnouncementSelectScalar = {
    id?: boolean;
    eventId?: boolean;
    title?: boolean;
    bodyRich?: boolean;
    createdAt?: boolean;
  };

  export type AnnouncementOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "id" | "eventId" | "title" | "bodyRich" | "createdAt",
    ExtArgs["result"]["announcement"]
  >;
  export type AnnouncementInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    event?: boolean | EventDefaultArgs<ExtArgs>;
  };

  export type $AnnouncementPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Announcement";
    objects: {
      event: Prisma.$EventPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        eventId: string;
        title: string;
        bodyRich: Prisma.JsonValue | null;
        createdAt: Date;
      },
      ExtArgs["result"]["announcement"]
    >;
    composites: {};
  };

  type AnnouncementGetPayload<
    S extends boolean | null | undefined | AnnouncementDefaultArgs,
  > = $Result.GetResult<Prisma.$AnnouncementPayload, S>;

  type AnnouncementCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnnouncementFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AnnouncementCountAggregateInputType | true;
  };

  export interface AnnouncementDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Announcement"];
      meta: { name: "Announcement" };
    };
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     *
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnnouncementFindManyArgs>(
      args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     *
     */
    create<T extends AnnouncementCreateArgs>(
      args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnnouncementCreateManyArgs>(
      args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     *
     */
    delete<T extends AnnouncementDeleteArgs>(
      args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnnouncementUpdateArgs>(
      args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(
      args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(
      args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(
      args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>,
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
     **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AnnouncementCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnnouncementAggregateArgs>(
      args: Subset<T, AnnouncementAggregateArgs>,
    ): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>;

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs["orderBy"] }
        : { orderBy?: AnnouncementGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAnnouncementGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Announcement model
     */
    readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    event<T extends EventDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, EventDefaultArgs<ExtArgs>>,
    ): Prisma__EventClient<
      | $Result.GetResult<
          Prisma.$EventPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", "String">;
    readonly eventId: FieldRef<"Announcement", "String">;
    readonly title: FieldRef<"Announcement", "String">;
    readonly bodyRich: FieldRef<"Announcement", "Json">;
    readonly createdAt: FieldRef<"Announcement", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
  };

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<
      AnnouncementUpdateManyMutationInput,
      AnnouncementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput;
    /**
     * Limit how many Announcements to update.
     */
    limit?: number;
  };

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput;
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
  };

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput;
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number;
  };

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
  };

  /**
   * Model ContactMessage
   */

  export type AggregateContactMessage = {
    _count: ContactMessageCountAggregateOutputType | null;
    _min: ContactMessageMinAggregateOutputType | null;
    _max: ContactMessageMaxAggregateOutputType | null;
  };

  export type ContactMessageMinAggregateOutputType = {
    id: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    organization: string | null;
    message: string | null;
    createdAt: Date | null;
    readAt: Date | null;
  };

  export type ContactMessageMaxAggregateOutputType = {
    id: string | null;
    firstName: string | null;
    lastName: string | null;
    email: string | null;
    phone: string | null;
    organization: string | null;
    message: string | null;
    createdAt: Date | null;
    readAt: Date | null;
  };

  export type ContactMessageCountAggregateOutputType = {
    id: number;
    firstName: number;
    lastName: number;
    email: number;
    phone: number;
    organization: number;
    message: number;
    createdAt: number;
    readAt: number;
    _all: number;
  };

  export type ContactMessageMinAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    organization?: true;
    message?: true;
    createdAt?: true;
    readAt?: true;
  };

  export type ContactMessageMaxAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    organization?: true;
    message?: true;
    createdAt?: true;
    readAt?: true;
  };

  export type ContactMessageCountAggregateInputType = {
    id?: true;
    firstName?: true;
    lastName?: true;
    email?: true;
    phone?: true;
    organization?: true;
    message?: true;
    createdAt?: true;
    readAt?: true;
    _all?: true;
  };

  export type ContactMessageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ContactMessage to aggregate.
     */
    where?: ContactMessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?:
      | ContactMessageOrderByWithRelationInput
      | ContactMessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ContactMessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContactMessages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ContactMessages
     **/
    _count?: true | ContactMessageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ContactMessageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ContactMessageMaxAggregateInputType;
  };

  export type GetContactMessageAggregateType<
    T extends ContactMessageAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateContactMessage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactMessage[P]>
      : GetScalarType<T[P], AggregateContactMessage[P]>;
  };

  export type ContactMessageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ContactMessageWhereInput;
    orderBy?:
      | ContactMessageOrderByWithAggregationInput
      | ContactMessageOrderByWithAggregationInput[];
    by: ContactMessageScalarFieldEnum[] | ContactMessageScalarFieldEnum;
    having?: ContactMessageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ContactMessageCountAggregateInputType | true;
    _min?: ContactMessageMinAggregateInputType;
    _max?: ContactMessageMaxAggregateInputType;
  };

  export type ContactMessageGroupByOutputType = {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phone: string | null;
    organization: string | null;
    message: string;
    createdAt: Date;
    readAt: Date | null;
    _count: ContactMessageCountAggregateOutputType | null;
    _min: ContactMessageMinAggregateOutputType | null;
    _max: ContactMessageMaxAggregateOutputType | null;
  };

  type GetContactMessageGroupByPayload<T extends ContactMessageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ContactMessageGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ContactMessageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>;
        }
      >
    >;

  export type ContactMessageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      email?: boolean;
      phone?: boolean;
      organization?: boolean;
      message?: boolean;
      createdAt?: boolean;
      readAt?: boolean;
    },
    ExtArgs["result"]["contactMessage"]
  >;

  export type ContactMessageSelectScalar = {
    id?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    email?: boolean;
    phone?: boolean;
    organization?: boolean;
    message?: boolean;
    createdAt?: boolean;
    readAt?: boolean;
  };

  export type ContactMessageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "firstName"
    | "lastName"
    | "email"
    | "phone"
    | "organization"
    | "message"
    | "createdAt"
    | "readAt",
    ExtArgs["result"]["contactMessage"]
  >;

  export type $ContactMessagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ContactMessage";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firstName: string;
        lastName: string;
        email: string;
        phone: string | null;
        organization: string | null;
        message: string;
        createdAt: Date;
        readAt: Date | null;
      },
      ExtArgs["result"]["contactMessage"]
    >;
    composites: {};
  };

  type ContactMessageGetPayload<
    S extends boolean | null | undefined | ContactMessageDefaultArgs,
  > = $Result.GetResult<Prisma.$ContactMessagePayload, S>;

  type ContactMessageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ContactMessageFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ContactMessageCountAggregateInputType | true;
  };

  export interface ContactMessageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ContactMessage"];
      meta: { name: "ContactMessage" };
    };
    /**
     * Find zero or one ContactMessage that matches the filter.
     * @param {ContactMessageFindUniqueArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactMessageFindUniqueArgs>(
      args: SelectSubset<T, ContactMessageFindUniqueArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ContactMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactMessageFindUniqueOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactMessageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ContactMessageFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ContactMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactMessageFindFirstArgs>(
      args?: SelectSubset<T, ContactMessageFindFirstArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ContactMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContactMessageFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ContactMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany()
     *
     * // Get first 10 ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ContactMessageFindManyArgs>(
      args?: SelectSubset<T, ContactMessageFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ContactMessage.
     * @param {ContactMessageCreateArgs} args - Arguments to create a ContactMessage.
     * @example
     * // Create one ContactMessage
     * const ContactMessage = await prisma.contactMessage.create({
     *   data: {
     *     // ... data to create a ContactMessage
     *   }
     * })
     *
     */
    create<T extends ContactMessageCreateArgs>(
      args: SelectSubset<T, ContactMessageCreateArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ContactMessages.
     * @param {ContactMessageCreateManyArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ContactMessageCreateManyArgs>(
      args?: SelectSubset<T, ContactMessageCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ContactMessage.
     * @param {ContactMessageDeleteArgs} args - Arguments to delete one ContactMessage.
     * @example
     * // Delete one ContactMessage
     * const ContactMessage = await prisma.contactMessage.delete({
     *   where: {
     *     // ... filter to delete one ContactMessage
     *   }
     * })
     *
     */
    delete<T extends ContactMessageDeleteArgs>(
      args: SelectSubset<T, ContactMessageDeleteArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ContactMessage.
     * @param {ContactMessageUpdateArgs} args - Arguments to update one ContactMessage.
     * @example
     * // Update one ContactMessage
     * const contactMessage = await prisma.contactMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ContactMessageUpdateArgs>(
      args: SelectSubset<T, ContactMessageUpdateArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ContactMessages.
     * @param {ContactMessageDeleteManyArgs} args - Arguments to filter ContactMessages to delete.
     * @example
     * // Delete a few ContactMessages
     * const { count } = await prisma.contactMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ContactMessageDeleteManyArgs>(
      args?: SelectSubset<T, ContactMessageDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ContactMessageUpdateManyArgs>(
      args: SelectSubset<T, ContactMessageUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ContactMessage.
     * @param {ContactMessageUpsertArgs} args - Arguments to update or create a ContactMessage.
     * @example
     * // Update or create a ContactMessage
     * const contactMessage = await prisma.contactMessage.upsert({
     *   create: {
     *     // ... data to create a ContactMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactMessage we want to update
     *   }
     * })
     */
    upsert<T extends ContactMessageUpsertArgs>(
      args: SelectSubset<T, ContactMessageUpsertArgs<ExtArgs>>,
    ): Prisma__ContactMessageClient<
      $Result.GetResult<
        Prisma.$ContactMessagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageCountArgs} args - Arguments to filter ContactMessages to count.
     * @example
     * // Count the number of ContactMessages
     * const count = await prisma.contactMessage.count({
     *   where: {
     *     // ... the filter for the ContactMessages we want to count
     *   }
     * })
     **/
    count<T extends ContactMessageCountArgs>(
      args?: Subset<T, ContactMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ContactMessageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ContactMessageAggregateArgs>(
      args: Subset<T, ContactMessageAggregateArgs>,
    ): Prisma.PrismaPromise<GetContactMessageAggregateType<T>>;

    /**
     * Group by ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ContactMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactMessageGroupByArgs["orderBy"] }
        : { orderBy?: ContactMessageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ContactMessageGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetContactMessageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ContactMessage model
     */
    readonly fields: ContactMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactMessageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ContactMessage model
   */
  interface ContactMessageFieldRefs {
    readonly id: FieldRef<"ContactMessage", "String">;
    readonly firstName: FieldRef<"ContactMessage", "String">;
    readonly lastName: FieldRef<"ContactMessage", "String">;
    readonly email: FieldRef<"ContactMessage", "String">;
    readonly phone: FieldRef<"ContactMessage", "String">;
    readonly organization: FieldRef<"ContactMessage", "String">;
    readonly message: FieldRef<"ContactMessage", "String">;
    readonly createdAt: FieldRef<"ContactMessage", "DateTime">;
    readonly readAt: FieldRef<"ContactMessage", "DateTime">;
  }

  // Custom InputTypes
  /**
   * ContactMessage findUnique
   */
  export type ContactMessageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput;
  };

  /**
   * ContactMessage findUniqueOrThrow
   */
  export type ContactMessageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput;
  };

  /**
   * ContactMessage findFirst
   */
  export type ContactMessageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?:
      | ContactMessageOrderByWithRelationInput
      | ContactMessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContactMessages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[];
  };

  /**
   * ContactMessage findFirstOrThrow
   */
  export type ContactMessageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?:
      | ContactMessageOrderByWithRelationInput
      | ContactMessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContactMessages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[];
  };

  /**
   * ContactMessage findMany
   */
  export type ContactMessageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter, which ContactMessages to fetch.
     */
    where?: ContactMessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?:
      | ContactMessageOrderByWithRelationInput
      | ContactMessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ContactMessages.
     */
    skip?: number;
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[];
  };

  /**
   * ContactMessage create
   */
  export type ContactMessageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * The data needed to create a ContactMessage.
     */
    data: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>;
  };

  /**
   * ContactMessage createMany
   */
  export type ContactMessageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ContactMessage update
   */
  export type ContactMessageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * The data needed to update a ContactMessage.
     */
    data: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>;
    /**
     * Choose, which ContactMessage to update.
     */
    where: ContactMessageWhereUniqueInput;
  };

  /**
   * ContactMessage updateMany
   */
  export type ContactMessageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<
      ContactMessageUpdateManyMutationInput,
      ContactMessageUncheckedUpdateManyInput
    >;
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput;
    /**
     * Limit how many ContactMessages to update.
     */
    limit?: number;
  };

  /**
   * ContactMessage upsert
   */
  export type ContactMessageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * The filter to search for the ContactMessage to update in case it exists.
     */
    where: ContactMessageWhereUniqueInput;
    /**
     * In case the ContactMessage found by the `where` argument doesn't exist, create a new ContactMessage with this data.
     */
    create: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>;
    /**
     * In case the ContactMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>;
  };

  /**
   * ContactMessage delete
   */
  export type ContactMessageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
    /**
     * Filter which ContactMessage to delete.
     */
    where: ContactMessageWhereUniqueInput;
  };

  /**
   * ContactMessage deleteMany
   */
  export type ContactMessageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ContactMessages to delete
     */
    where?: ContactMessageWhereInput;
    /**
     * Limit how many ContactMessages to delete.
     */
    limit?: number;
  };

  /**
   * ContactMessage without action
   */
  export type ContactMessageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ContactMessage
     */
    omit?: ContactMessageOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: "id";
    email: "email";
    name: "name";
    imageUrl: "imageUrl";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const OrganizationScalarFieldEnum: {
    id: "id";
    name: "name";
    slug: "slug";
    logoUrl: "logoUrl";
    description: "description";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type OrganizationScalarFieldEnum =
    (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum];

  export const OrgMembershipScalarFieldEnum: {
    id: "id";
    orgId: "orgId";
    userId: "userId";
    role: "role";
    createdAt: "createdAt";
  };

  export type OrgMembershipScalarFieldEnum =
    (typeof OrgMembershipScalarFieldEnum)[keyof typeof OrgMembershipScalarFieldEnum];

  export const EventScalarFieldEnum: {
    id: "id";
    orgId: "orgId";
    name: "name";
    slug: "slug";
    type: "type";
    status: "status";
    heroTitle: "heroTitle";
    heroSubtitle: "heroSubtitle";
    rulesRich: "rulesRich";
    rubricRich: "rubricRich";
    startAt: "startAt";
    endAt: "endAt";
    submitDueAt: "submitDueAt";
    requireImages: "requireImages";
    requireVideoDemo: "requireVideoDemo";
    visibility: "visibility";
    joinMode: "joinMode";
    registrationOpensAt: "registrationOpensAt";
    registrationClosesAt: "registrationClosesAt";
    maxTeamSize: "maxTeamSize";
    lockTeamChangesAtStart: "lockTeamChangesAtStart";
    allowSelfJoinRequests: "allowSelfJoinRequests";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type EventScalarFieldEnum =
    (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

  export const EventRegistrationRequestScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
    message: "message";
    status: "status";
    createdAt: "createdAt";
    reviewedAt: "reviewedAt";
    reviewedByUserId: "reviewedByUserId";
  };

  export type EventRegistrationRequestScalarFieldEnum =
    (typeof EventRegistrationRequestScalarFieldEnum)[keyof typeof EventRegistrationRequestScalarFieldEnum];

  export const EventParticipantScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
    status: "status";
    newsletterOptIn: "newsletterOptIn";
    contactEmail: "contactEmail";
    lookingForTeam: "lookingForTeam";
    trackPreference: "trackPreference";
    skills: "skills";
    interests: "interests";
    experienceLevel: "experienceLevel";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type EventParticipantScalarFieldEnum =
    (typeof EventParticipantScalarFieldEnum)[keyof typeof EventParticipantScalarFieldEnum];

  export const SubmissionSchemaScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    fields: "fields";
  };

  export type SubmissionSchemaScalarFieldEnum =
    (typeof SubmissionSchemaScalarFieldEnum)[keyof typeof SubmissionSchemaScalarFieldEnum];

  export const TeamScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    name: "name";
    blurb: "blurb";
    track: "track";
    lookingForMembers: "lookingForMembers";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type TeamScalarFieldEnum =
    (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

  export const TeamMemberScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    userId: "userId";
    role: "role";
  };

  export type TeamMemberScalarFieldEnum =
    (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

  export const TeamInviteScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    email: "email";
    token: "token";
    status: "status";
    message: "message";
    createdByUserId: "createdByUserId";
    createdAt: "createdAt";
    expiresAt: "expiresAt";
  };

  export type TeamInviteScalarFieldEnum =
    (typeof TeamInviteScalarFieldEnum)[keyof typeof TeamInviteScalarFieldEnum];

  export const TeamJoinRequestScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    userId: "userId";
    message: "message";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type TeamJoinRequestScalarFieldEnum =
    (typeof TeamJoinRequestScalarFieldEnum)[keyof typeof TeamJoinRequestScalarFieldEnum];

  export const TeamAuditLogScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    actorId: "actorId";
    targetUserId: "targetUserId";
    action: "action";
    meta: "meta";
    createdAt: "createdAt";
  };

  export type TeamAuditLogScalarFieldEnum =
    (typeof TeamAuditLogScalarFieldEnum)[keyof typeof TeamAuditLogScalarFieldEnum];

  export const SubmissionScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    authorId: "authorId";
    status: "status";
    title: "title";
    description: "description";
    content: "content";
    imageUrls: "imageUrls";
    videoUrl: "videoUrl";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    submittedAt: "submittedAt";
  };

  export type SubmissionScalarFieldEnum =
    (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum];

  export const JudgeAssignmentScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
    role: "role";
  };

  export type JudgeAssignmentScalarFieldEnum =
    (typeof JudgeAssignmentScalarFieldEnum)[keyof typeof JudgeAssignmentScalarFieldEnum];

  export const ScoreScalarFieldEnum: {
    id: "id";
    submissionId: "submissionId";
    judgeId: "judgeId";
    total: "total";
    breakdown: "breakdown";
    feedback: "feedback";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ScoreScalarFieldEnum =
    (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum];

  export const AnnouncementScalarFieldEnum: {
    id: "id";
    eventId: "eventId";
    title: "title";
    bodyRich: "bodyRich";
    createdAt: "createdAt";
  };

  export type AnnouncementScalarFieldEnum =
    (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum];

  export const ContactMessageScalarFieldEnum: {
    id: "id";
    firstName: "firstName";
    lastName: "lastName";
    email: "email";
    phone: "phone";
    organization: "organization";
    message: "message";
    createdAt: "createdAt";
    readAt: "readAt";
  };

  export type ContactMessageScalarFieldEnum =
    (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const UserOrderByRelevanceFieldEnum: {
    id: "id";
    email: "email";
    name: "name";
    imageUrl: "imageUrl";
  };

  export type UserOrderByRelevanceFieldEnum =
    (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum];

  export const OrganizationOrderByRelevanceFieldEnum: {
    id: "id";
    name: "name";
    slug: "slug";
    logoUrl: "logoUrl";
    description: "description";
  };

  export type OrganizationOrderByRelevanceFieldEnum =
    (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum];

  export const OrgMembershipOrderByRelevanceFieldEnum: {
    id: "id";
    orgId: "orgId";
    userId: "userId";
  };

  export type OrgMembershipOrderByRelevanceFieldEnum =
    (typeof OrgMembershipOrderByRelevanceFieldEnum)[keyof typeof OrgMembershipOrderByRelevanceFieldEnum];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const EventOrderByRelevanceFieldEnum: {
    id: "id";
    orgId: "orgId";
    name: "name";
    slug: "slug";
    heroTitle: "heroTitle";
    heroSubtitle: "heroSubtitle";
  };

  export type EventOrderByRelevanceFieldEnum =
    (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum];

  export const EventRegistrationRequestOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
    message: "message";
    reviewedByUserId: "reviewedByUserId";
  };

  export type EventRegistrationRequestOrderByRelevanceFieldEnum =
    (typeof EventRegistrationRequestOrderByRelevanceFieldEnum)[keyof typeof EventRegistrationRequestOrderByRelevanceFieldEnum];

  export const EventParticipantOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
    contactEmail: "contactEmail";
    trackPreference: "trackPreference";
    experienceLevel: "experienceLevel";
  };

  export type EventParticipantOrderByRelevanceFieldEnum =
    (typeof EventParticipantOrderByRelevanceFieldEnum)[keyof typeof EventParticipantOrderByRelevanceFieldEnum];

  export const SubmissionSchemaOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
  };

  export type SubmissionSchemaOrderByRelevanceFieldEnum =
    (typeof SubmissionSchemaOrderByRelevanceFieldEnum)[keyof typeof SubmissionSchemaOrderByRelevanceFieldEnum];

  export const TeamOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    name: "name";
    blurb: "blurb";
    track: "track";
  };

  export type TeamOrderByRelevanceFieldEnum =
    (typeof TeamOrderByRelevanceFieldEnum)[keyof typeof TeamOrderByRelevanceFieldEnum];

  export const TeamMemberOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    userId: "userId";
  };

  export type TeamMemberOrderByRelevanceFieldEnum =
    (typeof TeamMemberOrderByRelevanceFieldEnum)[keyof typeof TeamMemberOrderByRelevanceFieldEnum];

  export const TeamInviteOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    email: "email";
    token: "token";
    message: "message";
    createdByUserId: "createdByUserId";
  };

  export type TeamInviteOrderByRelevanceFieldEnum =
    (typeof TeamInviteOrderByRelevanceFieldEnum)[keyof typeof TeamInviteOrderByRelevanceFieldEnum];

  export const TeamJoinRequestOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    userId: "userId";
    message: "message";
  };

  export type TeamJoinRequestOrderByRelevanceFieldEnum =
    (typeof TeamJoinRequestOrderByRelevanceFieldEnum)[keyof typeof TeamJoinRequestOrderByRelevanceFieldEnum];

  export const TeamAuditLogOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    actorId: "actorId";
    targetUserId: "targetUserId";
  };

  export type TeamAuditLogOrderByRelevanceFieldEnum =
    (typeof TeamAuditLogOrderByRelevanceFieldEnum)[keyof typeof TeamAuditLogOrderByRelevanceFieldEnum];

  export const SubmissionOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    teamId: "teamId";
    authorId: "authorId";
    title: "title";
    description: "description";
    videoUrl: "videoUrl";
  };

  export type SubmissionOrderByRelevanceFieldEnum =
    (typeof SubmissionOrderByRelevanceFieldEnum)[keyof typeof SubmissionOrderByRelevanceFieldEnum];

  export const JudgeAssignmentOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    userId: "userId";
  };

  export type JudgeAssignmentOrderByRelevanceFieldEnum =
    (typeof JudgeAssignmentOrderByRelevanceFieldEnum)[keyof typeof JudgeAssignmentOrderByRelevanceFieldEnum];

  export const ScoreOrderByRelevanceFieldEnum: {
    id: "id";
    submissionId: "submissionId";
    judgeId: "judgeId";
    feedback: "feedback";
  };

  export type ScoreOrderByRelevanceFieldEnum =
    (typeof ScoreOrderByRelevanceFieldEnum)[keyof typeof ScoreOrderByRelevanceFieldEnum];

  export const AnnouncementOrderByRelevanceFieldEnum: {
    id: "id";
    eventId: "eventId";
    title: "title";
  };

  export type AnnouncementOrderByRelevanceFieldEnum =
    (typeof AnnouncementOrderByRelevanceFieldEnum)[keyof typeof AnnouncementOrderByRelevanceFieldEnum];

  export const ContactMessageOrderByRelevanceFieldEnum: {
    id: "id";
    firstName: "firstName";
    lastName: "lastName";
    email: "email";
    phone: "phone";
    organization: "organization";
    message: "message";
  };

  export type ContactMessageOrderByRelevanceFieldEnum =
    (typeof ContactMessageOrderByRelevanceFieldEnum)[keyof typeof ContactMessageOrderByRelevanceFieldEnum];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'OrgRole'
   */
  export type EnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "OrgRole"
  >;

  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventType"
  >;

  /**
   * Reference to a field of type 'EventStatus'
   */
  export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventStatus"
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Json"
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "QueryMode"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'EventVisibility'
   */
  export type EnumEventVisibilityFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "EventVisibility">;

  /**
   * Reference to a field of type 'EventJoinMode'
   */
  export type EnumEventJoinModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "EventJoinMode"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'RegistrationRequestStatus'
   */
  export type EnumRegistrationRequestStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "RegistrationRequestStatus">;

  /**
   * Reference to a field of type 'ParticipantStatus'
   */
  export type EnumParticipantStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "ParticipantStatus">;

  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "TeamRole"
  >;

  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "InviteStatus"
  >;

  /**
   * Reference to a field of type 'JoinRequestStatus'
   */
  export type EnumJoinRequestStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "JoinRequestStatus">;

  /**
   * Reference to a field of type 'TeamAuditAction'
   */
  export type EnumTeamAuditActionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "TeamAuditAction">;

  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, "SubmissionStatus">;

  /**
   * Reference to a field of type 'JudgeRole'
   */
  export type EnumJudgeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "JudgeRole"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    email?: StringFilter<"User"> | string;
    name?: StringNullableFilter<"User"> | string | null;
    imageUrl?: StringNullableFilter<"User"> | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    memberships?: OrgMembershipListRelationFilter;
    eventParticipants?: EventParticipantListRelationFilter;
    teams?: TeamMemberListRelationFilter;
    submissions?: SubmissionListRelationFilter;
    judgeLinks?: JudgeAssignmentListRelationFilter;
    teamInvitesCreated?: TeamInviteListRelationFilter;
    teamJoinRequests?: TeamJoinRequestListRelationFilter;
    teamAuditActor?: TeamAuditLogListRelationFilter;
    teamAuditTarget?: TeamAuditLogListRelationFilter;
    scoresGiven?: ScoreListRelationFilter;
    registrationRequests?: EventRegistrationRequestListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    memberships?: OrgMembershipOrderByRelationAggregateInput;
    eventParticipants?: EventParticipantOrderByRelationAggregateInput;
    teams?: TeamMemberOrderByRelationAggregateInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
    judgeLinks?: JudgeAssignmentOrderByRelationAggregateInput;
    teamInvitesCreated?: TeamInviteOrderByRelationAggregateInput;
    teamJoinRequests?: TeamJoinRequestOrderByRelationAggregateInput;
    teamAuditActor?: TeamAuditLogOrderByRelationAggregateInput;
    teamAuditTarget?: TeamAuditLogOrderByRelationAggregateInput;
    scoresGiven?: ScoreOrderByRelationAggregateInput;
    registrationRequests?: EventRegistrationRequestOrderByRelationAggregateInput;
    _relevance?: UserOrderByRelevanceInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<"User"> | string | null;
      imageUrl?: StringNullableFilter<"User"> | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      memberships?: OrgMembershipListRelationFilter;
      eventParticipants?: EventParticipantListRelationFilter;
      teams?: TeamMemberListRelationFilter;
      submissions?: SubmissionListRelationFilter;
      judgeLinks?: JudgeAssignmentListRelationFilter;
      teamInvitesCreated?: TeamInviteListRelationFilter;
      teamJoinRequests?: TeamJoinRequestListRelationFilter;
      teamAuditActor?: TeamAuditLogListRelationFilter;
      teamAuditTarget?: TeamAuditLogListRelationFilter;
      scoresGiven?: ScoreListRelationFilter;
      registrationRequests?: EventRegistrationRequestListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrderInput | SortOrder;
    imageUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    email?: StringWithAggregatesFilter<"User"> | string;
    name?: StringNullableWithAggregatesFilter<"User"> | string | null;
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
  };

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[];
    OR?: OrganizationWhereInput[];
    NOT?: OrganizationWhereInput | OrganizationWhereInput[];
    id?: StringFilter<"Organization"> | string;
    name?: StringFilter<"Organization"> | string;
    slug?: StringFilter<"Organization"> | string;
    logoUrl?: StringNullableFilter<"Organization"> | string | null;
    description?: StringNullableFilter<"Organization"> | string | null;
    createdAt?: DateTimeFilter<"Organization"> | Date | string;
    updatedAt?: DateTimeFilter<"Organization"> | Date | string;
    memberships?: OrgMembershipListRelationFilter;
    events?: EventListRelationFilter;
  };

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    memberships?: OrgMembershipOrderByRelationAggregateInput;
    events?: EventOrderByRelationAggregateInput;
    _relevance?: OrganizationOrderByRelevanceInput;
  };

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: OrganizationWhereInput | OrganizationWhereInput[];
      OR?: OrganizationWhereInput[];
      NOT?: OrganizationWhereInput | OrganizationWhereInput[];
      name?: StringFilter<"Organization"> | string;
      logoUrl?: StringNullableFilter<"Organization"> | string | null;
      description?: StringNullableFilter<"Organization"> | string | null;
      createdAt?: DateTimeFilter<"Organization"> | Date | string;
      updatedAt?: DateTimeFilter<"Organization"> | Date | string;
      memberships?: OrgMembershipListRelationFilter;
      events?: EventListRelationFilter;
    },
    "id" | "slug"
  >;

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: OrganizationCountOrderByAggregateInput;
    _max?: OrganizationMaxOrderByAggregateInput;
    _min?: OrganizationMinOrderByAggregateInput;
  };

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    OR?: OrganizationScalarWhereWithAggregatesInput[];
    NOT?:
      | OrganizationScalarWhereWithAggregatesInput
      | OrganizationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Organization"> | string;
    name?: StringWithAggregatesFilter<"Organization"> | string;
    slug?: StringWithAggregatesFilter<"Organization"> | string;
    logoUrl?:
      | StringNullableWithAggregatesFilter<"Organization">
      | string
      | null;
    description?:
      | StringNullableWithAggregatesFilter<"Organization">
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string;
  };

  export type OrgMembershipWhereInput = {
    AND?: OrgMembershipWhereInput | OrgMembershipWhereInput[];
    OR?: OrgMembershipWhereInput[];
    NOT?: OrgMembershipWhereInput | OrgMembershipWhereInput[];
    id?: StringFilter<"OrgMembership"> | string;
    orgId?: StringFilter<"OrgMembership"> | string;
    userId?: StringFilter<"OrgMembership"> | string;
    role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole;
    createdAt?: DateTimeFilter<"OrgMembership"> | Date | string;
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type OrgMembershipOrderByWithRelationInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    org?: OrganizationOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: OrgMembershipOrderByRelevanceInput;
  };

  export type OrgMembershipWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      orgId_userId?: OrgMembershipOrgIdUserIdCompoundUniqueInput;
      AND?: OrgMembershipWhereInput | OrgMembershipWhereInput[];
      OR?: OrgMembershipWhereInput[];
      NOT?: OrgMembershipWhereInput | OrgMembershipWhereInput[];
      orgId?: StringFilter<"OrgMembership"> | string;
      userId?: StringFilter<"OrgMembership"> | string;
      role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole;
      createdAt?: DateTimeFilter<"OrgMembership"> | Date | string;
      org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "orgId_userId"
  >;

  export type OrgMembershipOrderByWithAggregationInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
    _count?: OrgMembershipCountOrderByAggregateInput;
    _max?: OrgMembershipMaxOrderByAggregateInput;
    _min?: OrgMembershipMinOrderByAggregateInput;
  };

  export type OrgMembershipScalarWhereWithAggregatesInput = {
    AND?:
      | OrgMembershipScalarWhereWithAggregatesInput
      | OrgMembershipScalarWhereWithAggregatesInput[];
    OR?: OrgMembershipScalarWhereWithAggregatesInput[];
    NOT?:
      | OrgMembershipScalarWhereWithAggregatesInput
      | OrgMembershipScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"OrgMembership"> | string;
    orgId?: StringWithAggregatesFilter<"OrgMembership"> | string;
    userId?: StringWithAggregatesFilter<"OrgMembership"> | string;
    role?: EnumOrgRoleWithAggregatesFilter<"OrgMembership"> | $Enums.OrgRole;
    createdAt?: DateTimeWithAggregatesFilter<"OrgMembership"> | Date | string;
  };

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[];
    OR?: EventWhereInput[];
    NOT?: EventWhereInput | EventWhereInput[];
    id?: StringFilter<"Event"> | string;
    orgId?: StringFilter<"Event"> | string;
    name?: StringFilter<"Event"> | string;
    slug?: StringFilter<"Event"> | string;
    type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus;
    heroTitle?: StringFilter<"Event"> | string;
    heroSubtitle?: StringNullableFilter<"Event"> | string | null;
    rulesRich?: JsonNullableFilter<"Event">;
    rubricRich?: JsonNullableFilter<"Event">;
    startAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    endAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    submitDueAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    requireImages?: BoolFilter<"Event"> | boolean;
    requireVideoDemo?: BoolFilter<"Event"> | boolean;
    visibility?: EnumEventVisibilityFilter<"Event"> | $Enums.EventVisibility;
    joinMode?: EnumEventJoinModeFilter<"Event"> | $Enums.EventJoinMode;
    registrationOpensAt?:
      | DateTimeNullableFilter<"Event">
      | Date
      | string
      | null;
    registrationClosesAt?:
      | DateTimeNullableFilter<"Event">
      | Date
      | string
      | null;
    maxTeamSize?: IntFilter<"Event"> | number;
    lockTeamChangesAtStart?: BoolFilter<"Event"> | boolean;
    allowSelfJoinRequests?: BoolFilter<"Event"> | boolean;
    createdAt?: DateTimeFilter<"Event"> | Date | string;
    updatedAt?: DateTimeFilter<"Event"> | Date | string;
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
    submissionSchema?: XOR<
      SubmissionSchemaNullableScalarRelationFilter,
      SubmissionSchemaWhereInput
    > | null;
    participants?: EventParticipantListRelationFilter;
    teams?: TeamListRelationFilter;
    teamInvites?: TeamInviteListRelationFilter;
    joinRequests?: TeamJoinRequestListRelationFilter;
    teamAuditLogs?: TeamAuditLogListRelationFilter;
    submissions?: SubmissionListRelationFilter;
    announcements?: AnnouncementListRelationFilter;
    judgeAssignments?: JudgeAssignmentListRelationFilter;
    registrationRequests?: EventRegistrationRequestListRelationFilter;
  };

  export type EventOrderByWithRelationInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    heroTitle?: SortOrder;
    heroSubtitle?: SortOrderInput | SortOrder;
    rulesRich?: SortOrderInput | SortOrder;
    rubricRich?: SortOrderInput | SortOrder;
    startAt?: SortOrderInput | SortOrder;
    endAt?: SortOrderInput | SortOrder;
    submitDueAt?: SortOrderInput | SortOrder;
    requireImages?: SortOrder;
    requireVideoDemo?: SortOrder;
    visibility?: SortOrder;
    joinMode?: SortOrder;
    registrationOpensAt?: SortOrderInput | SortOrder;
    registrationClosesAt?: SortOrderInput | SortOrder;
    maxTeamSize?: SortOrder;
    lockTeamChangesAtStart?: SortOrder;
    allowSelfJoinRequests?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    org?: OrganizationOrderByWithRelationInput;
    submissionSchema?: SubmissionSchemaOrderByWithRelationInput;
    participants?: EventParticipantOrderByRelationAggregateInput;
    teams?: TeamOrderByRelationAggregateInput;
    teamInvites?: TeamInviteOrderByRelationAggregateInput;
    joinRequests?: TeamJoinRequestOrderByRelationAggregateInput;
    teamAuditLogs?: TeamAuditLogOrderByRelationAggregateInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
    announcements?: AnnouncementOrderByRelationAggregateInput;
    judgeAssignments?: JudgeAssignmentOrderByRelationAggregateInput;
    registrationRequests?: EventRegistrationRequestOrderByRelationAggregateInput;
    _relevance?: EventOrderByRelevanceInput;
  };

  export type EventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      orgId_slug?: EventOrgIdSlugCompoundUniqueInput;
      AND?: EventWhereInput | EventWhereInput[];
      OR?: EventWhereInput[];
      NOT?: EventWhereInput | EventWhereInput[];
      orgId?: StringFilter<"Event"> | string;
      name?: StringFilter<"Event"> | string;
      slug?: StringFilter<"Event"> | string;
      type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
      status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus;
      heroTitle?: StringFilter<"Event"> | string;
      heroSubtitle?: StringNullableFilter<"Event"> | string | null;
      rulesRich?: JsonNullableFilter<"Event">;
      rubricRich?: JsonNullableFilter<"Event">;
      startAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
      endAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
      submitDueAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
      requireImages?: BoolFilter<"Event"> | boolean;
      requireVideoDemo?: BoolFilter<"Event"> | boolean;
      visibility?: EnumEventVisibilityFilter<"Event"> | $Enums.EventVisibility;
      joinMode?: EnumEventJoinModeFilter<"Event"> | $Enums.EventJoinMode;
      registrationOpensAt?:
        | DateTimeNullableFilter<"Event">
        | Date
        | string
        | null;
      registrationClosesAt?:
        | DateTimeNullableFilter<"Event">
        | Date
        | string
        | null;
      maxTeamSize?: IntFilter<"Event"> | number;
      lockTeamChangesAtStart?: BoolFilter<"Event"> | boolean;
      allowSelfJoinRequests?: BoolFilter<"Event"> | boolean;
      createdAt?: DateTimeFilter<"Event"> | Date | string;
      updatedAt?: DateTimeFilter<"Event"> | Date | string;
      org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>;
      submissionSchema?: XOR<
        SubmissionSchemaNullableScalarRelationFilter,
        SubmissionSchemaWhereInput
      > | null;
      participants?: EventParticipantListRelationFilter;
      teams?: TeamListRelationFilter;
      teamInvites?: TeamInviteListRelationFilter;
      joinRequests?: TeamJoinRequestListRelationFilter;
      teamAuditLogs?: TeamAuditLogListRelationFilter;
      submissions?: SubmissionListRelationFilter;
      announcements?: AnnouncementListRelationFilter;
      judgeAssignments?: JudgeAssignmentListRelationFilter;
      registrationRequests?: EventRegistrationRequestListRelationFilter;
    },
    "id" | "orgId_slug"
  >;

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    heroTitle?: SortOrder;
    heroSubtitle?: SortOrderInput | SortOrder;
    rulesRich?: SortOrderInput | SortOrder;
    rubricRich?: SortOrderInput | SortOrder;
    startAt?: SortOrderInput | SortOrder;
    endAt?: SortOrderInput | SortOrder;
    submitDueAt?: SortOrderInput | SortOrder;
    requireImages?: SortOrder;
    requireVideoDemo?: SortOrder;
    visibility?: SortOrder;
    joinMode?: SortOrder;
    registrationOpensAt?: SortOrderInput | SortOrder;
    registrationClosesAt?: SortOrderInput | SortOrder;
    maxTeamSize?: SortOrder;
    lockTeamChangesAtStart?: SortOrder;
    allowSelfJoinRequests?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: EventCountOrderByAggregateInput;
    _avg?: EventAvgOrderByAggregateInput;
    _max?: EventMaxOrderByAggregateInput;
    _min?: EventMinOrderByAggregateInput;
    _sum?: EventSumOrderByAggregateInput;
  };

  export type EventScalarWhereWithAggregatesInput = {
    AND?:
      | EventScalarWhereWithAggregatesInput
      | EventScalarWhereWithAggregatesInput[];
    OR?: EventScalarWhereWithAggregatesInput[];
    NOT?:
      | EventScalarWhereWithAggregatesInput
      | EventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Event"> | string;
    orgId?: StringWithAggregatesFilter<"Event"> | string;
    name?: StringWithAggregatesFilter<"Event"> | string;
    slug?: StringWithAggregatesFilter<"Event"> | string;
    type?: EnumEventTypeWithAggregatesFilter<"Event"> | $Enums.EventType;
    status?: EnumEventStatusWithAggregatesFilter<"Event"> | $Enums.EventStatus;
    heroTitle?: StringWithAggregatesFilter<"Event"> | string;
    heroSubtitle?: StringNullableWithAggregatesFilter<"Event"> | string | null;
    rulesRich?: JsonNullableWithAggregatesFilter<"Event">;
    rubricRich?: JsonNullableWithAggregatesFilter<"Event">;
    startAt?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    endAt?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    submitDueAt?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    requireImages?: BoolWithAggregatesFilter<"Event"> | boolean;
    requireVideoDemo?: BoolWithAggregatesFilter<"Event"> | boolean;
    visibility?:
      | EnumEventVisibilityWithAggregatesFilter<"Event">
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeWithAggregatesFilter<"Event">
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    registrationClosesAt?:
      | DateTimeNullableWithAggregatesFilter<"Event">
      | Date
      | string
      | null;
    maxTeamSize?: IntWithAggregatesFilter<"Event"> | number;
    lockTeamChangesAtStart?: BoolWithAggregatesFilter<"Event"> | boolean;
    allowSelfJoinRequests?: BoolWithAggregatesFilter<"Event"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string;
  };

  export type EventRegistrationRequestWhereInput = {
    AND?:
      | EventRegistrationRequestWhereInput
      | EventRegistrationRequestWhereInput[];
    OR?: EventRegistrationRequestWhereInput[];
    NOT?:
      | EventRegistrationRequestWhereInput
      | EventRegistrationRequestWhereInput[];
    id?: StringFilter<"EventRegistrationRequest"> | string;
    eventId?: StringFilter<"EventRegistrationRequest"> | string;
    userId?: StringFilter<"EventRegistrationRequest"> | string;
    message?: StringNullableFilter<"EventRegistrationRequest"> | string | null;
    status?:
      | EnumRegistrationRequestStatusFilter<"EventRegistrationRequest">
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFilter<"EventRegistrationRequest"> | Date | string;
    reviewedAt?:
      | DateTimeNullableFilter<"EventRegistrationRequest">
      | Date
      | string
      | null;
    reviewedByUserId?:
      | StringNullableFilter<"EventRegistrationRequest">
      | string
      | null;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type EventRegistrationRequestOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    reviewedAt?: SortOrderInput | SortOrder;
    reviewedByUserId?: SortOrderInput | SortOrder;
    event?: EventOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: EventRegistrationRequestOrderByRelevanceInput;
  };

  export type EventRegistrationRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      eventId_userId?: EventRegistrationRequestEventIdUserIdCompoundUniqueInput;
      AND?:
        | EventRegistrationRequestWhereInput
        | EventRegistrationRequestWhereInput[];
      OR?: EventRegistrationRequestWhereInput[];
      NOT?:
        | EventRegistrationRequestWhereInput
        | EventRegistrationRequestWhereInput[];
      eventId?: StringFilter<"EventRegistrationRequest"> | string;
      userId?: StringFilter<"EventRegistrationRequest"> | string;
      message?:
        | StringNullableFilter<"EventRegistrationRequest">
        | string
        | null;
      status?:
        | EnumRegistrationRequestStatusFilter<"EventRegistrationRequest">
        | $Enums.RegistrationRequestStatus;
      createdAt?: DateTimeFilter<"EventRegistrationRequest"> | Date | string;
      reviewedAt?:
        | DateTimeNullableFilter<"EventRegistrationRequest">
        | Date
        | string
        | null;
      reviewedByUserId?:
        | StringNullableFilter<"EventRegistrationRequest">
        | string
        | null;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "eventId_userId"
  >;

  export type EventRegistrationRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    reviewedAt?: SortOrderInput | SortOrder;
    reviewedByUserId?: SortOrderInput | SortOrder;
    _count?: EventRegistrationRequestCountOrderByAggregateInput;
    _max?: EventRegistrationRequestMaxOrderByAggregateInput;
    _min?: EventRegistrationRequestMinOrderByAggregateInput;
  };

  export type EventRegistrationRequestScalarWhereWithAggregatesInput = {
    AND?:
      | EventRegistrationRequestScalarWhereWithAggregatesInput
      | EventRegistrationRequestScalarWhereWithAggregatesInput[];
    OR?: EventRegistrationRequestScalarWhereWithAggregatesInput[];
    NOT?:
      | EventRegistrationRequestScalarWhereWithAggregatesInput
      | EventRegistrationRequestScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"EventRegistrationRequest"> | string;
    eventId?: StringWithAggregatesFilter<"EventRegistrationRequest"> | string;
    userId?: StringWithAggregatesFilter<"EventRegistrationRequest"> | string;
    message?:
      | StringNullableWithAggregatesFilter<"EventRegistrationRequest">
      | string
      | null;
    status?:
      | EnumRegistrationRequestStatusWithAggregatesFilter<"EventRegistrationRequest">
      | $Enums.RegistrationRequestStatus;
    createdAt?:
      | DateTimeWithAggregatesFilter<"EventRegistrationRequest">
      | Date
      | string;
    reviewedAt?:
      | DateTimeNullableWithAggregatesFilter<"EventRegistrationRequest">
      | Date
      | string
      | null;
    reviewedByUserId?:
      | StringNullableWithAggregatesFilter<"EventRegistrationRequest">
      | string
      | null;
  };

  export type EventParticipantWhereInput = {
    AND?: EventParticipantWhereInput | EventParticipantWhereInput[];
    OR?: EventParticipantWhereInput[];
    NOT?: EventParticipantWhereInput | EventParticipantWhereInput[];
    id?: StringFilter<"EventParticipant"> | string;
    eventId?: StringFilter<"EventParticipant"> | string;
    userId?: StringFilter<"EventParticipant"> | string;
    status?:
      | EnumParticipantStatusFilter<"EventParticipant">
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFilter<"EventParticipant"> | boolean;
    contactEmail?: StringNullableFilter<"EventParticipant"> | string | null;
    lookingForTeam?: BoolFilter<"EventParticipant"> | boolean;
    trackPreference?: StringNullableFilter<"EventParticipant"> | string | null;
    skills?: JsonNullableFilter<"EventParticipant">;
    interests?: JsonNullableFilter<"EventParticipant">;
    experienceLevel?: StringNullableFilter<"EventParticipant"> | string | null;
    createdAt?: DateTimeFilter<"EventParticipant"> | Date | string;
    updatedAt?: DateTimeFilter<"EventParticipant"> | Date | string;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type EventParticipantOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    newsletterOptIn?: SortOrder;
    contactEmail?: SortOrderInput | SortOrder;
    lookingForTeam?: SortOrder;
    trackPreference?: SortOrderInput | SortOrder;
    skills?: SortOrderInput | SortOrder;
    interests?: SortOrderInput | SortOrder;
    experienceLevel?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    event?: EventOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: EventParticipantOrderByRelevanceInput;
  };

  export type EventParticipantWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      eventId_userId?: EventParticipantEventIdUserIdCompoundUniqueInput;
      AND?: EventParticipantWhereInput | EventParticipantWhereInput[];
      OR?: EventParticipantWhereInput[];
      NOT?: EventParticipantWhereInput | EventParticipantWhereInput[];
      eventId?: StringFilter<"EventParticipant"> | string;
      userId?: StringFilter<"EventParticipant"> | string;
      status?:
        | EnumParticipantStatusFilter<"EventParticipant">
        | $Enums.ParticipantStatus;
      newsletterOptIn?: BoolFilter<"EventParticipant"> | boolean;
      contactEmail?: StringNullableFilter<"EventParticipant"> | string | null;
      lookingForTeam?: BoolFilter<"EventParticipant"> | boolean;
      trackPreference?:
        | StringNullableFilter<"EventParticipant">
        | string
        | null;
      skills?: JsonNullableFilter<"EventParticipant">;
      interests?: JsonNullableFilter<"EventParticipant">;
      experienceLevel?:
        | StringNullableFilter<"EventParticipant">
        | string
        | null;
      createdAt?: DateTimeFilter<"EventParticipant"> | Date | string;
      updatedAt?: DateTimeFilter<"EventParticipant"> | Date | string;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "eventId_userId"
  >;

  export type EventParticipantOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    newsletterOptIn?: SortOrder;
    contactEmail?: SortOrderInput | SortOrder;
    lookingForTeam?: SortOrder;
    trackPreference?: SortOrderInput | SortOrder;
    skills?: SortOrderInput | SortOrder;
    interests?: SortOrderInput | SortOrder;
    experienceLevel?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: EventParticipantCountOrderByAggregateInput;
    _max?: EventParticipantMaxOrderByAggregateInput;
    _min?: EventParticipantMinOrderByAggregateInput;
  };

  export type EventParticipantScalarWhereWithAggregatesInput = {
    AND?:
      | EventParticipantScalarWhereWithAggregatesInput
      | EventParticipantScalarWhereWithAggregatesInput[];
    OR?: EventParticipantScalarWhereWithAggregatesInput[];
    NOT?:
      | EventParticipantScalarWhereWithAggregatesInput
      | EventParticipantScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"EventParticipant"> | string;
    eventId?: StringWithAggregatesFilter<"EventParticipant"> | string;
    userId?: StringWithAggregatesFilter<"EventParticipant"> | string;
    status?:
      | EnumParticipantStatusWithAggregatesFilter<"EventParticipant">
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolWithAggregatesFilter<"EventParticipant"> | boolean;
    contactEmail?:
      | StringNullableWithAggregatesFilter<"EventParticipant">
      | string
      | null;
    lookingForTeam?: BoolWithAggregatesFilter<"EventParticipant"> | boolean;
    trackPreference?:
      | StringNullableWithAggregatesFilter<"EventParticipant">
      | string
      | null;
    skills?: JsonNullableWithAggregatesFilter<"EventParticipant">;
    interests?: JsonNullableWithAggregatesFilter<"EventParticipant">;
    experienceLevel?:
      | StringNullableWithAggregatesFilter<"EventParticipant">
      | string
      | null;
    createdAt?:
      | DateTimeWithAggregatesFilter<"EventParticipant">
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<"EventParticipant">
      | Date
      | string;
  };

  export type SubmissionSchemaWhereInput = {
    AND?: SubmissionSchemaWhereInput | SubmissionSchemaWhereInput[];
    OR?: SubmissionSchemaWhereInput[];
    NOT?: SubmissionSchemaWhereInput | SubmissionSchemaWhereInput[];
    id?: StringFilter<"SubmissionSchema"> | string;
    eventId?: StringFilter<"SubmissionSchema"> | string;
    fields?: JsonFilter<"SubmissionSchema">;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
  };

  export type SubmissionSchemaOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    fields?: SortOrder;
    event?: EventOrderByWithRelationInput;
    _relevance?: SubmissionSchemaOrderByRelevanceInput;
  };

  export type SubmissionSchemaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      eventId?: string;
      AND?: SubmissionSchemaWhereInput | SubmissionSchemaWhereInput[];
      OR?: SubmissionSchemaWhereInput[];
      NOT?: SubmissionSchemaWhereInput | SubmissionSchemaWhereInput[];
      fields?: JsonFilter<"SubmissionSchema">;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    },
    "id" | "eventId"
  >;

  export type SubmissionSchemaOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    fields?: SortOrder;
    _count?: SubmissionSchemaCountOrderByAggregateInput;
    _max?: SubmissionSchemaMaxOrderByAggregateInput;
    _min?: SubmissionSchemaMinOrderByAggregateInput;
  };

  export type SubmissionSchemaScalarWhereWithAggregatesInput = {
    AND?:
      | SubmissionSchemaScalarWhereWithAggregatesInput
      | SubmissionSchemaScalarWhereWithAggregatesInput[];
    OR?: SubmissionSchemaScalarWhereWithAggregatesInput[];
    NOT?:
      | SubmissionSchemaScalarWhereWithAggregatesInput
      | SubmissionSchemaScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"SubmissionSchema"> | string;
    eventId?: StringWithAggregatesFilter<"SubmissionSchema"> | string;
    fields?: JsonWithAggregatesFilter<"SubmissionSchema">;
  };

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[];
    OR?: TeamWhereInput[];
    NOT?: TeamWhereInput | TeamWhereInput[];
    id?: StringFilter<"Team"> | string;
    eventId?: StringFilter<"Team"> | string;
    name?: StringFilter<"Team"> | string;
    blurb?: StringNullableFilter<"Team"> | string | null;
    track?: StringNullableFilter<"Team"> | string | null;
    lookingForMembers?: BoolFilter<"Team"> | boolean;
    createdAt?: DateTimeFilter<"Team"> | Date | string;
    updatedAt?: DateTimeFilter<"Team"> | Date | string;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    auditLogs?: TeamAuditLogListRelationFilter;
    members?: TeamMemberListRelationFilter;
    invites?: TeamInviteListRelationFilter;
    joinRequests?: TeamJoinRequestListRelationFilter;
    submissions?: SubmissionListRelationFilter;
  };

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    blurb?: SortOrderInput | SortOrder;
    track?: SortOrderInput | SortOrder;
    lookingForMembers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    event?: EventOrderByWithRelationInput;
    auditLogs?: TeamAuditLogOrderByRelationAggregateInput;
    members?: TeamMemberOrderByRelationAggregateInput;
    invites?: TeamInviteOrderByRelationAggregateInput;
    joinRequests?: TeamJoinRequestOrderByRelationAggregateInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
    _relevance?: TeamOrderByRelevanceInput;
  };

  export type TeamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TeamWhereInput | TeamWhereInput[];
      OR?: TeamWhereInput[];
      NOT?: TeamWhereInput | TeamWhereInput[];
      eventId?: StringFilter<"Team"> | string;
      name?: StringFilter<"Team"> | string;
      blurb?: StringNullableFilter<"Team"> | string | null;
      track?: StringNullableFilter<"Team"> | string | null;
      lookingForMembers?: BoolFilter<"Team"> | boolean;
      createdAt?: DateTimeFilter<"Team"> | Date | string;
      updatedAt?: DateTimeFilter<"Team"> | Date | string;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      auditLogs?: TeamAuditLogListRelationFilter;
      members?: TeamMemberListRelationFilter;
      invites?: TeamInviteListRelationFilter;
      joinRequests?: TeamJoinRequestListRelationFilter;
      submissions?: SubmissionListRelationFilter;
    },
    "id"
  >;

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    blurb?: SortOrderInput | SortOrder;
    track?: SortOrderInput | SortOrder;
    lookingForMembers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TeamCountOrderByAggregateInput;
    _max?: TeamMaxOrderByAggregateInput;
    _min?: TeamMinOrderByAggregateInput;
  };

  export type TeamScalarWhereWithAggregatesInput = {
    AND?:
      | TeamScalarWhereWithAggregatesInput
      | TeamScalarWhereWithAggregatesInput[];
    OR?: TeamScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamScalarWhereWithAggregatesInput
      | TeamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Team"> | string;
    eventId?: StringWithAggregatesFilter<"Team"> | string;
    name?: StringWithAggregatesFilter<"Team"> | string;
    blurb?: StringNullableWithAggregatesFilter<"Team"> | string | null;
    track?: StringNullableWithAggregatesFilter<"Team"> | string | null;
    lookingForMembers?: BoolWithAggregatesFilter<"Team"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string;
  };

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
    OR?: TeamMemberWhereInput[];
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
    id?: StringFilter<"TeamMember"> | string;
    eventId?: StringFilter<"TeamMember"> | string;
    teamId?: StringFilter<"TeamMember"> | string;
    userId?: StringFilter<"TeamMember"> | string;
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole;
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    team?: TeamOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: TeamMemberOrderByRelevanceInput;
  };

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput;
      eventId_userId?: TeamMemberEventIdUserIdCompoundUniqueInput;
      AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
      OR?: TeamMemberWhereInput[];
      NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
      eventId?: StringFilter<"TeamMember"> | string;
      teamId?: StringFilter<"TeamMember"> | string;
      userId?: StringFilter<"TeamMember"> | string;
      role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "teamId_userId" | "eventId_userId"
  >;

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    _count?: TeamMemberCountOrderByAggregateInput;
    _max?: TeamMemberMaxOrderByAggregateInput;
    _min?: TeamMemberMinOrderByAggregateInput;
  };

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?:
      | TeamMemberScalarWhereWithAggregatesInput
      | TeamMemberScalarWhereWithAggregatesInput[];
    OR?: TeamMemberScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamMemberScalarWhereWithAggregatesInput
      | TeamMemberScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TeamMember"> | string;
    eventId?: StringWithAggregatesFilter<"TeamMember"> | string;
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string;
    userId?: StringWithAggregatesFilter<"TeamMember"> | string;
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole;
  };

  export type TeamInviteWhereInput = {
    AND?: TeamInviteWhereInput | TeamInviteWhereInput[];
    OR?: TeamInviteWhereInput[];
    NOT?: TeamInviteWhereInput | TeamInviteWhereInput[];
    id?: StringFilter<"TeamInvite"> | string;
    eventId?: StringFilter<"TeamInvite"> | string;
    teamId?: StringFilter<"TeamInvite"> | string;
    email?: StringFilter<"TeamInvite"> | string;
    token?: StringFilter<"TeamInvite"> | string;
    status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus;
    message?: StringNullableFilter<"TeamInvite"> | string | null;
    createdByUserId?: StringFilter<"TeamInvite"> | string;
    createdAt?: DateTimeFilter<"TeamInvite"> | Date | string;
    expiresAt?: DateTimeNullableFilter<"TeamInvite"> | Date | string | null;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TeamInviteOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    email?: SortOrder;
    token?: SortOrder;
    status?: SortOrder;
    message?: SortOrderInput | SortOrder;
    createdByUserId?: SortOrder;
    createdAt?: SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    event?: EventOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
    creator?: UserOrderByWithRelationInput;
    _relevance?: TeamInviteOrderByRelevanceInput;
  };

  export type TeamInviteWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: TeamInviteWhereInput | TeamInviteWhereInput[];
      OR?: TeamInviteWhereInput[];
      NOT?: TeamInviteWhereInput | TeamInviteWhereInput[];
      eventId?: StringFilter<"TeamInvite"> | string;
      teamId?: StringFilter<"TeamInvite"> | string;
      email?: StringFilter<"TeamInvite"> | string;
      status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus;
      message?: StringNullableFilter<"TeamInvite"> | string | null;
      createdByUserId?: StringFilter<"TeamInvite"> | string;
      createdAt?: DateTimeFilter<"TeamInvite"> | Date | string;
      expiresAt?: DateTimeNullableFilter<"TeamInvite"> | Date | string | null;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      creator?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "token"
  >;

  export type TeamInviteOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    email?: SortOrder;
    token?: SortOrder;
    status?: SortOrder;
    message?: SortOrderInput | SortOrder;
    createdByUserId?: SortOrder;
    createdAt?: SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    _count?: TeamInviteCountOrderByAggregateInput;
    _max?: TeamInviteMaxOrderByAggregateInput;
    _min?: TeamInviteMinOrderByAggregateInput;
  };

  export type TeamInviteScalarWhereWithAggregatesInput = {
    AND?:
      | TeamInviteScalarWhereWithAggregatesInput
      | TeamInviteScalarWhereWithAggregatesInput[];
    OR?: TeamInviteScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamInviteScalarWhereWithAggregatesInput
      | TeamInviteScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TeamInvite"> | string;
    eventId?: StringWithAggregatesFilter<"TeamInvite"> | string;
    teamId?: StringWithAggregatesFilter<"TeamInvite"> | string;
    email?: StringWithAggregatesFilter<"TeamInvite"> | string;
    token?: StringWithAggregatesFilter<"TeamInvite"> | string;
    status?:
      | EnumInviteStatusWithAggregatesFilter<"TeamInvite">
      | $Enums.InviteStatus;
    message?: StringNullableWithAggregatesFilter<"TeamInvite"> | string | null;
    createdByUserId?: StringWithAggregatesFilter<"TeamInvite"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"TeamInvite"> | Date | string;
    expiresAt?:
      | DateTimeNullableWithAggregatesFilter<"TeamInvite">
      | Date
      | string
      | null;
  };

  export type TeamJoinRequestWhereInput = {
    AND?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[];
    OR?: TeamJoinRequestWhereInput[];
    NOT?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[];
    id?: StringFilter<"TeamJoinRequest"> | string;
    eventId?: StringFilter<"TeamJoinRequest"> | string;
    teamId?: StringFilter<"TeamJoinRequest"> | string;
    userId?: StringFilter<"TeamJoinRequest"> | string;
    message?: StringNullableFilter<"TeamJoinRequest"> | string | null;
    status?:
      | EnumJoinRequestStatusFilter<"TeamJoinRequest">
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
    updatedAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type TeamJoinRequestOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    event?: EventOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: TeamJoinRequestOrderByRelevanceInput;
  };

  export type TeamJoinRequestWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      teamId_userId?: TeamJoinRequestTeamIdUserIdCompoundUniqueInput;
      AND?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[];
      OR?: TeamJoinRequestWhereInput[];
      NOT?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[];
      eventId?: StringFilter<"TeamJoinRequest"> | string;
      teamId?: StringFilter<"TeamJoinRequest"> | string;
      userId?: StringFilter<"TeamJoinRequest"> | string;
      message?: StringNullableFilter<"TeamJoinRequest"> | string | null;
      status?:
        | EnumJoinRequestStatusFilter<"TeamJoinRequest">
        | $Enums.JoinRequestStatus;
      createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
      updatedAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "teamId_userId"
  >;

  export type TeamJoinRequestOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrderInput | SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TeamJoinRequestCountOrderByAggregateInput;
    _max?: TeamJoinRequestMaxOrderByAggregateInput;
    _min?: TeamJoinRequestMinOrderByAggregateInput;
  };

  export type TeamJoinRequestScalarWhereWithAggregatesInput = {
    AND?:
      | TeamJoinRequestScalarWhereWithAggregatesInput
      | TeamJoinRequestScalarWhereWithAggregatesInput[];
    OR?: TeamJoinRequestScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamJoinRequestScalarWhereWithAggregatesInput
      | TeamJoinRequestScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TeamJoinRequest"> | string;
    eventId?: StringWithAggregatesFilter<"TeamJoinRequest"> | string;
    teamId?: StringWithAggregatesFilter<"TeamJoinRequest"> | string;
    userId?: StringWithAggregatesFilter<"TeamJoinRequest"> | string;
    message?:
      | StringNullableWithAggregatesFilter<"TeamJoinRequest">
      | string
      | null;
    status?:
      | EnumJoinRequestStatusWithAggregatesFilter<"TeamJoinRequest">
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeWithAggregatesFilter<"TeamJoinRequest"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"TeamJoinRequest"> | Date | string;
  };

  export type TeamAuditLogWhereInput = {
    AND?: TeamAuditLogWhereInput | TeamAuditLogWhereInput[];
    OR?: TeamAuditLogWhereInput[];
    NOT?: TeamAuditLogWhereInput | TeamAuditLogWhereInput[];
    id?: StringFilter<"TeamAuditLog"> | string;
    eventId?: StringFilter<"TeamAuditLog"> | string;
    teamId?: StringFilter<"TeamAuditLog"> | string;
    actorId?: StringNullableFilter<"TeamAuditLog"> | string | null;
    targetUserId?: StringNullableFilter<"TeamAuditLog"> | string | null;
    action?: EnumTeamAuditActionFilter<"TeamAuditLog"> | $Enums.TeamAuditAction;
    meta?: JsonNullableFilter<"TeamAuditLog">;
    createdAt?: DateTimeFilter<"TeamAuditLog"> | Date | string;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    targetUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type TeamAuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    targetUserId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    meta?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    event?: EventOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
    actor?: UserOrderByWithRelationInput;
    targetUser?: UserOrderByWithRelationInput;
    _relevance?: TeamAuditLogOrderByRelevanceInput;
  };

  export type TeamAuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TeamAuditLogWhereInput | TeamAuditLogWhereInput[];
      OR?: TeamAuditLogWhereInput[];
      NOT?: TeamAuditLogWhereInput | TeamAuditLogWhereInput[];
      eventId?: StringFilter<"TeamAuditLog"> | string;
      teamId?: StringFilter<"TeamAuditLog"> | string;
      actorId?: StringNullableFilter<"TeamAuditLog"> | string | null;
      targetUserId?: StringNullableFilter<"TeamAuditLog"> | string | null;
      action?:
        | EnumTeamAuditActionFilter<"TeamAuditLog">
        | $Enums.TeamAuditAction;
      meta?: JsonNullableFilter<"TeamAuditLog">;
      createdAt?: DateTimeFilter<"TeamAuditLog"> | Date | string;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      targetUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    "id"
  >;

  export type TeamAuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    targetUserId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    meta?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: TeamAuditLogCountOrderByAggregateInput;
    _max?: TeamAuditLogMaxOrderByAggregateInput;
    _min?: TeamAuditLogMinOrderByAggregateInput;
  };

  export type TeamAuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | TeamAuditLogScalarWhereWithAggregatesInput
      | TeamAuditLogScalarWhereWithAggregatesInput[];
    OR?: TeamAuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | TeamAuditLogScalarWhereWithAggregatesInput
      | TeamAuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"TeamAuditLog"> | string;
    eventId?: StringWithAggregatesFilter<"TeamAuditLog"> | string;
    teamId?: StringWithAggregatesFilter<"TeamAuditLog"> | string;
    actorId?:
      | StringNullableWithAggregatesFilter<"TeamAuditLog">
      | string
      | null;
    targetUserId?:
      | StringNullableWithAggregatesFilter<"TeamAuditLog">
      | string
      | null;
    action?:
      | EnumTeamAuditActionWithAggregatesFilter<"TeamAuditLog">
      | $Enums.TeamAuditAction;
    meta?: JsonNullableWithAggregatesFilter<"TeamAuditLog">;
    createdAt?: DateTimeWithAggregatesFilter<"TeamAuditLog"> | Date | string;
  };

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[];
    OR?: SubmissionWhereInput[];
    NOT?: SubmissionWhereInput | SubmissionWhereInput[];
    id?: StringFilter<"Submission"> | string;
    eventId?: StringFilter<"Submission"> | string;
    teamId?: StringNullableFilter<"Submission"> | string | null;
    authorId?: StringNullableFilter<"Submission"> | string | null;
    status?: EnumSubmissionStatusFilter<"Submission"> | $Enums.SubmissionStatus;
    title?: StringFilter<"Submission"> | string;
    description?: StringNullableFilter<"Submission"> | string | null;
    content?: JsonNullableFilter<"Submission">;
    imageUrls?: JsonNullableFilter<"Submission">;
    videoUrl?: StringNullableFilter<"Submission"> | string | null;
    createdAt?: DateTimeFilter<"Submission"> | Date | string;
    updatedAt?: DateTimeFilter<"Submission"> | Date | string;
    submittedAt?: DateTimeNullableFilter<"Submission"> | Date | string | null;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null;
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    scores?: ScoreListRelationFilter;
  };

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrderInput | SortOrder;
    authorId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    content?: SortOrderInput | SortOrder;
    imageUrls?: SortOrderInput | SortOrder;
    videoUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submittedAt?: SortOrderInput | SortOrder;
    event?: EventOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
    author?: UserOrderByWithRelationInput;
    scores?: ScoreOrderByRelationAggregateInput;
    _relevance?: SubmissionOrderByRelevanceInput;
  };

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SubmissionWhereInput | SubmissionWhereInput[];
      OR?: SubmissionWhereInput[];
      NOT?: SubmissionWhereInput | SubmissionWhereInput[];
      eventId?: StringFilter<"Submission"> | string;
      teamId?: StringNullableFilter<"Submission"> | string | null;
      authorId?: StringNullableFilter<"Submission"> | string | null;
      status?:
        | EnumSubmissionStatusFilter<"Submission">
        | $Enums.SubmissionStatus;
      title?: StringFilter<"Submission"> | string;
      description?: StringNullableFilter<"Submission"> | string | null;
      content?: JsonNullableFilter<"Submission">;
      imageUrls?: JsonNullableFilter<"Submission">;
      videoUrl?: StringNullableFilter<"Submission"> | string | null;
      createdAt?: DateTimeFilter<"Submission"> | Date | string;
      updatedAt?: DateTimeFilter<"Submission"> | Date | string;
      submittedAt?: DateTimeNullableFilter<"Submission"> | Date | string | null;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null;
      author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      scores?: ScoreListRelationFilter;
    },
    "id"
  >;

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrderInput | SortOrder;
    authorId?: SortOrderInput | SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    content?: SortOrderInput | SortOrder;
    imageUrls?: SortOrderInput | SortOrder;
    videoUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submittedAt?: SortOrderInput | SortOrder;
    _count?: SubmissionCountOrderByAggregateInput;
    _max?: SubmissionMaxOrderByAggregateInput;
    _min?: SubmissionMinOrderByAggregateInput;
  };

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?:
      | SubmissionScalarWhereWithAggregatesInput
      | SubmissionScalarWhereWithAggregatesInput[];
    OR?: SubmissionScalarWhereWithAggregatesInput[];
    NOT?:
      | SubmissionScalarWhereWithAggregatesInput
      | SubmissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Submission"> | string;
    eventId?: StringWithAggregatesFilter<"Submission"> | string;
    teamId?: StringNullableWithAggregatesFilter<"Submission"> | string | null;
    authorId?: StringNullableWithAggregatesFilter<"Submission"> | string | null;
    status?:
      | EnumSubmissionStatusWithAggregatesFilter<"Submission">
      | $Enums.SubmissionStatus;
    title?: StringWithAggregatesFilter<"Submission"> | string;
    description?:
      | StringNullableWithAggregatesFilter<"Submission">
      | string
      | null;
    content?: JsonNullableWithAggregatesFilter<"Submission">;
    imageUrls?: JsonNullableWithAggregatesFilter<"Submission">;
    videoUrl?: StringNullableWithAggregatesFilter<"Submission"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string;
    submittedAt?:
      | DateTimeNullableWithAggregatesFilter<"Submission">
      | Date
      | string
      | null;
  };

  export type JudgeAssignmentWhereInput = {
    AND?: JudgeAssignmentWhereInput | JudgeAssignmentWhereInput[];
    OR?: JudgeAssignmentWhereInput[];
    NOT?: JudgeAssignmentWhereInput | JudgeAssignmentWhereInput[];
    id?: StringFilter<"JudgeAssignment"> | string;
    eventId?: StringFilter<"JudgeAssignment"> | string;
    userId?: StringFilter<"JudgeAssignment"> | string;
    role?: EnumJudgeRoleFilter<"JudgeAssignment"> | $Enums.JudgeRole;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type JudgeAssignmentOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    event?: EventOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    _relevance?: JudgeAssignmentOrderByRelevanceInput;
  };

  export type JudgeAssignmentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      eventId_userId?: JudgeAssignmentEventIdUserIdCompoundUniqueInput;
      AND?: JudgeAssignmentWhereInput | JudgeAssignmentWhereInput[];
      OR?: JudgeAssignmentWhereInput[];
      NOT?: JudgeAssignmentWhereInput | JudgeAssignmentWhereInput[];
      eventId?: StringFilter<"JudgeAssignment"> | string;
      userId?: StringFilter<"JudgeAssignment"> | string;
      role?: EnumJudgeRoleFilter<"JudgeAssignment"> | $Enums.JudgeRole;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "eventId_userId"
  >;

  export type JudgeAssignmentOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    _count?: JudgeAssignmentCountOrderByAggregateInput;
    _max?: JudgeAssignmentMaxOrderByAggregateInput;
    _min?: JudgeAssignmentMinOrderByAggregateInput;
  };

  export type JudgeAssignmentScalarWhereWithAggregatesInput = {
    AND?:
      | JudgeAssignmentScalarWhereWithAggregatesInput
      | JudgeAssignmentScalarWhereWithAggregatesInput[];
    OR?: JudgeAssignmentScalarWhereWithAggregatesInput[];
    NOT?:
      | JudgeAssignmentScalarWhereWithAggregatesInput
      | JudgeAssignmentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"JudgeAssignment"> | string;
    eventId?: StringWithAggregatesFilter<"JudgeAssignment"> | string;
    userId?: StringWithAggregatesFilter<"JudgeAssignment"> | string;
    role?:
      | EnumJudgeRoleWithAggregatesFilter<"JudgeAssignment">
      | $Enums.JudgeRole;
  };

  export type ScoreWhereInput = {
    AND?: ScoreWhereInput | ScoreWhereInput[];
    OR?: ScoreWhereInput[];
    NOT?: ScoreWhereInput | ScoreWhereInput[];
    id?: StringFilter<"Score"> | string;
    submissionId?: StringFilter<"Score"> | string;
    judgeId?: StringFilter<"Score"> | string;
    total?: FloatNullableFilter<"Score"> | number | null;
    breakdown?: JsonNullableFilter<"Score">;
    feedback?: StringNullableFilter<"Score"> | string | null;
    createdAt?: DateTimeFilter<"Score"> | Date | string;
    updatedAt?: DateTimeFilter<"Score"> | Date | string;
    submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>;
    judge?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ScoreOrderByWithRelationInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    total?: SortOrderInput | SortOrder;
    breakdown?: SortOrderInput | SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submission?: SubmissionOrderByWithRelationInput;
    judge?: UserOrderByWithRelationInput;
    _relevance?: ScoreOrderByRelevanceInput;
  };

  export type ScoreWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      submissionId_judgeId?: ScoreSubmissionIdJudgeIdCompoundUniqueInput;
      AND?: ScoreWhereInput | ScoreWhereInput[];
      OR?: ScoreWhereInput[];
      NOT?: ScoreWhereInput | ScoreWhereInput[];
      submissionId?: StringFilter<"Score"> | string;
      judgeId?: StringFilter<"Score"> | string;
      total?: FloatNullableFilter<"Score"> | number | null;
      breakdown?: JsonNullableFilter<"Score">;
      feedback?: StringNullableFilter<"Score"> | string | null;
      createdAt?: DateTimeFilter<"Score"> | Date | string;
      updatedAt?: DateTimeFilter<"Score"> | Date | string;
      submission?: XOR<SubmissionScalarRelationFilter, SubmissionWhereInput>;
      judge?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    "id" | "submissionId_judgeId"
  >;

  export type ScoreOrderByWithAggregationInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    total?: SortOrderInput | SortOrder;
    breakdown?: SortOrderInput | SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ScoreCountOrderByAggregateInput;
    _avg?: ScoreAvgOrderByAggregateInput;
    _max?: ScoreMaxOrderByAggregateInput;
    _min?: ScoreMinOrderByAggregateInput;
    _sum?: ScoreSumOrderByAggregateInput;
  };

  export type ScoreScalarWhereWithAggregatesInput = {
    AND?:
      | ScoreScalarWhereWithAggregatesInput
      | ScoreScalarWhereWithAggregatesInput[];
    OR?: ScoreScalarWhereWithAggregatesInput[];
    NOT?:
      | ScoreScalarWhereWithAggregatesInput
      | ScoreScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Score"> | string;
    submissionId?: StringWithAggregatesFilter<"Score"> | string;
    judgeId?: StringWithAggregatesFilter<"Score"> | string;
    total?: FloatNullableWithAggregatesFilter<"Score"> | number | null;
    breakdown?: JsonNullableWithAggregatesFilter<"Score">;
    feedback?: StringNullableWithAggregatesFilter<"Score"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"Score"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Score"> | Date | string;
  };

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
    OR?: AnnouncementWhereInput[];
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
    id?: StringFilter<"Announcement"> | string;
    eventId?: StringFilter<"Announcement"> | string;
    title?: StringFilter<"Announcement"> | string;
    bodyRich?: JsonNullableFilter<"Announcement">;
    createdAt?: DateTimeFilter<"Announcement"> | Date | string;
    event?: XOR<EventScalarRelationFilter, EventWhereInput>;
  };

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    title?: SortOrder;
    bodyRich?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    event?: EventOrderByWithRelationInput;
    _relevance?: AnnouncementOrderByRelevanceInput;
  };

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
      OR?: AnnouncementWhereInput[];
      NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
      eventId?: StringFilter<"Announcement"> | string;
      title?: StringFilter<"Announcement"> | string;
      bodyRich?: JsonNullableFilter<"Announcement">;
      createdAt?: DateTimeFilter<"Announcement"> | Date | string;
      event?: XOR<EventScalarRelationFilter, EventWhereInput>;
    },
    "id"
  >;

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    title?: SortOrder;
    bodyRich?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AnnouncementCountOrderByAggregateInput;
    _max?: AnnouncementMaxOrderByAggregateInput;
    _min?: AnnouncementMinOrderByAggregateInput;
  };

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?:
      | AnnouncementScalarWhereWithAggregatesInput
      | AnnouncementScalarWhereWithAggregatesInput[];
    OR?: AnnouncementScalarWhereWithAggregatesInput[];
    NOT?:
      | AnnouncementScalarWhereWithAggregatesInput
      | AnnouncementScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Announcement"> | string;
    eventId?: StringWithAggregatesFilter<"Announcement"> | string;
    title?: StringWithAggregatesFilter<"Announcement"> | string;
    bodyRich?: JsonNullableWithAggregatesFilter<"Announcement">;
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string;
  };

  export type ContactMessageWhereInput = {
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[];
    OR?: ContactMessageWhereInput[];
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[];
    id?: StringFilter<"ContactMessage"> | string;
    firstName?: StringFilter<"ContactMessage"> | string;
    lastName?: StringFilter<"ContactMessage"> | string;
    email?: StringFilter<"ContactMessage"> | string;
    phone?: StringNullableFilter<"ContactMessage"> | string | null;
    organization?: StringNullableFilter<"ContactMessage"> | string | null;
    message?: StringFilter<"ContactMessage"> | string;
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string;
    readAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null;
  };

  export type ContactMessageOrderByWithRelationInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    organization?: SortOrderInput | SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    _relevance?: ContactMessageOrderByRelevanceInput;
  };

  export type ContactMessageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ContactMessageWhereInput | ContactMessageWhereInput[];
      OR?: ContactMessageWhereInput[];
      NOT?: ContactMessageWhereInput | ContactMessageWhereInput[];
      firstName?: StringFilter<"ContactMessage"> | string;
      lastName?: StringFilter<"ContactMessage"> | string;
      email?: StringFilter<"ContactMessage"> | string;
      phone?: StringNullableFilter<"ContactMessage"> | string | null;
      organization?: StringNullableFilter<"ContactMessage"> | string | null;
      message?: StringFilter<"ContactMessage"> | string;
      createdAt?: DateTimeFilter<"ContactMessage"> | Date | string;
      readAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null;
    },
    "id"
  >;

  export type ContactMessageOrderByWithAggregationInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    organization?: SortOrderInput | SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    _count?: ContactMessageCountOrderByAggregateInput;
    _max?: ContactMessageMaxOrderByAggregateInput;
    _min?: ContactMessageMinOrderByAggregateInput;
  };

  export type ContactMessageScalarWhereWithAggregatesInput = {
    AND?:
      | ContactMessageScalarWhereWithAggregatesInput
      | ContactMessageScalarWhereWithAggregatesInput[];
    OR?: ContactMessageScalarWhereWithAggregatesInput[];
    NOT?:
      | ContactMessageScalarWhereWithAggregatesInput
      | ContactMessageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ContactMessage"> | string;
    firstName?: StringWithAggregatesFilter<"ContactMessage"> | string;
    lastName?: StringWithAggregatesFilter<"ContactMessage"> | string;
    email?: StringWithAggregatesFilter<"ContactMessage"> | string;
    phone?:
      | StringNullableWithAggregatesFilter<"ContactMessage">
      | string
      | null;
    organization?:
      | StringNullableWithAggregatesFilter<"ContactMessage">
      | string
      | null;
    message?: StringWithAggregatesFilter<"ContactMessage"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string;
    readAt?:
      | DateTimeNullableWithAggregatesFilter<"ContactMessage">
      | Date
      | string
      | null;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrganizationCreateInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutOrgInput;
    events?: EventCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutOrgInput;
    events?: EventUncheckedCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutOrgNestedInput;
    events?: EventUpdateManyWithoutOrgNestedInput;
  };

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput;
    events?: EventUncheckedUpdateManyWithoutOrgNestedInput;
  };

  export type OrganizationCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgMembershipCreateInput = {
    id?: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutMembershipsInput;
    user: UserCreateNestedOneWithoutMembershipsInput;
  };

  export type OrgMembershipUncheckedCreateInput = {
    id?: string;
    orgId: string;
    userId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type OrgMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type OrgMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgMembershipCreateManyInput = {
    id?: string;
    orgId: string;
    userId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type OrgMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventCreateInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type EventCreateManyInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventRegistrationRequestCreateInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
    event: EventCreateNestedOneWithoutRegistrationRequestsInput;
    user: UserCreateNestedOneWithoutRegistrationRequestsInput;
  };

  export type EventRegistrationRequestUncheckedCreateInput = {
    id?: string;
    eventId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type EventRegistrationRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    event?: EventUpdateOneRequiredWithoutRegistrationRequestsNestedInput;
    user?: UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput;
  };

  export type EventRegistrationRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventRegistrationRequestCreateManyInput = {
    id?: string;
    eventId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type EventRegistrationRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventRegistrationRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventParticipantCreateInput = {
    id?: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutParticipantsInput;
    user: UserCreateNestedOneWithoutEventParticipantsInput;
  };

  export type EventParticipantUncheckedCreateInput = {
    id?: string;
    eventId: string;
    userId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput;
    user?: UserUpdateOneRequiredWithoutEventParticipantsNestedInput;
  };

  export type EventParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantCreateManyInput = {
    id?: string;
    eventId: string;
    userId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionSchemaCreateInput = {
    id?: string;
    fields: JsonNullValueInput | InputJsonValue;
    event: EventCreateNestedOneWithoutSubmissionSchemaInput;
  };

  export type SubmissionSchemaUncheckedCreateInput = {
    id?: string;
    eventId: string;
    fields: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
    event?: EventUpdateOneRequiredWithoutSubmissionSchemaNestedInput;
  };

  export type SubmissionSchemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaCreateManyInput = {
    id?: string;
    eventId: string;
    fields: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
  };

  export type TeamCreateInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamCreateManyInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateInput = {
    id?: string;
    eventId: string;
    role?: $Enums.TeamRole;
    team: TeamCreateNestedOneWithoutMembersInput;
    user: UserCreateNestedOneWithoutTeamsInput;
  };

  export type TeamMemberUncheckedCreateInput = {
    id?: string;
    eventId: string;
    teamId: string;
    userId: string;
    role?: $Enums.TeamRole;
  };

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
  };

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamMemberCreateManyInput = {
    id?: string;
    eventId: string;
    teamId: string;
    userId: string;
    role?: $Enums.TeamRole;
  };

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamInviteCreateInput = {
    id?: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
    event: EventCreateNestedOneWithoutTeamInvitesInput;
    team: TeamCreateNestedOneWithoutInvitesInput;
    creator: UserCreateNestedOneWithoutTeamInvitesCreatedInput;
  };

  export type TeamInviteUncheckedCreateInput = {
    id?: string;
    eventId: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutTeamInvitesNestedInput;
    team?: TeamUpdateOneRequiredWithoutInvitesNestedInput;
    creator?: UserUpdateOneRequiredWithoutTeamInvitesCreatedNestedInput;
  };

  export type TeamInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamInviteCreateManyInput = {
    id?: string;
    eventId: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamJoinRequestCreateInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutJoinRequestsInput;
    team: TeamCreateNestedOneWithoutJoinRequestsInput;
    user: UserCreateNestedOneWithoutTeamJoinRequestsInput;
  };

  export type TeamJoinRequestUncheckedCreateInput = {
    id?: string;
    eventId: string;
    teamId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamJoinRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutJoinRequestsNestedInput;
    team?: TeamUpdateOneRequiredWithoutJoinRequestsNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput;
  };

  export type TeamJoinRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamJoinRequestCreateManyInput = {
    id?: string;
    eventId: string;
    teamId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamJoinRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamJoinRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogCreateInput = {
    id?: string;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamAuditLogsInput;
    team: TeamCreateNestedOneWithoutAuditLogsInput;
    actor?: UserCreateNestedOneWithoutTeamAuditActorInput;
    targetUser?: UserCreateNestedOneWithoutTeamAuditTargetInput;
  };

  export type TeamAuditLogUncheckedCreateInput = {
    id?: string;
    eventId: string;
    teamId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamAuditLogsNestedInput;
    team?: TeamUpdateOneRequiredWithoutAuditLogsNestedInput;
    actor?: UserUpdateOneWithoutTeamAuditActorNestedInput;
    targetUser?: UserUpdateOneWithoutTeamAuditTargetNestedInput;
  };

  export type TeamAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogCreateManyInput = {
    id?: string;
    eventId: string;
    teamId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionCreateInput = {
    id?: string;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    event: EventCreateNestedOneWithoutSubmissionsInput;
    team?: TeamCreateNestedOneWithoutSubmissionsInput;
    author?: UserCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateInput = {
    id?: string;
    eventId: string;
    teamId?: string | null;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutSubmissionsNestedInput;
    author?: UserUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionCreateManyInput = {
    id?: string;
    eventId: string;
    teamId?: string | null;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
  };

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type JudgeAssignmentCreateInput = {
    id?: string;
    role?: $Enums.JudgeRole;
    event: EventCreateNestedOneWithoutJudgeAssignmentsInput;
    user: UserCreateNestedOneWithoutJudgeLinksInput;
  };

  export type JudgeAssignmentUncheckedCreateInput = {
    id?: string;
    eventId: string;
    userId: string;
    role?: $Enums.JudgeRole;
  };

  export type JudgeAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
    event?: EventUpdateOneRequiredWithoutJudgeAssignmentsNestedInput;
    user?: UserUpdateOneRequiredWithoutJudgeLinksNestedInput;
  };

  export type JudgeAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type JudgeAssignmentCreateManyInput = {
    id?: string;
    eventId: string;
    userId: string;
    role?: $Enums.JudgeRole;
  };

  export type JudgeAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type JudgeAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type ScoreCreateInput = {
    id?: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submission: SubmissionCreateNestedOneWithoutScoresInput;
    judge: UserCreateNestedOneWithoutScoresGivenInput;
  };

  export type ScoreUncheckedCreateInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submission?: SubmissionUpdateOneRequiredWithoutScoresNestedInput;
    judge?: UserUpdateOneRequiredWithoutScoresGivenNestedInput;
  };

  export type ScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateManyInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCreateInput = {
    id?: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    event: EventCreateNestedOneWithoutAnnouncementsInput;
  };

  export type AnnouncementUncheckedCreateInput = {
    id?: string;
    eventId: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutAnnouncementsNestedInput;
  };

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCreateManyInput = {
    id?: string;
    eventId: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ContactMessageCreateInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    organization?: string | null;
    message: string;
    createdAt?: Date | string;
    readAt?: Date | string | null;
  };

  export type ContactMessageUncheckedCreateInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    organization?: string | null;
    message: string;
    createdAt?: Date | string;
    readAt?: Date | string | null;
  };

  export type ContactMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    message?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ContactMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    message?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ContactMessageCreateManyInput = {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    phone?: string | null;
    organization?: string | null;
    message: string;
    createdAt?: Date | string;
    readAt?: Date | string | null;
  };

  export type ContactMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    message?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ContactMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    message?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type OrgMembershipListRelationFilter = {
    every?: OrgMembershipWhereInput;
    some?: OrgMembershipWhereInput;
    none?: OrgMembershipWhereInput;
  };

  export type EventParticipantListRelationFilter = {
    every?: EventParticipantWhereInput;
    some?: EventParticipantWhereInput;
    none?: EventParticipantWhereInput;
  };

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput;
    some?: TeamMemberWhereInput;
    none?: TeamMemberWhereInput;
  };

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput;
    some?: SubmissionWhereInput;
    none?: SubmissionWhereInput;
  };

  export type JudgeAssignmentListRelationFilter = {
    every?: JudgeAssignmentWhereInput;
    some?: JudgeAssignmentWhereInput;
    none?: JudgeAssignmentWhereInput;
  };

  export type TeamInviteListRelationFilter = {
    every?: TeamInviteWhereInput;
    some?: TeamInviteWhereInput;
    none?: TeamInviteWhereInput;
  };

  export type TeamJoinRequestListRelationFilter = {
    every?: TeamJoinRequestWhereInput;
    some?: TeamJoinRequestWhereInput;
    none?: TeamJoinRequestWhereInput;
  };

  export type TeamAuditLogListRelationFilter = {
    every?: TeamAuditLogWhereInput;
    some?: TeamAuditLogWhereInput;
    none?: TeamAuditLogWhereInput;
  };

  export type ScoreListRelationFilter = {
    every?: ScoreWhereInput;
    some?: ScoreWhereInput;
    none?: ScoreWhereInput;
  };

  export type EventRegistrationRequestListRelationFilter = {
    every?: EventRegistrationRequestWhereInput;
    some?: EventRegistrationRequestWhereInput;
    none?: EventRegistrationRequestWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type OrgMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EventParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type JudgeAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamInviteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamJoinRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ScoreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EventRegistrationRequestOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    imageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    imageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    imageUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EventListRelationFilter = {
    every?: EventWhereInput;
    some?: EventWhereInput;
    none?: EventWhereInput;
  };

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrganizationOrderByRelevanceInput = {
    fields:
      | OrganizationOrderByRelevanceFieldEnum
      | OrganizationOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    logoUrl?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    logoUrl?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    logoUrl?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.OrgRole[];
    notIn?: $Enums.OrgRole[];
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole;
  };

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput;
    isNot?: OrganizationWhereInput;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type OrgMembershipOrderByRelevanceInput = {
    fields:
      | OrgMembershipOrderByRelevanceFieldEnum
      | OrgMembershipOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type OrgMembershipOrgIdUserIdCompoundUniqueInput = {
    orgId: string;
    userId: string;
  };

  export type OrgMembershipCountOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrgMembershipMaxOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrgMembershipMinOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.OrgRole[];
    notIn?: $Enums.OrgRole[];
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>;
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>;
  };

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[];
    notIn?: $Enums.EventType[];
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType;
  };

  export type EnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[];
    notIn?: $Enums.EventStatus[];
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type EnumEventVisibilityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventVisibility
      | EnumEventVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.EventVisibility[];
    notIn?: $Enums.EventVisibility[];
    not?:
      | NestedEnumEventVisibilityFilter<$PrismaModel>
      | $Enums.EventVisibility;
  };

  export type EnumEventJoinModeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventJoinMode
      | EnumEventJoinModeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventJoinMode[];
    notIn?: $Enums.EventJoinMode[];
    not?: NestedEnumEventJoinModeFilter<$PrismaModel> | $Enums.EventJoinMode;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type SubmissionSchemaNullableScalarRelationFilter = {
    is?: SubmissionSchemaWhereInput | null;
    isNot?: SubmissionSchemaWhereInput | null;
  };

  export type TeamListRelationFilter = {
    every?: TeamWhereInput;
    some?: TeamWhereInput;
    none?: TeamWhereInput;
  };

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput;
    some?: AnnouncementWhereInput;
    none?: AnnouncementWhereInput;
  };

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EventOrderByRelevanceInput = {
    fields: EventOrderByRelevanceFieldEnum | EventOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type EventOrgIdSlugCompoundUniqueInput = {
    orgId: string;
    slug: string;
  };

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    heroTitle?: SortOrder;
    heroSubtitle?: SortOrder;
    rulesRich?: SortOrder;
    rubricRich?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    submitDueAt?: SortOrder;
    requireImages?: SortOrder;
    requireVideoDemo?: SortOrder;
    visibility?: SortOrder;
    joinMode?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    maxTeamSize?: SortOrder;
    lockTeamChangesAtStart?: SortOrder;
    allowSelfJoinRequests?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventAvgOrderByAggregateInput = {
    maxTeamSize?: SortOrder;
  };

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    heroTitle?: SortOrder;
    heroSubtitle?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    submitDueAt?: SortOrder;
    requireImages?: SortOrder;
    requireVideoDemo?: SortOrder;
    visibility?: SortOrder;
    joinMode?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    maxTeamSize?: SortOrder;
    lockTeamChangesAtStart?: SortOrder;
    allowSelfJoinRequests?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder;
    orgId?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    heroTitle?: SortOrder;
    heroSubtitle?: SortOrder;
    startAt?: SortOrder;
    endAt?: SortOrder;
    submitDueAt?: SortOrder;
    requireImages?: SortOrder;
    requireVideoDemo?: SortOrder;
    visibility?: SortOrder;
    joinMode?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    maxTeamSize?: SortOrder;
    lockTeamChangesAtStart?: SortOrder;
    allowSelfJoinRequests?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventSumOrderByAggregateInput = {
    maxTeamSize?: SortOrder;
  };

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[];
    notIn?: $Enums.EventType[];
    not?:
      | NestedEnumEventTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventTypeFilter<$PrismaModel>;
    _max?: NestedEnumEventTypeFilter<$PrismaModel>;
  };

  export type EnumEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[];
    notIn?: $Enums.EventStatus[];
    not?:
      | NestedEnumEventStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.EventStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventStatusFilter<$PrismaModel>;
    _max?: NestedEnumEventStatusFilter<$PrismaModel>;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          "path"
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumEventVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventVisibility
      | EnumEventVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.EventVisibility[];
    notIn?: $Enums.EventVisibility[];
    not?:
      | NestedEnumEventVisibilityWithAggregatesFilter<$PrismaModel>
      | $Enums.EventVisibility;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventVisibilityFilter<$PrismaModel>;
    _max?: NestedEnumEventVisibilityFilter<$PrismaModel>;
  };

  export type EnumEventJoinModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventJoinMode
      | EnumEventJoinModeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventJoinMode[];
    notIn?: $Enums.EventJoinMode[];
    not?:
      | NestedEnumEventJoinModeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventJoinMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventJoinModeFilter<$PrismaModel>;
    _max?: NestedEnumEventJoinModeFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumRegistrationRequestStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.RegistrationRequestStatus
      | EnumRegistrationRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RegistrationRequestStatus[];
    notIn?: $Enums.RegistrationRequestStatus[];
    not?:
      | NestedEnumRegistrationRequestStatusFilter<$PrismaModel>
      | $Enums.RegistrationRequestStatus;
  };

  export type EventScalarRelationFilter = {
    is?: EventWhereInput;
    isNot?: EventWhereInput;
  };

  export type EventRegistrationRequestOrderByRelevanceInput = {
    fields:
      | EventRegistrationRequestOrderByRelevanceFieldEnum
      | EventRegistrationRequestOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type EventRegistrationRequestEventIdUserIdCompoundUniqueInput = {
    eventId: string;
    userId: string;
  };

  export type EventRegistrationRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    reviewedAt?: SortOrder;
    reviewedByUserId?: SortOrder;
  };

  export type EventRegistrationRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    reviewedAt?: SortOrder;
    reviewedByUserId?: SortOrder;
  };

  export type EventRegistrationRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    reviewedAt?: SortOrder;
    reviewedByUserId?: SortOrder;
  };

  export type EnumRegistrationRequestStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.RegistrationRequestStatus
      | EnumRegistrationRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RegistrationRequestStatus[];
    notIn?: $Enums.RegistrationRequestStatus[];
    not?:
      | NestedEnumRegistrationRequestStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.RegistrationRequestStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRegistrationRequestStatusFilter<$PrismaModel>;
    _max?: NestedEnumRegistrationRequestStatusFilter<$PrismaModel>;
  };

  export type EnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ParticipantStatus
      | EnumParticipantStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ParticipantStatus[];
    notIn?: $Enums.ParticipantStatus[];
    not?:
      | NestedEnumParticipantStatusFilter<$PrismaModel>
      | $Enums.ParticipantStatus;
  };

  export type EventParticipantOrderByRelevanceInput = {
    fields:
      | EventParticipantOrderByRelevanceFieldEnum
      | EventParticipantOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type EventParticipantEventIdUserIdCompoundUniqueInput = {
    eventId: string;
    userId: string;
  };

  export type EventParticipantCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    newsletterOptIn?: SortOrder;
    contactEmail?: SortOrder;
    lookingForTeam?: SortOrder;
    trackPreference?: SortOrder;
    skills?: SortOrder;
    interests?: SortOrder;
    experienceLevel?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventParticipantMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    newsletterOptIn?: SortOrder;
    contactEmail?: SortOrder;
    lookingForTeam?: SortOrder;
    trackPreference?: SortOrder;
    experienceLevel?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EventParticipantMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    status?: SortOrder;
    newsletterOptIn?: SortOrder;
    contactEmail?: SortOrder;
    lookingForTeam?: SortOrder;
    trackPreference?: SortOrder;
    experienceLevel?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumParticipantStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.ParticipantStatus
        | EnumParticipantStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.ParticipantStatus[];
      notIn?: $Enums.ParticipantStatus[];
      not?:
        | NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.ParticipantStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumParticipantStatusFilter<$PrismaModel>;
      _max?: NestedEnumParticipantStatusFilter<$PrismaModel>;
    };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, "path">>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type SubmissionSchemaOrderByRelevanceInput = {
    fields:
      | SubmissionSchemaOrderByRelevanceFieldEnum
      | SubmissionSchemaOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SubmissionSchemaCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    fields?: SortOrder;
  };

  export type SubmissionSchemaMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
  };

  export type SubmissionSchemaMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, "path">
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type TeamOrderByRelevanceInput = {
    fields: TeamOrderByRelevanceFieldEnum | TeamOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    blurb?: SortOrder;
    track?: SortOrder;
    lookingForMembers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    blurb?: SortOrder;
    track?: SortOrder;
    lookingForMembers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    name?: SortOrder;
    blurb?: SortOrder;
    track?: SortOrder;
    lookingForMembers?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamRole[];
    notIn?: $Enums.TeamRole[];
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole;
  };

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput;
    isNot?: TeamWhereInput;
  };

  export type TeamMemberOrderByRelevanceInput = {
    fields:
      | TeamMemberOrderByRelevanceFieldEnum
      | TeamMemberOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string;
    userId: string;
  };

  export type TeamMemberEventIdUserIdCompoundUniqueInput = {
    eventId: string;
    userId: string;
  };

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamRole[];
    notIn?: $Enums.TeamRole[];
    not?:
      | NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.TeamRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>;
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>;
  };

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InviteStatus[];
    notIn?: $Enums.InviteStatus[];
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus;
  };

  export type TeamInviteOrderByRelevanceInput = {
    fields:
      | TeamInviteOrderByRelevanceFieldEnum
      | TeamInviteOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamInviteCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    email?: SortOrder;
    token?: SortOrder;
    status?: SortOrder;
    message?: SortOrder;
    createdByUserId?: SortOrder;
    createdAt?: SortOrder;
    expiresAt?: SortOrder;
  };

  export type TeamInviteMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    email?: SortOrder;
    token?: SortOrder;
    status?: SortOrder;
    message?: SortOrder;
    createdByUserId?: SortOrder;
    createdAt?: SortOrder;
    expiresAt?: SortOrder;
  };

  export type TeamInviteMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    email?: SortOrder;
    token?: SortOrder;
    status?: SortOrder;
    message?: SortOrder;
    createdByUserId?: SortOrder;
    createdAt?: SortOrder;
    expiresAt?: SortOrder;
  };

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InviteStatus[];
    notIn?: $Enums.InviteStatus[];
    not?:
      | NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.InviteStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>;
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>;
  };

  export type EnumJoinRequestStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.JoinRequestStatus
      | EnumJoinRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.JoinRequestStatus[];
    notIn?: $Enums.JoinRequestStatus[];
    not?:
      | NestedEnumJoinRequestStatusFilter<$PrismaModel>
      | $Enums.JoinRequestStatus;
  };

  export type TeamJoinRequestOrderByRelevanceInput = {
    fields:
      | TeamJoinRequestOrderByRelevanceFieldEnum
      | TeamJoinRequestOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamJoinRequestTeamIdUserIdCompoundUniqueInput = {
    teamId: string;
    userId: string;
  };

  export type TeamJoinRequestCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamJoinRequestMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamJoinRequestMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    userId?: SortOrder;
    message?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumJoinRequestStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.JoinRequestStatus
        | EnumJoinRequestStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.JoinRequestStatus[];
      notIn?: $Enums.JoinRequestStatus[];
      not?:
        | NestedEnumJoinRequestStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.JoinRequestStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumJoinRequestStatusFilter<$PrismaModel>;
      _max?: NestedEnumJoinRequestStatusFilter<$PrismaModel>;
    };

  export type EnumTeamAuditActionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TeamAuditAction
      | EnumTeamAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamAuditAction[];
    notIn?: $Enums.TeamAuditAction[];
    not?:
      | NestedEnumTeamAuditActionFilter<$PrismaModel>
      | $Enums.TeamAuditAction;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type TeamAuditLogOrderByRelevanceInput = {
    fields:
      | TeamAuditLogOrderByRelevanceFieldEnum
      | TeamAuditLogOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type TeamAuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    actorId?: SortOrder;
    targetUserId?: SortOrder;
    action?: SortOrder;
    meta?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TeamAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    actorId?: SortOrder;
    targetUserId?: SortOrder;
    action?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TeamAuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    actorId?: SortOrder;
    targetUserId?: SortOrder;
    action?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumTeamAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TeamAuditAction
      | EnumTeamAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamAuditAction[];
    notIn?: $Enums.TeamAuditAction[];
    not?:
      | NestedEnumTeamAuditActionWithAggregatesFilter<$PrismaModel>
      | $Enums.TeamAuditAction;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamAuditActionFilter<$PrismaModel>;
    _max?: NestedEnumTeamAuditActionFilter<$PrismaModel>;
  };

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubmissionStatus
      | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[];
    notIn?: $Enums.SubmissionStatus[];
    not?:
      | NestedEnumSubmissionStatusFilter<$PrismaModel>
      | $Enums.SubmissionStatus;
  };

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null;
    isNot?: TeamWhereInput | null;
  };

  export type SubmissionOrderByRelevanceInput = {
    fields:
      | SubmissionOrderByRelevanceFieldEnum
      | SubmissionOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    authorId?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    content?: SortOrder;
    imageUrls?: SortOrder;
    videoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submittedAt?: SortOrder;
  };

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    authorId?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    videoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submittedAt?: SortOrder;
  };

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    teamId?: SortOrder;
    authorId?: SortOrder;
    status?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    videoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submittedAt?: SortOrder;
  };

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubmissionStatus
      | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[];
    notIn?: $Enums.SubmissionStatus[];
    not?:
      | NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
  };

  export type EnumJudgeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.JudgeRole | EnumJudgeRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.JudgeRole[];
    notIn?: $Enums.JudgeRole[];
    not?: NestedEnumJudgeRoleFilter<$PrismaModel> | $Enums.JudgeRole;
  };

  export type JudgeAssignmentOrderByRelevanceInput = {
    fields:
      | JudgeAssignmentOrderByRelevanceFieldEnum
      | JudgeAssignmentOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type JudgeAssignmentEventIdUserIdCompoundUniqueInput = {
    eventId: string;
    userId: string;
  };

  export type JudgeAssignmentCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type JudgeAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type JudgeAssignmentMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
  };

  export type EnumJudgeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JudgeRole | EnumJudgeRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.JudgeRole[];
    notIn?: $Enums.JudgeRole[];
    not?:
      | NestedEnumJudgeRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.JudgeRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumJudgeRoleFilter<$PrismaModel>;
    _max?: NestedEnumJudgeRoleFilter<$PrismaModel>;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type SubmissionScalarRelationFilter = {
    is?: SubmissionWhereInput;
    isNot?: SubmissionWhereInput;
  };

  export type ScoreOrderByRelevanceInput = {
    fields: ScoreOrderByRelevanceFieldEnum | ScoreOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ScoreSubmissionIdJudgeIdCompoundUniqueInput = {
    submissionId: string;
    judgeId: string;
  };

  export type ScoreCountOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    total?: SortOrder;
    breakdown?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreAvgOrderByAggregateInput = {
    total?: SortOrder;
  };

  export type ScoreMaxOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    total?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreMinOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    total?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreSumOrderByAggregateInput = {
    total?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type AnnouncementOrderByRelevanceInput = {
    fields:
      | AnnouncementOrderByRelevanceFieldEnum
      | AnnouncementOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    title?: SortOrder;
    bodyRich?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    title?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder;
    eventId?: SortOrder;
    title?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ContactMessageOrderByRelevanceInput = {
    fields:
      | ContactMessageOrderByRelevanceFieldEnum
      | ContactMessageOrderByRelevanceFieldEnum[];
    sort: SortOrder;
    search: string;
  };

  export type ContactMessageCountOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    organization?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    readAt?: SortOrder;
  };

  export type ContactMessageMaxOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    organization?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    readAt?: SortOrder;
  };

  export type ContactMessageMinOrderByAggregateInput = {
    id?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    organization?: SortOrder;
    message?: SortOrder;
    createdAt?: SortOrder;
    readAt?: SortOrder;
  };

  export type OrgMembershipCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutUserInput,
          OrgMembershipUncheckedCreateWithoutUserInput
        >
      | OrgMembershipCreateWithoutUserInput[]
      | OrgMembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutUserInput
      | OrgMembershipCreateOrConnectWithoutUserInput[];
    createMany?: OrgMembershipCreateManyUserInputEnvelope;
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
  };

  export type EventParticipantCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutUserInput,
          EventParticipantUncheckedCreateWithoutUserInput
        >
      | EventParticipantCreateWithoutUserInput[]
      | EventParticipantUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutUserInput
      | EventParticipantCreateOrConnectWithoutUserInput[];
    createMany?: EventParticipantCreateManyUserInputEnvelope;
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
  };

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutUserInput,
          TeamMemberUncheckedCreateWithoutUserInput
        >
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type SubmissionCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutAuthorInput,
          SubmissionUncheckedCreateWithoutAuthorInput
        >
      | SubmissionCreateWithoutAuthorInput[]
      | SubmissionUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutAuthorInput
      | SubmissionCreateOrConnectWithoutAuthorInput[];
    createMany?: SubmissionCreateManyAuthorInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type JudgeAssignmentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutUserInput,
          JudgeAssignmentUncheckedCreateWithoutUserInput
        >
      | JudgeAssignmentCreateWithoutUserInput[]
      | JudgeAssignmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutUserInput
      | JudgeAssignmentCreateOrConnectWithoutUserInput[];
    createMany?: JudgeAssignmentCreateManyUserInputEnvelope;
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
  };

  export type TeamInviteCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutCreatorInput,
          TeamInviteUncheckedCreateWithoutCreatorInput
        >
      | TeamInviteCreateWithoutCreatorInput[]
      | TeamInviteUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutCreatorInput
      | TeamInviteCreateOrConnectWithoutCreatorInput[];
    createMany?: TeamInviteCreateManyCreatorInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutUserInput,
          TeamJoinRequestUncheckedCreateWithoutUserInput
        >
      | TeamJoinRequestCreateWithoutUserInput[]
      | TeamJoinRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutUserInput
      | TeamJoinRequestCreateOrConnectWithoutUserInput[];
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type TeamAuditLogCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutActorInput,
          TeamAuditLogUncheckedCreateWithoutActorInput
        >
      | TeamAuditLogCreateWithoutActorInput[]
      | TeamAuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutActorInput
      | TeamAuditLogCreateOrConnectWithoutActorInput[];
    createMany?: TeamAuditLogCreateManyActorInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type TeamAuditLogCreateNestedManyWithoutTargetUserInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTargetUserInput,
          TeamAuditLogUncheckedCreateWithoutTargetUserInput
        >
      | TeamAuditLogCreateWithoutTargetUserInput[]
      | TeamAuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput[];
    createMany?: TeamAuditLogCreateManyTargetUserInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type ScoreCreateNestedManyWithoutJudgeInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type EventRegistrationRequestCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EventRegistrationRequestCreateWithoutUserInput,
          EventRegistrationRequestUncheckedCreateWithoutUserInput
        >
      | EventRegistrationRequestCreateWithoutUserInput[]
      | EventRegistrationRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventRegistrationRequestCreateOrConnectWithoutUserInput
      | EventRegistrationRequestCreateOrConnectWithoutUserInput[];
    createMany?: EventRegistrationRequestCreateManyUserInputEnvelope;
    connect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
  };

  export type OrgMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutUserInput,
          OrgMembershipUncheckedCreateWithoutUserInput
        >
      | OrgMembershipCreateWithoutUserInput[]
      | OrgMembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutUserInput
      | OrgMembershipCreateOrConnectWithoutUserInput[];
    createMany?: OrgMembershipCreateManyUserInputEnvelope;
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
  };

  export type EventParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutUserInput,
          EventParticipantUncheckedCreateWithoutUserInput
        >
      | EventParticipantCreateWithoutUserInput[]
      | EventParticipantUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutUserInput
      | EventParticipantCreateOrConnectWithoutUserInput[];
    createMany?: EventParticipantCreateManyUserInputEnvelope;
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutUserInput,
          TeamMemberUncheckedCreateWithoutUserInput
        >
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutAuthorInput,
          SubmissionUncheckedCreateWithoutAuthorInput
        >
      | SubmissionCreateWithoutAuthorInput[]
      | SubmissionUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutAuthorInput
      | SubmissionCreateOrConnectWithoutAuthorInput[];
    createMany?: SubmissionCreateManyAuthorInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutUserInput,
          JudgeAssignmentUncheckedCreateWithoutUserInput
        >
      | JudgeAssignmentCreateWithoutUserInput[]
      | JudgeAssignmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutUserInput
      | JudgeAssignmentCreateOrConnectWithoutUserInput[];
    createMany?: JudgeAssignmentCreateManyUserInputEnvelope;
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
  };

  export type TeamInviteUncheckedCreateNestedManyWithoutCreatorInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutCreatorInput,
          TeamInviteUncheckedCreateWithoutCreatorInput
        >
      | TeamInviteCreateWithoutCreatorInput[]
      | TeamInviteUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutCreatorInput
      | TeamInviteCreateOrConnectWithoutCreatorInput[];
    createMany?: TeamInviteCreateManyCreatorInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutUserInput,
          TeamJoinRequestUncheckedCreateWithoutUserInput
        >
      | TeamJoinRequestCreateWithoutUserInput[]
      | TeamJoinRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutUserInput
      | TeamJoinRequestCreateOrConnectWithoutUserInput[];
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type TeamAuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutActorInput,
          TeamAuditLogUncheckedCreateWithoutActorInput
        >
      | TeamAuditLogCreateWithoutActorInput[]
      | TeamAuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutActorInput
      | TeamAuditLogCreateOrConnectWithoutActorInput[];
    createMany?: TeamAuditLogCreateManyActorInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTargetUserInput,
          TeamAuditLogUncheckedCreateWithoutTargetUserInput
        >
      | TeamAuditLogCreateWithoutTargetUserInput[]
      | TeamAuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput[];
    createMany?: TeamAuditLogCreateManyTargetUserInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type ScoreUncheckedCreateNestedManyWithoutJudgeInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput =
    {
      create?:
        | XOR<
            EventRegistrationRequestCreateWithoutUserInput,
            EventRegistrationRequestUncheckedCreateWithoutUserInput
          >
        | EventRegistrationRequestCreateWithoutUserInput[]
        | EventRegistrationRequestUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EventRegistrationRequestCreateOrConnectWithoutUserInput
        | EventRegistrationRequestCreateOrConnectWithoutUserInput[];
      createMany?: EventRegistrationRequestCreateManyUserInputEnvelope;
      connect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
    };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type OrgMembershipUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutUserInput,
          OrgMembershipUncheckedCreateWithoutUserInput
        >
      | OrgMembershipCreateWithoutUserInput[]
      | OrgMembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutUserInput
      | OrgMembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrgMembershipUpsertWithWhereUniqueWithoutUserInput
      | OrgMembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrgMembershipCreateManyUserInputEnvelope;
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    disconnect?:
      | OrgMembershipWhereUniqueInput
      | OrgMembershipWhereUniqueInput[];
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    update?:
      | OrgMembershipUpdateWithWhereUniqueWithoutUserInput
      | OrgMembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrgMembershipUpdateManyWithWhereWithoutUserInput
      | OrgMembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | OrgMembershipScalarWhereInput
      | OrgMembershipScalarWhereInput[];
  };

  export type EventParticipantUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutUserInput,
          EventParticipantUncheckedCreateWithoutUserInput
        >
      | EventParticipantCreateWithoutUserInput[]
      | EventParticipantUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutUserInput
      | EventParticipantCreateOrConnectWithoutUserInput[];
    upsert?:
      | EventParticipantUpsertWithWhereUniqueWithoutUserInput
      | EventParticipantUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EventParticipantCreateManyUserInputEnvelope;
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[];
    disconnect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    delete?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    update?:
      | EventParticipantUpdateWithWhereUniqueWithoutUserInput
      | EventParticipantUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EventParticipantUpdateManyWithWhereWithoutUserInput
      | EventParticipantUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | EventParticipantScalarWhereInput
      | EventParticipantScalarWhereInput[];
  };

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutUserInput,
          TeamMemberUncheckedCreateWithoutUserInput
        >
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type SubmissionUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutAuthorInput,
          SubmissionUncheckedCreateWithoutAuthorInput
        >
      | SubmissionCreateWithoutAuthorInput[]
      | SubmissionUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutAuthorInput
      | SubmissionCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutAuthorInput
      | SubmissionUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: SubmissionCreateManyAuthorInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutAuthorInput
      | SubmissionUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutAuthorInput
      | SubmissionUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type JudgeAssignmentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutUserInput,
          JudgeAssignmentUncheckedCreateWithoutUserInput
        >
      | JudgeAssignmentCreateWithoutUserInput[]
      | JudgeAssignmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutUserInput
      | JudgeAssignmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | JudgeAssignmentUpsertWithWhereUniqueWithoutUserInput
      | JudgeAssignmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: JudgeAssignmentCreateManyUserInputEnvelope;
    set?: JudgeAssignmentWhereUniqueInput | JudgeAssignmentWhereUniqueInput[];
    disconnect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    delete?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    update?:
      | JudgeAssignmentUpdateWithWhereUniqueWithoutUserInput
      | JudgeAssignmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | JudgeAssignmentUpdateManyWithWhereWithoutUserInput
      | JudgeAssignmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | JudgeAssignmentScalarWhereInput
      | JudgeAssignmentScalarWhereInput[];
  };

  export type TeamInviteUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutCreatorInput,
          TeamInviteUncheckedCreateWithoutCreatorInput
        >
      | TeamInviteCreateWithoutCreatorInput[]
      | TeamInviteUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutCreatorInput
      | TeamInviteCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutCreatorInput
      | TeamInviteUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: TeamInviteCreateManyCreatorInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutCreatorInput
      | TeamInviteUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutCreatorInput
      | TeamInviteUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutUserInput,
          TeamJoinRequestUncheckedCreateWithoutUserInput
        >
      | TeamJoinRequestCreateWithoutUserInput[]
      | TeamJoinRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutUserInput
      | TeamJoinRequestCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutUserInput
      | TeamJoinRequestUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type TeamAuditLogUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutActorInput,
          TeamAuditLogUncheckedCreateWithoutActorInput
        >
      | TeamAuditLogCreateWithoutActorInput[]
      | TeamAuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutActorInput
      | TeamAuditLogCreateOrConnectWithoutActorInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutActorInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: TeamAuditLogCreateManyActorInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutActorInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutActorInput
      | TeamAuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type TeamAuditLogUpdateManyWithoutTargetUserNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTargetUserInput,
          TeamAuditLogUncheckedCreateWithoutTargetUserInput
        >
      | TeamAuditLogCreateWithoutTargetUserInput[]
      | TeamAuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutTargetUserInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutTargetUserInput[];
    createMany?: TeamAuditLogCreateManyTargetUserInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutTargetUserInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutTargetUserInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutTargetUserInput
      | TeamAuditLogUpdateManyWithWhereWithoutTargetUserInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type ScoreUpdateManyWithoutJudgeNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutJudgeInput
      | ScoreUpdateManyWithWhereWithoutJudgeInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type EventRegistrationRequestUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EventRegistrationRequestCreateWithoutUserInput,
          EventRegistrationRequestUncheckedCreateWithoutUserInput
        >
      | EventRegistrationRequestCreateWithoutUserInput[]
      | EventRegistrationRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventRegistrationRequestCreateOrConnectWithoutUserInput
      | EventRegistrationRequestCreateOrConnectWithoutUserInput[];
    upsert?:
      | EventRegistrationRequestUpsertWithWhereUniqueWithoutUserInput
      | EventRegistrationRequestUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EventRegistrationRequestCreateManyUserInputEnvelope;
    set?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    disconnect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    delete?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    connect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    update?:
      | EventRegistrationRequestUpdateWithWhereUniqueWithoutUserInput
      | EventRegistrationRequestUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EventRegistrationRequestUpdateManyWithWhereWithoutUserInput
      | EventRegistrationRequestUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | EventRegistrationRequestScalarWhereInput
      | EventRegistrationRequestScalarWhereInput[];
  };

  export type OrgMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutUserInput,
          OrgMembershipUncheckedCreateWithoutUserInput
        >
      | OrgMembershipCreateWithoutUserInput[]
      | OrgMembershipUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutUserInput
      | OrgMembershipCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrgMembershipUpsertWithWhereUniqueWithoutUserInput
      | OrgMembershipUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrgMembershipCreateManyUserInputEnvelope;
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    disconnect?:
      | OrgMembershipWhereUniqueInput
      | OrgMembershipWhereUniqueInput[];
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    update?:
      | OrgMembershipUpdateWithWhereUniqueWithoutUserInput
      | OrgMembershipUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrgMembershipUpdateManyWithWhereWithoutUserInput
      | OrgMembershipUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | OrgMembershipScalarWhereInput
      | OrgMembershipScalarWhereInput[];
  };

  export type EventParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutUserInput,
          EventParticipantUncheckedCreateWithoutUserInput
        >
      | EventParticipantCreateWithoutUserInput[]
      | EventParticipantUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutUserInput
      | EventParticipantCreateOrConnectWithoutUserInput[];
    upsert?:
      | EventParticipantUpsertWithWhereUniqueWithoutUserInput
      | EventParticipantUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EventParticipantCreateManyUserInputEnvelope;
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[];
    disconnect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    delete?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    update?:
      | EventParticipantUpdateWithWhereUniqueWithoutUserInput
      | EventParticipantUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EventParticipantUpdateManyWithWhereWithoutUserInput
      | EventParticipantUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | EventParticipantScalarWhereInput
      | EventParticipantScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutUserInput,
          TeamMemberUncheckedCreateWithoutUserInput
        >
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutAuthorInput,
          SubmissionUncheckedCreateWithoutAuthorInput
        >
      | SubmissionCreateWithoutAuthorInput[]
      | SubmissionUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutAuthorInput
      | SubmissionCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutAuthorInput
      | SubmissionUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: SubmissionCreateManyAuthorInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutAuthorInput
      | SubmissionUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutAuthorInput
      | SubmissionUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutUserInput,
          JudgeAssignmentUncheckedCreateWithoutUserInput
        >
      | JudgeAssignmentCreateWithoutUserInput[]
      | JudgeAssignmentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutUserInput
      | JudgeAssignmentCreateOrConnectWithoutUserInput[];
    upsert?:
      | JudgeAssignmentUpsertWithWhereUniqueWithoutUserInput
      | JudgeAssignmentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: JudgeAssignmentCreateManyUserInputEnvelope;
    set?: JudgeAssignmentWhereUniqueInput | JudgeAssignmentWhereUniqueInput[];
    disconnect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    delete?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    update?:
      | JudgeAssignmentUpdateWithWhereUniqueWithoutUserInput
      | JudgeAssignmentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | JudgeAssignmentUpdateManyWithWhereWithoutUserInput
      | JudgeAssignmentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | JudgeAssignmentScalarWhereInput
      | JudgeAssignmentScalarWhereInput[];
  };

  export type TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutCreatorInput,
          TeamInviteUncheckedCreateWithoutCreatorInput
        >
      | TeamInviteCreateWithoutCreatorInput[]
      | TeamInviteUncheckedCreateWithoutCreatorInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutCreatorInput
      | TeamInviteCreateOrConnectWithoutCreatorInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutCreatorInput
      | TeamInviteUpsertWithWhereUniqueWithoutCreatorInput[];
    createMany?: TeamInviteCreateManyCreatorInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutCreatorInput
      | TeamInviteUpdateWithWhereUniqueWithoutCreatorInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutCreatorInput
      | TeamInviteUpdateManyWithWhereWithoutCreatorInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutUserInput,
          TeamJoinRequestUncheckedCreateWithoutUserInput
        >
      | TeamJoinRequestCreateWithoutUserInput[]
      | TeamJoinRequestUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutUserInput
      | TeamJoinRequestCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutUserInput
      | TeamJoinRequestUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutActorInput,
          TeamAuditLogUncheckedCreateWithoutActorInput
        >
      | TeamAuditLogCreateWithoutActorInput[]
      | TeamAuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutActorInput
      | TeamAuditLogCreateOrConnectWithoutActorInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutActorInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: TeamAuditLogCreateManyActorInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutActorInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutActorInput
      | TeamAuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTargetUserInput,
          TeamAuditLogUncheckedCreateWithoutTargetUserInput
        >
      | TeamAuditLogCreateWithoutTargetUserInput[]
      | TeamAuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput
      | TeamAuditLogCreateOrConnectWithoutTargetUserInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutTargetUserInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutTargetUserInput[];
    createMany?: TeamAuditLogCreateManyTargetUserInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutTargetUserInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutTargetUserInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutTargetUserInput
      | TeamAuditLogUpdateManyWithWhereWithoutTargetUserInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type ScoreUncheckedUpdateManyWithoutJudgeNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutJudgeInput
      | ScoreUpdateManyWithWhereWithoutJudgeInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput =
    {
      create?:
        | XOR<
            EventRegistrationRequestCreateWithoutUserInput,
            EventRegistrationRequestUncheckedCreateWithoutUserInput
          >
        | EventRegistrationRequestCreateWithoutUserInput[]
        | EventRegistrationRequestUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EventRegistrationRequestCreateOrConnectWithoutUserInput
        | EventRegistrationRequestCreateOrConnectWithoutUserInput[];
      upsert?:
        | EventRegistrationRequestUpsertWithWhereUniqueWithoutUserInput
        | EventRegistrationRequestUpsertWithWhereUniqueWithoutUserInput[];
      createMany?: EventRegistrationRequestCreateManyUserInputEnvelope;
      set?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      disconnect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      delete?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      connect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      update?:
        | EventRegistrationRequestUpdateWithWhereUniqueWithoutUserInput
        | EventRegistrationRequestUpdateWithWhereUniqueWithoutUserInput[];
      updateMany?:
        | EventRegistrationRequestUpdateManyWithWhereWithoutUserInput
        | EventRegistrationRequestUpdateManyWithWhereWithoutUserInput[];
      deleteMany?:
        | EventRegistrationRequestScalarWhereInput
        | EventRegistrationRequestScalarWhereInput[];
    };

  export type OrgMembershipCreateNestedManyWithoutOrgInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutOrgInput,
          OrgMembershipUncheckedCreateWithoutOrgInput
        >
      | OrgMembershipCreateWithoutOrgInput[]
      | OrgMembershipUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutOrgInput
      | OrgMembershipCreateOrConnectWithoutOrgInput[];
    createMany?: OrgMembershipCreateManyOrgInputEnvelope;
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
  };

  export type EventCreateNestedManyWithoutOrgInput = {
    create?:
      | XOR<EventCreateWithoutOrgInput, EventUncheckedCreateWithoutOrgInput>
      | EventCreateWithoutOrgInput[]
      | EventUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrgInput
      | EventCreateOrConnectWithoutOrgInput[];
    createMany?: EventCreateManyOrgInputEnvelope;
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type OrgMembershipUncheckedCreateNestedManyWithoutOrgInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutOrgInput,
          OrgMembershipUncheckedCreateWithoutOrgInput
        >
      | OrgMembershipCreateWithoutOrgInput[]
      | OrgMembershipUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutOrgInput
      | OrgMembershipCreateOrConnectWithoutOrgInput[];
    createMany?: OrgMembershipCreateManyOrgInputEnvelope;
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
  };

  export type EventUncheckedCreateNestedManyWithoutOrgInput = {
    create?:
      | XOR<EventCreateWithoutOrgInput, EventUncheckedCreateWithoutOrgInput>
      | EventCreateWithoutOrgInput[]
      | EventUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrgInput
      | EventCreateOrConnectWithoutOrgInput[];
    createMany?: EventCreateManyOrgInputEnvelope;
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
  };

  export type OrgMembershipUpdateManyWithoutOrgNestedInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutOrgInput,
          OrgMembershipUncheckedCreateWithoutOrgInput
        >
      | OrgMembershipCreateWithoutOrgInput[]
      | OrgMembershipUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutOrgInput
      | OrgMembershipCreateOrConnectWithoutOrgInput[];
    upsert?:
      | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput
      | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput[];
    createMany?: OrgMembershipCreateManyOrgInputEnvelope;
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    disconnect?:
      | OrgMembershipWhereUniqueInput
      | OrgMembershipWhereUniqueInput[];
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    update?:
      | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput
      | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput[];
    updateMany?:
      | OrgMembershipUpdateManyWithWhereWithoutOrgInput
      | OrgMembershipUpdateManyWithWhereWithoutOrgInput[];
    deleteMany?:
      | OrgMembershipScalarWhereInput
      | OrgMembershipScalarWhereInput[];
  };

  export type EventUpdateManyWithoutOrgNestedInput = {
    create?:
      | XOR<EventCreateWithoutOrgInput, EventUncheckedCreateWithoutOrgInput>
      | EventCreateWithoutOrgInput[]
      | EventUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrgInput
      | EventCreateOrConnectWithoutOrgInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutOrgInput
      | EventUpsertWithWhereUniqueWithoutOrgInput[];
    createMany?: EventCreateManyOrgInputEnvelope;
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutOrgInput
      | EventUpdateWithWhereUniqueWithoutOrgInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutOrgInput
      | EventUpdateManyWithWhereWithoutOrgInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput = {
    create?:
      | XOR<
          OrgMembershipCreateWithoutOrgInput,
          OrgMembershipUncheckedCreateWithoutOrgInput
        >
      | OrgMembershipCreateWithoutOrgInput[]
      | OrgMembershipUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | OrgMembershipCreateOrConnectWithoutOrgInput
      | OrgMembershipCreateOrConnectWithoutOrgInput[];
    upsert?:
      | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput
      | OrgMembershipUpsertWithWhereUniqueWithoutOrgInput[];
    createMany?: OrgMembershipCreateManyOrgInputEnvelope;
    set?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    disconnect?:
      | OrgMembershipWhereUniqueInput
      | OrgMembershipWhereUniqueInput[];
    delete?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    connect?: OrgMembershipWhereUniqueInput | OrgMembershipWhereUniqueInput[];
    update?:
      | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput
      | OrgMembershipUpdateWithWhereUniqueWithoutOrgInput[];
    updateMany?:
      | OrgMembershipUpdateManyWithWhereWithoutOrgInput
      | OrgMembershipUpdateManyWithWhereWithoutOrgInput[];
    deleteMany?:
      | OrgMembershipScalarWhereInput
      | OrgMembershipScalarWhereInput[];
  };

  export type EventUncheckedUpdateManyWithoutOrgNestedInput = {
    create?:
      | XOR<EventCreateWithoutOrgInput, EventUncheckedCreateWithoutOrgInput>
      | EventCreateWithoutOrgInput[]
      | EventUncheckedCreateWithoutOrgInput[];
    connectOrCreate?:
      | EventCreateOrConnectWithoutOrgInput
      | EventCreateOrConnectWithoutOrgInput[];
    upsert?:
      | EventUpsertWithWhereUniqueWithoutOrgInput
      | EventUpsertWithWhereUniqueWithoutOrgInput[];
    createMany?: EventCreateManyOrgInputEnvelope;
    set?: EventWhereUniqueInput | EventWhereUniqueInput[];
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[];
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[];
    update?:
      | EventUpdateWithWhereUniqueWithoutOrgInput
      | EventUpdateWithWhereUniqueWithoutOrgInput[];
    updateMany?:
      | EventUpdateManyWithWhereWithoutOrgInput
      | EventUpdateManyWithWhereWithoutOrgInput[];
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[];
  };

  export type OrganizationCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumOrgRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrgRole;
  };

  export type OrganizationUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembershipsInput;
    upsert?: OrganizationUpsertWithoutMembershipsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutMembershipsInput,
        OrganizationUpdateWithoutMembershipsInput
      >,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput;
    upsert?: UserUpsertWithoutMembershipsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutMembershipsInput,
        UserUpdateWithoutMembershipsInput
      >,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type OrganizationCreateNestedOneWithoutEventsInput = {
    create?: XOR<
      OrganizationCreateWithoutEventsInput,
      OrganizationUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput;
    connect?: OrganizationWhereUniqueInput;
  };

  export type SubmissionSchemaCreateNestedOneWithoutEventInput = {
    create?: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
    connectOrCreate?: SubmissionSchemaCreateOrConnectWithoutEventInput;
    connect?: SubmissionSchemaWhereUniqueInput;
  };

  export type EventParticipantCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutEventInput,
          EventParticipantUncheckedCreateWithoutEventInput
        >
      | EventParticipantCreateWithoutEventInput[]
      | EventParticipantUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutEventInput
      | EventParticipantCreateOrConnectWithoutEventInput[];
    createMany?: EventParticipantCreateManyEventInputEnvelope;
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
  };

  export type TeamCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type TeamInviteCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutEventInput,
          TeamInviteUncheckedCreateWithoutEventInput
        >
      | TeamInviteCreateWithoutEventInput[]
      | TeamInviteUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutEventInput
      | TeamInviteCreateOrConnectWithoutEventInput[];
    createMany?: TeamInviteCreateManyEventInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutEventInput,
          TeamJoinRequestUncheckedCreateWithoutEventInput
        >
      | TeamJoinRequestCreateWithoutEventInput[]
      | TeamJoinRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutEventInput
      | TeamJoinRequestCreateOrConnectWithoutEventInput[];
    createMany?: TeamJoinRequestCreateManyEventInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type TeamAuditLogCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutEventInput,
          TeamAuditLogUncheckedCreateWithoutEventInput
        >
      | TeamAuditLogCreateWithoutEventInput[]
      | TeamAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutEventInput
      | TeamAuditLogCreateOrConnectWithoutEventInput[];
    createMany?: TeamAuditLogCreateManyEventInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type SubmissionCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutEventInput,
          SubmissionUncheckedCreateWithoutEventInput
        >
      | SubmissionCreateWithoutEventInput[]
      | SubmissionUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutEventInput
      | SubmissionCreateOrConnectWithoutEventInput[];
    createMany?: SubmissionCreateManyEventInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type AnnouncementCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutEventInput,
          AnnouncementUncheckedCreateWithoutEventInput
        >
      | AnnouncementCreateWithoutEventInput[]
      | AnnouncementUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutEventInput
      | AnnouncementCreateOrConnectWithoutEventInput[];
    createMany?: AnnouncementCreateManyEventInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type JudgeAssignmentCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutEventInput,
          JudgeAssignmentUncheckedCreateWithoutEventInput
        >
      | JudgeAssignmentCreateWithoutEventInput[]
      | JudgeAssignmentUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutEventInput
      | JudgeAssignmentCreateOrConnectWithoutEventInput[];
    createMany?: JudgeAssignmentCreateManyEventInputEnvelope;
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
  };

  export type EventRegistrationRequestCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          EventRegistrationRequestCreateWithoutEventInput,
          EventRegistrationRequestUncheckedCreateWithoutEventInput
        >
      | EventRegistrationRequestCreateWithoutEventInput[]
      | EventRegistrationRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventRegistrationRequestCreateOrConnectWithoutEventInput
      | EventRegistrationRequestCreateOrConnectWithoutEventInput[];
    createMany?: EventRegistrationRequestCreateManyEventInputEnvelope;
    connect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
  };

  export type SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
    connectOrCreate?: SubmissionSchemaCreateOrConnectWithoutEventInput;
    connect?: SubmissionSchemaWhereUniqueInput;
  };

  export type EventParticipantUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutEventInput,
          EventParticipantUncheckedCreateWithoutEventInput
        >
      | EventParticipantCreateWithoutEventInput[]
      | EventParticipantUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutEventInput
      | EventParticipantCreateOrConnectWithoutEventInput[];
    createMany?: EventParticipantCreateManyEventInputEnvelope;
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
  };

  export type TeamUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type TeamInviteUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutEventInput,
          TeamInviteUncheckedCreateWithoutEventInput
        >
      | TeamInviteCreateWithoutEventInput[]
      | TeamInviteUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutEventInput
      | TeamInviteCreateOrConnectWithoutEventInput[];
    createMany?: TeamInviteCreateManyEventInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutEventInput,
          TeamJoinRequestUncheckedCreateWithoutEventInput
        >
      | TeamJoinRequestCreateWithoutEventInput[]
      | TeamJoinRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutEventInput
      | TeamJoinRequestCreateOrConnectWithoutEventInput[];
    createMany?: TeamJoinRequestCreateManyEventInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type TeamAuditLogUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutEventInput,
          TeamAuditLogUncheckedCreateWithoutEventInput
        >
      | TeamAuditLogCreateWithoutEventInput[]
      | TeamAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutEventInput
      | TeamAuditLogCreateOrConnectWithoutEventInput[];
    createMany?: TeamAuditLogCreateManyEventInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutEventInput,
          SubmissionUncheckedCreateWithoutEventInput
        >
      | SubmissionCreateWithoutEventInput[]
      | SubmissionUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutEventInput
      | SubmissionCreateOrConnectWithoutEventInput[];
    createMany?: SubmissionCreateManyEventInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type AnnouncementUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutEventInput,
          AnnouncementUncheckedCreateWithoutEventInput
        >
      | AnnouncementCreateWithoutEventInput[]
      | AnnouncementUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutEventInput
      | AnnouncementCreateOrConnectWithoutEventInput[];
    createMany?: AnnouncementCreateManyEventInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutEventInput,
          JudgeAssignmentUncheckedCreateWithoutEventInput
        >
      | JudgeAssignmentCreateWithoutEventInput[]
      | JudgeAssignmentUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutEventInput
      | JudgeAssignmentCreateOrConnectWithoutEventInput[];
    createMany?: JudgeAssignmentCreateManyEventInputEnvelope;
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
  };

  export type EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput =
    {
      create?:
        | XOR<
            EventRegistrationRequestCreateWithoutEventInput,
            EventRegistrationRequestUncheckedCreateWithoutEventInput
          >
        | EventRegistrationRequestCreateWithoutEventInput[]
        | EventRegistrationRequestUncheckedCreateWithoutEventInput[];
      connectOrCreate?:
        | EventRegistrationRequestCreateOrConnectWithoutEventInput
        | EventRegistrationRequestCreateOrConnectWithoutEventInput[];
      createMany?: EventRegistrationRequestCreateManyEventInputEnvelope;
      connect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
    };

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType;
  };

  export type EnumEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EventStatus;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type EnumEventVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.EventVisibility;
  };

  export type EnumEventJoinModeFieldUpdateOperationsInput = {
    set?: $Enums.EventJoinMode;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type OrganizationUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<
      OrganizationCreateWithoutEventsInput,
      OrganizationUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput;
    upsert?: OrganizationUpsertWithoutEventsInput;
    connect?: OrganizationWhereUniqueInput;
    update?: XOR<
      XOR<
        OrganizationUpdateToOneWithWhereWithoutEventsInput,
        OrganizationUpdateWithoutEventsInput
      >,
      OrganizationUncheckedUpdateWithoutEventsInput
    >;
  };

  export type SubmissionSchemaUpdateOneWithoutEventNestedInput = {
    create?: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
    connectOrCreate?: SubmissionSchemaCreateOrConnectWithoutEventInput;
    upsert?: SubmissionSchemaUpsertWithoutEventInput;
    disconnect?: SubmissionSchemaWhereInput | boolean;
    delete?: SubmissionSchemaWhereInput | boolean;
    connect?: SubmissionSchemaWhereUniqueInput;
    update?: XOR<
      XOR<
        SubmissionSchemaUpdateToOneWithWhereWithoutEventInput,
        SubmissionSchemaUpdateWithoutEventInput
      >,
      SubmissionSchemaUncheckedUpdateWithoutEventInput
    >;
  };

  export type EventParticipantUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutEventInput,
          EventParticipantUncheckedCreateWithoutEventInput
        >
      | EventParticipantCreateWithoutEventInput[]
      | EventParticipantUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutEventInput
      | EventParticipantCreateOrConnectWithoutEventInput[];
    upsert?:
      | EventParticipantUpsertWithWhereUniqueWithoutEventInput
      | EventParticipantUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: EventParticipantCreateManyEventInputEnvelope;
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[];
    disconnect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    delete?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    update?:
      | EventParticipantUpdateWithWhereUniqueWithoutEventInput
      | EventParticipantUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | EventParticipantUpdateManyWithWhereWithoutEventInput
      | EventParticipantUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | EventParticipantScalarWhereInput
      | EventParticipantScalarWhereInput[];
  };

  export type TeamUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutEventInput
      | TeamUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutEventInput
      | TeamUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutEventInput
      | TeamUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type TeamInviteUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutEventInput,
          TeamInviteUncheckedCreateWithoutEventInput
        >
      | TeamInviteCreateWithoutEventInput[]
      | TeamInviteUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutEventInput
      | TeamInviteCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutEventInput
      | TeamInviteUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamInviteCreateManyEventInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutEventInput
      | TeamInviteUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutEventInput
      | TeamInviteUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutEventInput,
          TeamJoinRequestUncheckedCreateWithoutEventInput
        >
      | TeamJoinRequestCreateWithoutEventInput[]
      | TeamJoinRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutEventInput
      | TeamJoinRequestCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutEventInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamJoinRequestCreateManyEventInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutEventInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutEventInput
      | TeamJoinRequestUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type TeamAuditLogUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutEventInput,
          TeamAuditLogUncheckedCreateWithoutEventInput
        >
      | TeamAuditLogCreateWithoutEventInput[]
      | TeamAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutEventInput
      | TeamAuditLogCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutEventInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamAuditLogCreateManyEventInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutEventInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutEventInput
      | TeamAuditLogUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type SubmissionUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutEventInput,
          SubmissionUncheckedCreateWithoutEventInput
        >
      | SubmissionCreateWithoutEventInput[]
      | SubmissionUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutEventInput
      | SubmissionCreateOrConnectWithoutEventInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutEventInput
      | SubmissionUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: SubmissionCreateManyEventInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutEventInput
      | SubmissionUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutEventInput
      | SubmissionUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type AnnouncementUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutEventInput,
          AnnouncementUncheckedCreateWithoutEventInput
        >
      | AnnouncementCreateWithoutEventInput[]
      | AnnouncementUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutEventInput
      | AnnouncementCreateOrConnectWithoutEventInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutEventInput
      | AnnouncementUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: AnnouncementCreateManyEventInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutEventInput
      | AnnouncementUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutEventInput
      | AnnouncementUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type JudgeAssignmentUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutEventInput,
          JudgeAssignmentUncheckedCreateWithoutEventInput
        >
      | JudgeAssignmentCreateWithoutEventInput[]
      | JudgeAssignmentUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutEventInput
      | JudgeAssignmentCreateOrConnectWithoutEventInput[];
    upsert?:
      | JudgeAssignmentUpsertWithWhereUniqueWithoutEventInput
      | JudgeAssignmentUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: JudgeAssignmentCreateManyEventInputEnvelope;
    set?: JudgeAssignmentWhereUniqueInput | JudgeAssignmentWhereUniqueInput[];
    disconnect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    delete?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    update?:
      | JudgeAssignmentUpdateWithWhereUniqueWithoutEventInput
      | JudgeAssignmentUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | JudgeAssignmentUpdateManyWithWhereWithoutEventInput
      | JudgeAssignmentUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | JudgeAssignmentScalarWhereInput
      | JudgeAssignmentScalarWhereInput[];
  };

  export type EventRegistrationRequestUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          EventRegistrationRequestCreateWithoutEventInput,
          EventRegistrationRequestUncheckedCreateWithoutEventInput
        >
      | EventRegistrationRequestCreateWithoutEventInput[]
      | EventRegistrationRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventRegistrationRequestCreateOrConnectWithoutEventInput
      | EventRegistrationRequestCreateOrConnectWithoutEventInput[];
    upsert?:
      | EventRegistrationRequestUpsertWithWhereUniqueWithoutEventInput
      | EventRegistrationRequestUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: EventRegistrationRequestCreateManyEventInputEnvelope;
    set?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    disconnect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    delete?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    connect?:
      | EventRegistrationRequestWhereUniqueInput
      | EventRegistrationRequestWhereUniqueInput[];
    update?:
      | EventRegistrationRequestUpdateWithWhereUniqueWithoutEventInput
      | EventRegistrationRequestUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | EventRegistrationRequestUpdateManyWithWhereWithoutEventInput
      | EventRegistrationRequestUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | EventRegistrationRequestScalarWhereInput
      | EventRegistrationRequestScalarWhereInput[];
  };

  export type SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
    connectOrCreate?: SubmissionSchemaCreateOrConnectWithoutEventInput;
    upsert?: SubmissionSchemaUpsertWithoutEventInput;
    disconnect?: SubmissionSchemaWhereInput | boolean;
    delete?: SubmissionSchemaWhereInput | boolean;
    connect?: SubmissionSchemaWhereUniqueInput;
    update?: XOR<
      XOR<
        SubmissionSchemaUpdateToOneWithWhereWithoutEventInput,
        SubmissionSchemaUpdateWithoutEventInput
      >,
      SubmissionSchemaUncheckedUpdateWithoutEventInput
    >;
  };

  export type EventParticipantUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          EventParticipantCreateWithoutEventInput,
          EventParticipantUncheckedCreateWithoutEventInput
        >
      | EventParticipantCreateWithoutEventInput[]
      | EventParticipantUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | EventParticipantCreateOrConnectWithoutEventInput
      | EventParticipantCreateOrConnectWithoutEventInput[];
    upsert?:
      | EventParticipantUpsertWithWhereUniqueWithoutEventInput
      | EventParticipantUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: EventParticipantCreateManyEventInputEnvelope;
    set?: EventParticipantWhereUniqueInput | EventParticipantWhereUniqueInput[];
    disconnect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    delete?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    connect?:
      | EventParticipantWhereUniqueInput
      | EventParticipantWhereUniqueInput[];
    update?:
      | EventParticipantUpdateWithWhereUniqueWithoutEventInput
      | EventParticipantUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | EventParticipantUpdateManyWithWhereWithoutEventInput
      | EventParticipantUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | EventParticipantScalarWhereInput
      | EventParticipantScalarWhereInput[];
  };

  export type TeamUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
      | TeamCreateWithoutEventInput[]
      | TeamUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutEventInput
      | TeamCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutEventInput
      | TeamUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamCreateManyEventInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutEventInput
      | TeamUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutEventInput
      | TeamUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type TeamInviteUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutEventInput,
          TeamInviteUncheckedCreateWithoutEventInput
        >
      | TeamInviteCreateWithoutEventInput[]
      | TeamInviteUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutEventInput
      | TeamInviteCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutEventInput
      | TeamInviteUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamInviteCreateManyEventInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutEventInput
      | TeamInviteUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutEventInput
      | TeamInviteUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutEventInput,
          TeamJoinRequestUncheckedCreateWithoutEventInput
        >
      | TeamJoinRequestCreateWithoutEventInput[]
      | TeamJoinRequestUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutEventInput
      | TeamJoinRequestCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutEventInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamJoinRequestCreateManyEventInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutEventInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutEventInput
      | TeamJoinRequestUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutEventInput,
          TeamAuditLogUncheckedCreateWithoutEventInput
        >
      | TeamAuditLogCreateWithoutEventInput[]
      | TeamAuditLogUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutEventInput
      | TeamAuditLogCreateOrConnectWithoutEventInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutEventInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: TeamAuditLogCreateManyEventInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutEventInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutEventInput
      | TeamAuditLogUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutEventInput,
          SubmissionUncheckedCreateWithoutEventInput
        >
      | SubmissionCreateWithoutEventInput[]
      | SubmissionUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutEventInput
      | SubmissionCreateOrConnectWithoutEventInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutEventInput
      | SubmissionUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: SubmissionCreateManyEventInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutEventInput
      | SubmissionUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutEventInput
      | SubmissionUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type AnnouncementUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutEventInput,
          AnnouncementUncheckedCreateWithoutEventInput
        >
      | AnnouncementCreateWithoutEventInput[]
      | AnnouncementUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutEventInput
      | AnnouncementCreateOrConnectWithoutEventInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutEventInput
      | AnnouncementUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: AnnouncementCreateManyEventInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutEventInput
      | AnnouncementUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutEventInput
      | AnnouncementUpdateManyWithWhereWithoutEventInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput = {
    create?:
      | XOR<
          JudgeAssignmentCreateWithoutEventInput,
          JudgeAssignmentUncheckedCreateWithoutEventInput
        >
      | JudgeAssignmentCreateWithoutEventInput[]
      | JudgeAssignmentUncheckedCreateWithoutEventInput[];
    connectOrCreate?:
      | JudgeAssignmentCreateOrConnectWithoutEventInput
      | JudgeAssignmentCreateOrConnectWithoutEventInput[];
    upsert?:
      | JudgeAssignmentUpsertWithWhereUniqueWithoutEventInput
      | JudgeAssignmentUpsertWithWhereUniqueWithoutEventInput[];
    createMany?: JudgeAssignmentCreateManyEventInputEnvelope;
    set?: JudgeAssignmentWhereUniqueInput | JudgeAssignmentWhereUniqueInput[];
    disconnect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    delete?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    connect?:
      | JudgeAssignmentWhereUniqueInput
      | JudgeAssignmentWhereUniqueInput[];
    update?:
      | JudgeAssignmentUpdateWithWhereUniqueWithoutEventInput
      | JudgeAssignmentUpdateWithWhereUniqueWithoutEventInput[];
    updateMany?:
      | JudgeAssignmentUpdateManyWithWhereWithoutEventInput
      | JudgeAssignmentUpdateManyWithWhereWithoutEventInput[];
    deleteMany?:
      | JudgeAssignmentScalarWhereInput
      | JudgeAssignmentScalarWhereInput[];
  };

  export type EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput =
    {
      create?:
        | XOR<
            EventRegistrationRequestCreateWithoutEventInput,
            EventRegistrationRequestUncheckedCreateWithoutEventInput
          >
        | EventRegistrationRequestCreateWithoutEventInput[]
        | EventRegistrationRequestUncheckedCreateWithoutEventInput[];
      connectOrCreate?:
        | EventRegistrationRequestCreateOrConnectWithoutEventInput
        | EventRegistrationRequestCreateOrConnectWithoutEventInput[];
      upsert?:
        | EventRegistrationRequestUpsertWithWhereUniqueWithoutEventInput
        | EventRegistrationRequestUpsertWithWhereUniqueWithoutEventInput[];
      createMany?: EventRegistrationRequestCreateManyEventInputEnvelope;
      set?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      disconnect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      delete?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      connect?:
        | EventRegistrationRequestWhereUniqueInput
        | EventRegistrationRequestWhereUniqueInput[];
      update?:
        | EventRegistrationRequestUpdateWithWhereUniqueWithoutEventInput
        | EventRegistrationRequestUpdateWithWhereUniqueWithoutEventInput[];
      updateMany?:
        | EventRegistrationRequestUpdateManyWithWhereWithoutEventInput
        | EventRegistrationRequestUpdateManyWithWhereWithoutEventInput[];
      deleteMany?:
        | EventRegistrationRequestScalarWhereInput
        | EventRegistrationRequestScalarWhereInput[];
    };

  export type EventCreateNestedOneWithoutRegistrationRequestsInput = {
    create?: XOR<
      EventCreateWithoutRegistrationRequestsInput,
      EventUncheckedCreateWithoutRegistrationRequestsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationRequestsInput;
    connect?: EventWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutRegistrationRequestsInput = {
    create?: XOR<
      UserCreateWithoutRegistrationRequestsInput,
      UserUncheckedCreateWithoutRegistrationRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRegistrationRequestsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumRegistrationRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RegistrationRequestStatus;
  };

  export type EventUpdateOneRequiredWithoutRegistrationRequestsNestedInput = {
    create?: XOR<
      EventCreateWithoutRegistrationRequestsInput,
      EventUncheckedCreateWithoutRegistrationRequestsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationRequestsInput;
    upsert?: EventUpsertWithoutRegistrationRequestsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutRegistrationRequestsInput,
        EventUpdateWithoutRegistrationRequestsInput
      >,
      EventUncheckedUpdateWithoutRegistrationRequestsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput = {
    create?: XOR<
      UserCreateWithoutRegistrationRequestsInput,
      UserUncheckedCreateWithoutRegistrationRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRegistrationRequestsInput;
    upsert?: UserUpsertWithoutRegistrationRequestsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRegistrationRequestsInput,
        UserUpdateWithoutRegistrationRequestsInput
      >,
      UserUncheckedUpdateWithoutRegistrationRequestsInput
    >;
  };

  export type EventCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput;
    connect?: EventWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutEventParticipantsInput = {
    create?: XOR<
      UserCreateWithoutEventParticipantsInput,
      UserUncheckedCreateWithoutEventParticipantsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipantsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumParticipantStatusFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantStatus;
  };

  export type EventUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutParticipantsInput;
    upsert?: EventUpsertWithoutParticipantsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutParticipantsInput,
        EventUpdateWithoutParticipantsInput
      >,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutEventParticipantsNestedInput = {
    create?: XOR<
      UserCreateWithoutEventParticipantsInput,
      UserUncheckedCreateWithoutEventParticipantsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEventParticipantsInput;
    upsert?: UserUpsertWithoutEventParticipantsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutEventParticipantsInput,
        UserUpdateWithoutEventParticipantsInput
      >,
      UserUncheckedUpdateWithoutEventParticipantsInput
    >;
  };

  export type EventCreateNestedOneWithoutSubmissionSchemaInput = {
    create?: XOR<
      EventCreateWithoutSubmissionSchemaInput,
      EventUncheckedCreateWithoutSubmissionSchemaInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionSchemaInput;
    connect?: EventWhereUniqueInput;
  };

  export type EventUpdateOneRequiredWithoutSubmissionSchemaNestedInput = {
    create?: XOR<
      EventCreateWithoutSubmissionSchemaInput,
      EventUncheckedCreateWithoutSubmissionSchemaInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionSchemaInput;
    upsert?: EventUpsertWithoutSubmissionSchemaInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutSubmissionSchemaInput,
        EventUpdateWithoutSubmissionSchemaInput
      >,
      EventUncheckedUpdateWithoutSubmissionSchemaInput
    >;
  };

  export type EventCreateNestedOneWithoutTeamsInput = {
    create?: XOR<
      EventCreateWithoutTeamsInput,
      EventUncheckedCreateWithoutTeamsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamsInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamAuditLogCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTeamInput,
          TeamAuditLogUncheckedCreateWithoutTeamInput
        >
      | TeamAuditLogCreateWithoutTeamInput[]
      | TeamAuditLogUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTeamInput
      | TeamAuditLogCreateOrConnectWithoutTeamInput[];
    createMany?: TeamAuditLogCreateManyTeamInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutTeamInput,
          TeamMemberUncheckedCreateWithoutTeamInput
        >
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type TeamInviteCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutTeamInput,
          TeamInviteUncheckedCreateWithoutTeamInput
        >
      | TeamInviteCreateWithoutTeamInput[]
      | TeamInviteUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutTeamInput
      | TeamInviteCreateOrConnectWithoutTeamInput[];
    createMany?: TeamInviteCreateManyTeamInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutTeamInput,
          TeamJoinRequestUncheckedCreateWithoutTeamInput
        >
      | TeamJoinRequestCreateWithoutTeamInput[]
      | TeamJoinRequestUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutTeamInput
      | TeamJoinRequestCreateOrConnectWithoutTeamInput[];
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type SubmissionCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutTeamInput,
          SubmissionUncheckedCreateWithoutTeamInput
        >
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTeamInput,
          TeamAuditLogUncheckedCreateWithoutTeamInput
        >
      | TeamAuditLogCreateWithoutTeamInput[]
      | TeamAuditLogUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTeamInput
      | TeamAuditLogCreateOrConnectWithoutTeamInput[];
    createMany?: TeamAuditLogCreateManyTeamInputEnvelope;
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutTeamInput,
          TeamMemberUncheckedCreateWithoutTeamInput
        >
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type TeamInviteUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutTeamInput,
          TeamInviteUncheckedCreateWithoutTeamInput
        >
      | TeamInviteCreateWithoutTeamInput[]
      | TeamInviteUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutTeamInput
      | TeamInviteCreateOrConnectWithoutTeamInput[];
    createMany?: TeamInviteCreateManyTeamInputEnvelope;
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
  };

  export type TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutTeamInput,
          TeamJoinRequestUncheckedCreateWithoutTeamInput
        >
      | TeamJoinRequestCreateWithoutTeamInput[]
      | TeamJoinRequestUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutTeamInput
      | TeamJoinRequestCreateOrConnectWithoutTeamInput[];
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope;
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutTeamInput,
          SubmissionUncheckedCreateWithoutTeamInput
        >
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type EventUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<
      EventCreateWithoutTeamsInput,
      EventUncheckedCreateWithoutTeamsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamsInput;
    upsert?: EventUpsertWithoutTeamsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutTeamsInput,
        EventUpdateWithoutTeamsInput
      >,
      EventUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type TeamAuditLogUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTeamInput,
          TeamAuditLogUncheckedCreateWithoutTeamInput
        >
      | TeamAuditLogCreateWithoutTeamInput[]
      | TeamAuditLogUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTeamInput
      | TeamAuditLogCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutTeamInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamAuditLogCreateManyTeamInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutTeamInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutTeamInput
      | TeamAuditLogUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutTeamInput,
          TeamMemberUncheckedCreateWithoutTeamInput
        >
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutTeamInput
      | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type TeamInviteUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutTeamInput,
          TeamInviteUncheckedCreateWithoutTeamInput
        >
      | TeamInviteCreateWithoutTeamInput[]
      | TeamInviteUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutTeamInput
      | TeamInviteCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutTeamInput
      | TeamInviteUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamInviteCreateManyTeamInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutTeamInput
      | TeamInviteUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutTeamInput
      | TeamInviteUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutTeamInput,
          TeamJoinRequestUncheckedCreateWithoutTeamInput
        >
      | TeamJoinRequestCreateWithoutTeamInput[]
      | TeamJoinRequestUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutTeamInput
      | TeamJoinRequestCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput
      | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type SubmissionUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutTeamInput,
          SubmissionUncheckedCreateWithoutTeamInput
        >
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTeamInput
      | SubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamAuditLogCreateWithoutTeamInput,
          TeamAuditLogUncheckedCreateWithoutTeamInput
        >
      | TeamAuditLogCreateWithoutTeamInput[]
      | TeamAuditLogUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamAuditLogCreateOrConnectWithoutTeamInput
      | TeamAuditLogCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamAuditLogUpsertWithWhereUniqueWithoutTeamInput
      | TeamAuditLogUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamAuditLogCreateManyTeamInputEnvelope;
    set?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    disconnect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    delete?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    connect?: TeamAuditLogWhereUniqueInput | TeamAuditLogWhereUniqueInput[];
    update?:
      | TeamAuditLogUpdateWithWhereUniqueWithoutTeamInput
      | TeamAuditLogUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamAuditLogUpdateManyWithWhereWithoutTeamInput
      | TeamAuditLogUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamMemberCreateWithoutTeamInput,
          TeamMemberUncheckedCreateWithoutTeamInput
        >
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutTeamInput
      | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type TeamInviteUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamInviteCreateWithoutTeamInput,
          TeamInviteUncheckedCreateWithoutTeamInput
        >
      | TeamInviteCreateWithoutTeamInput[]
      | TeamInviteUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamInviteCreateOrConnectWithoutTeamInput
      | TeamInviteCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamInviteUpsertWithWhereUniqueWithoutTeamInput
      | TeamInviteUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamInviteCreateManyTeamInputEnvelope;
    set?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    disconnect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    delete?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    connect?: TeamInviteWhereUniqueInput | TeamInviteWhereUniqueInput[];
    update?:
      | TeamInviteUpdateWithWhereUniqueWithoutTeamInput
      | TeamInviteUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamInviteUpdateManyWithWhereWithoutTeamInput
      | TeamInviteUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          TeamJoinRequestCreateWithoutTeamInput,
          TeamJoinRequestUncheckedCreateWithoutTeamInput
        >
      | TeamJoinRequestCreateWithoutTeamInput[]
      | TeamJoinRequestUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamJoinRequestCreateOrConnectWithoutTeamInput
      | TeamJoinRequestCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput
      | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope;
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[];
    disconnect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    delete?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    connect?:
      | TeamJoinRequestWhereUniqueInput
      | TeamJoinRequestWhereUniqueInput[];
    update?:
      | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput
      | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput
      | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?:
      | TeamJoinRequestScalarWhereInput
      | TeamJoinRequestScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          SubmissionCreateWithoutTeamInput,
          SubmissionUncheckedCreateWithoutTeamInput
        >
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTeamInput
      | SubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<
      TeamCreateWithoutMembersInput,
      TeamUncheckedCreateWithoutMembersInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<
      UserCreateWithoutTeamsInput,
      UserUncheckedCreateWithoutTeamsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole;
  };

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<
      TeamCreateWithoutMembersInput,
      TeamUncheckedCreateWithoutMembersInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
    upsert?: TeamUpsertWithoutMembersInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutMembersInput,
        TeamUpdateWithoutMembersInput
      >,
      TeamUncheckedUpdateWithoutMembersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamsInput,
      UserUncheckedCreateWithoutTeamsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
    upsert?: UserUpsertWithoutTeamsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamsInput,
        UserUpdateWithoutTeamsInput
      >,
      UserUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type EventCreateNestedOneWithoutTeamInvitesInput = {
    create?: XOR<
      EventCreateWithoutTeamInvitesInput,
      EventUncheckedCreateWithoutTeamInvitesInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamInvitesInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutInvitesInput = {
    create?: XOR<
      TeamCreateWithoutInvitesInput,
      TeamUncheckedCreateWithoutInvitesInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutInvitesInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamInvitesCreatedInput = {
    create?: XOR<
      UserCreateWithoutTeamInvitesCreatedInput,
      UserUncheckedCreateWithoutTeamInvitesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamInvitesCreatedInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus;
  };

  export type EventUpdateOneRequiredWithoutTeamInvitesNestedInput = {
    create?: XOR<
      EventCreateWithoutTeamInvitesInput,
      EventUncheckedCreateWithoutTeamInvitesInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamInvitesInput;
    upsert?: EventUpsertWithoutTeamInvitesInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutTeamInvitesInput,
        EventUpdateWithoutTeamInvitesInput
      >,
      EventUncheckedUpdateWithoutTeamInvitesInput
    >;
  };

  export type TeamUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<
      TeamCreateWithoutInvitesInput,
      TeamUncheckedCreateWithoutInvitesInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutInvitesInput;
    upsert?: TeamUpsertWithoutInvitesInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutInvitesInput,
        TeamUpdateWithoutInvitesInput
      >,
      TeamUncheckedUpdateWithoutInvitesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTeamInvitesCreatedNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamInvitesCreatedInput,
      UserUncheckedCreateWithoutTeamInvitesCreatedInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamInvitesCreatedInput;
    upsert?: UserUpsertWithoutTeamInvitesCreatedInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamInvitesCreatedInput,
        UserUpdateWithoutTeamInvitesCreatedInput
      >,
      UserUncheckedUpdateWithoutTeamInvitesCreatedInput
    >;
  };

  export type EventCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<
      EventCreateWithoutJoinRequestsInput,
      EventUncheckedCreateWithoutJoinRequestsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutJoinRequestsInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<
      TeamCreateWithoutJoinRequestsInput,
      TeamUncheckedCreateWithoutJoinRequestsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutJoinRequestsInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamJoinRequestsInput = {
    create?: XOR<
      UserCreateWithoutTeamJoinRequestsInput,
      UserUncheckedCreateWithoutTeamJoinRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamJoinRequestsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumJoinRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.JoinRequestStatus;
  };

  export type EventUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<
      EventCreateWithoutJoinRequestsInput,
      EventUncheckedCreateWithoutJoinRequestsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutJoinRequestsInput;
    upsert?: EventUpsertWithoutJoinRequestsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutJoinRequestsInput,
        EventUpdateWithoutJoinRequestsInput
      >,
      EventUncheckedUpdateWithoutJoinRequestsInput
    >;
  };

  export type TeamUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<
      TeamCreateWithoutJoinRequestsInput,
      TeamUncheckedCreateWithoutJoinRequestsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutJoinRequestsInput;
    upsert?: TeamUpsertWithoutJoinRequestsInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutJoinRequestsInput,
        TeamUpdateWithoutJoinRequestsInput
      >,
      TeamUncheckedUpdateWithoutJoinRequestsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamJoinRequestsInput,
      UserUncheckedCreateWithoutTeamJoinRequestsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamJoinRequestsInput;
    upsert?: UserUpsertWithoutTeamJoinRequestsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamJoinRequestsInput,
        UserUpdateWithoutTeamJoinRequestsInput
      >,
      UserUncheckedUpdateWithoutTeamJoinRequestsInput
    >;
  };

  export type EventCreateNestedOneWithoutTeamAuditLogsInput = {
    create?: XOR<
      EventCreateWithoutTeamAuditLogsInput,
      EventUncheckedCreateWithoutTeamAuditLogsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamAuditLogsInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      TeamCreateWithoutAuditLogsInput,
      TeamUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutAuditLogsInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamAuditActorInput = {
    create?: XOR<
      UserCreateWithoutTeamAuditActorInput,
      UserUncheckedCreateWithoutTeamAuditActorInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamAuditActorInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamAuditTargetInput = {
    create?: XOR<
      UserCreateWithoutTeamAuditTargetInput,
      UserUncheckedCreateWithoutTeamAuditTargetInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamAuditTargetInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumTeamAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.TeamAuditAction;
  };

  export type EventUpdateOneRequiredWithoutTeamAuditLogsNestedInput = {
    create?: XOR<
      EventCreateWithoutTeamAuditLogsInput,
      EventUncheckedCreateWithoutTeamAuditLogsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutTeamAuditLogsInput;
    upsert?: EventUpsertWithoutTeamAuditLogsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutTeamAuditLogsInput,
        EventUpdateWithoutTeamAuditLogsInput
      >,
      EventUncheckedUpdateWithoutTeamAuditLogsInput
    >;
  };

  export type TeamUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      TeamCreateWithoutAuditLogsInput,
      TeamUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutAuditLogsInput;
    upsert?: TeamUpsertWithoutAuditLogsInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutAuditLogsInput,
        TeamUpdateWithoutAuditLogsInput
      >,
      TeamUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type UserUpdateOneWithoutTeamAuditActorNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamAuditActorInput,
      UserUncheckedCreateWithoutTeamAuditActorInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamAuditActorInput;
    upsert?: UserUpsertWithoutTeamAuditActorInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamAuditActorInput,
        UserUpdateWithoutTeamAuditActorInput
      >,
      UserUncheckedUpdateWithoutTeamAuditActorInput
    >;
  };

  export type UserUpdateOneWithoutTeamAuditTargetNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamAuditTargetInput,
      UserUncheckedCreateWithoutTeamAuditTargetInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamAuditTargetInput;
    upsert?: UserUpsertWithoutTeamAuditTargetInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamAuditTargetInput,
        UserUpdateWithoutTeamAuditTargetInput
      >,
      UserUncheckedUpdateWithoutTeamAuditTargetInput
    >;
  };

  export type EventCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<
      EventCreateWithoutSubmissionsInput,
      EventUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionsInput;
    connect?: EventWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<
      TeamCreateWithoutSubmissionsInput,
      TeamUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<
      UserCreateWithoutSubmissionsInput,
      UserUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type ScoreCreateNestedManyWithoutSubmissionInput = {
    create?:
      | XOR<
          ScoreCreateWithoutSubmissionInput,
          ScoreUncheckedCreateWithoutSubmissionInput
        >
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type ScoreUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?:
      | XOR<
          ScoreCreateWithoutSubmissionInput,
          ScoreUncheckedCreateWithoutSubmissionInput
        >
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus;
  };

  export type EventUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<
      EventCreateWithoutSubmissionsInput,
      EventUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionsInput;
    upsert?: EventUpsertWithoutSubmissionsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutSubmissionsInput,
        EventUpdateWithoutSubmissionsInput
      >,
      EventUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type TeamUpdateOneWithoutSubmissionsNestedInput = {
    create?: XOR<
      TeamCreateWithoutSubmissionsInput,
      TeamUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput;
    upsert?: TeamUpsertWithoutSubmissionsInput;
    disconnect?: TeamWhereInput | boolean;
    delete?: TeamWhereInput | boolean;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutSubmissionsInput,
        TeamUpdateWithoutSubmissionsInput
      >,
      TeamUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type UserUpdateOneWithoutSubmissionsNestedInput = {
    create?: XOR<
      UserCreateWithoutSubmissionsInput,
      UserUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput;
    upsert?: UserUpsertWithoutSubmissionsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSubmissionsInput,
        UserUpdateWithoutSubmissionsInput
      >,
      UserUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type ScoreUpdateManyWithoutSubmissionNestedInput = {
    create?:
      | XOR<
          ScoreCreateWithoutSubmissionInput,
          ScoreUncheckedCreateWithoutSubmissionInput
        >
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutSubmissionInput
      | ScoreUpdateManyWithWhereWithoutSubmissionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type ScoreUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?:
      | XOR<
          ScoreCreateWithoutSubmissionInput,
          ScoreUncheckedCreateWithoutSubmissionInput
        >
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutSubmissionInput
      | ScoreUpdateManyWithWhereWithoutSubmissionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type EventCreateNestedOneWithoutJudgeAssignmentsInput = {
    create?: XOR<
      EventCreateWithoutJudgeAssignmentsInput,
      EventUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutJudgeAssignmentsInput;
    connect?: EventWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutJudgeLinksInput = {
    create?: XOR<
      UserCreateWithoutJudgeLinksInput,
      UserUncheckedCreateWithoutJudgeLinksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutJudgeLinksInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumJudgeRoleFieldUpdateOperationsInput = {
    set?: $Enums.JudgeRole;
  };

  export type EventUpdateOneRequiredWithoutJudgeAssignmentsNestedInput = {
    create?: XOR<
      EventCreateWithoutJudgeAssignmentsInput,
      EventUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutJudgeAssignmentsInput;
    upsert?: EventUpsertWithoutJudgeAssignmentsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutJudgeAssignmentsInput,
        EventUpdateWithoutJudgeAssignmentsInput
      >,
      EventUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutJudgeLinksNestedInput = {
    create?: XOR<
      UserCreateWithoutJudgeLinksInput,
      UserUncheckedCreateWithoutJudgeLinksInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutJudgeLinksInput;
    upsert?: UserUpsertWithoutJudgeLinksInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutJudgeLinksInput,
        UserUpdateWithoutJudgeLinksInput
      >,
      UserUncheckedUpdateWithoutJudgeLinksInput
    >;
  };

  export type SubmissionCreateNestedOneWithoutScoresInput = {
    create?: XOR<
      SubmissionCreateWithoutScoresInput,
      SubmissionUncheckedCreateWithoutScoresInput
    >;
    connectOrCreate?: SubmissionCreateOrConnectWithoutScoresInput;
    connect?: SubmissionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutScoresGivenInput = {
    create?: XOR<
      UserCreateWithoutScoresGivenInput,
      UserUncheckedCreateWithoutScoresGivenInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutScoresGivenInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type SubmissionUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<
      SubmissionCreateWithoutScoresInput,
      SubmissionUncheckedCreateWithoutScoresInput
    >;
    connectOrCreate?: SubmissionCreateOrConnectWithoutScoresInput;
    upsert?: SubmissionUpsertWithoutScoresInput;
    connect?: SubmissionWhereUniqueInput;
    update?: XOR<
      XOR<
        SubmissionUpdateToOneWithWhereWithoutScoresInput,
        SubmissionUpdateWithoutScoresInput
      >,
      SubmissionUncheckedUpdateWithoutScoresInput
    >;
  };

  export type UserUpdateOneRequiredWithoutScoresGivenNestedInput = {
    create?: XOR<
      UserCreateWithoutScoresGivenInput,
      UserUncheckedCreateWithoutScoresGivenInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutScoresGivenInput;
    upsert?: UserUpsertWithoutScoresGivenInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutScoresGivenInput,
        UserUpdateWithoutScoresGivenInput
      >,
      UserUncheckedUpdateWithoutScoresGivenInput
    >;
  };

  export type EventCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<
      EventCreateWithoutAnnouncementsInput,
      EventUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutAnnouncementsInput;
    connect?: EventWhereUniqueInput;
  };

  export type EventUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<
      EventCreateWithoutAnnouncementsInput,
      EventUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: EventCreateOrConnectWithoutAnnouncementsInput;
    upsert?: EventUpsertWithoutAnnouncementsInput;
    connect?: EventWhereUniqueInput;
    update?: XOR<
      XOR<
        EventUpdateToOneWithWhereWithoutAnnouncementsInput,
        EventUpdateWithoutAnnouncementsInput
      >,
      EventUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[];
    notIn?: string[];
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | null;
    notIn?: string[] | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    search?: string;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[];
    notIn?: Date[] | string[];
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.OrgRole[];
    notIn?: $Enums.OrgRole[];
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole;
  };

  export type NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.OrgRole[];
    notIn?: $Enums.OrgRole[];
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>;
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>;
  };

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[];
    notIn?: $Enums.EventType[];
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType;
  };

  export type NestedEnumEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.EventStatus[];
    notIn?: $Enums.EventStatus[];
    not?: NestedEnumEventStatusFilter<$PrismaModel> | $Enums.EventStatus;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | null;
    notIn?: Date[] | string[] | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumEventVisibilityFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventVisibility
      | EnumEventVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.EventVisibility[];
    notIn?: $Enums.EventVisibility[];
    not?:
      | NestedEnumEventVisibilityFilter<$PrismaModel>
      | $Enums.EventVisibility;
  };

  export type NestedEnumEventJoinModeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.EventJoinMode
      | EnumEventJoinModeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventJoinMode[];
    notIn?: $Enums.EventJoinMode[];
    not?: NestedEnumEventJoinModeFilter<$PrismaModel> | $Enums.EventJoinMode;
  };

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventType[];
    notIn?: $Enums.EventType[];
    not?:
      | NestedEnumEventTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventTypeFilter<$PrismaModel>;
    _max?: NestedEnumEventTypeFilter<$PrismaModel>;
  };

  export type NestedEnumEventStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.EventStatus | EnumEventStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.EventStatus[];
      notIn?: $Enums.EventStatus[];
      not?:
        | NestedEnumEventStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.EventStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumEventStatusFilter<$PrismaModel>;
      _max?: NestedEnumEventStatusFilter<$PrismaModel>;
    };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            "path"
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumEventVisibilityWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.EventVisibility
      | EnumEventVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.EventVisibility[];
    notIn?: $Enums.EventVisibility[];
    not?:
      | NestedEnumEventVisibilityWithAggregatesFilter<$PrismaModel>
      | $Enums.EventVisibility;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventVisibilityFilter<$PrismaModel>;
    _max?: NestedEnumEventVisibilityFilter<$PrismaModel>;
  };

  export type NestedEnumEventJoinModeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.EventJoinMode
      | EnumEventJoinModeFieldRefInput<$PrismaModel>;
    in?: $Enums.EventJoinMode[];
    notIn?: $Enums.EventJoinMode[];
    not?:
      | NestedEnumEventJoinModeWithAggregatesFilter<$PrismaModel>
      | $Enums.EventJoinMode;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumEventJoinModeFilter<$PrismaModel>;
    _max?: NestedEnumEventJoinModeFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[];
    notIn?: number[];
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumRegistrationRequestStatusFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.RegistrationRequestStatus
        | EnumRegistrationRequestStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.RegistrationRequestStatus[];
      notIn?: $Enums.RegistrationRequestStatus[];
      not?:
        | NestedEnumRegistrationRequestStatusFilter<$PrismaModel>
        | $Enums.RegistrationRequestStatus;
    };

  export type NestedEnumRegistrationRequestStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.RegistrationRequestStatus
      | EnumRegistrationRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.RegistrationRequestStatus[];
    notIn?: $Enums.RegistrationRequestStatus[];
    not?:
      | NestedEnumRegistrationRequestStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.RegistrationRequestStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRegistrationRequestStatusFilter<$PrismaModel>;
    _max?: NestedEnumRegistrationRequestStatusFilter<$PrismaModel>;
  };

  export type NestedEnumParticipantStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ParticipantStatus
      | EnumParticipantStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ParticipantStatus[];
    notIn?: $Enums.ParticipantStatus[];
    not?:
      | NestedEnumParticipantStatusFilter<$PrismaModel>
      | $Enums.ParticipantStatus;
  };

  export type NestedEnumParticipantStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ParticipantStatus
      | EnumParticipantStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ParticipantStatus[];
    notIn?: $Enums.ParticipantStatus[];
    not?:
      | NestedEnumParticipantStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ParticipantStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumParticipantStatusFilter<$PrismaModel>;
    _max?: NestedEnumParticipantStatusFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string;
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue;
    lte?: InputJsonValue;
    gt?: InputJsonValue;
    gte?: InputJsonValue;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamRole[];
    notIn?: $Enums.TeamRole[];
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole;
  };

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamRole[];
    notIn?: $Enums.TeamRole[];
    not?:
      | NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.TeamRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>;
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>;
  };

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InviteStatus[];
    notIn?: $Enums.InviteStatus[];
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus;
  };

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.InviteStatus
        | EnumInviteStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.InviteStatus[];
      notIn?: $Enums.InviteStatus[];
      not?:
        | NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.InviteStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumInviteStatusFilter<$PrismaModel>;
      _max?: NestedEnumInviteStatusFilter<$PrismaModel>;
    };

  export type NestedEnumJoinRequestStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.JoinRequestStatus
      | EnumJoinRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.JoinRequestStatus[];
    notIn?: $Enums.JoinRequestStatus[];
    not?:
      | NestedEnumJoinRequestStatusFilter<$PrismaModel>
      | $Enums.JoinRequestStatus;
  };

  export type NestedEnumJoinRequestStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.JoinRequestStatus
      | EnumJoinRequestStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.JoinRequestStatus[];
    notIn?: $Enums.JoinRequestStatus[];
    not?:
      | NestedEnumJoinRequestStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.JoinRequestStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumJoinRequestStatusFilter<$PrismaModel>;
    _max?: NestedEnumJoinRequestStatusFilter<$PrismaModel>;
  };

  export type NestedEnumTeamAuditActionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.TeamAuditAction
      | EnumTeamAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamAuditAction[];
    notIn?: $Enums.TeamAuditAction[];
    not?:
      | NestedEnumTeamAuditActionFilter<$PrismaModel>
      | $Enums.TeamAuditAction;
  };

  export type NestedEnumTeamAuditActionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.TeamAuditAction
      | EnumTeamAuditActionFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamAuditAction[];
    notIn?: $Enums.TeamAuditAction[];
    not?:
      | NestedEnumTeamAuditActionWithAggregatesFilter<$PrismaModel>
      | $Enums.TeamAuditAction;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamAuditActionFilter<$PrismaModel>;
    _max?: NestedEnumTeamAuditActionFilter<$PrismaModel>;
  };

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubmissionStatus
      | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[];
    notIn?: $Enums.SubmissionStatus[];
    not?:
      | NestedEnumSubmissionStatusFilter<$PrismaModel>
      | $Enums.SubmissionStatus;
  };

  export type NestedEnumSubmissionStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SubmissionStatus
      | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[];
    notIn?: $Enums.SubmissionStatus[];
    not?:
      | NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
  };

  export type NestedEnumJudgeRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.JudgeRole | EnumJudgeRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.JudgeRole[];
    notIn?: $Enums.JudgeRole[];
    not?: NestedEnumJudgeRoleFilter<$PrismaModel> | $Enums.JudgeRole;
  };

  export type NestedEnumJudgeRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JudgeRole | EnumJudgeRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.JudgeRole[];
    notIn?: $Enums.JudgeRole[];
    not?:
      | NestedEnumJudgeRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.JudgeRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumJudgeRoleFilter<$PrismaModel>;
    _max?: NestedEnumJudgeRoleFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | null;
    notIn?: number[] | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type OrgMembershipCreateWithoutUserInput = {
    id?: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutMembershipsInput;
  };

  export type OrgMembershipUncheckedCreateWithoutUserInput = {
    id?: string;
    orgId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type OrgMembershipCreateOrConnectWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput;
    create: XOR<
      OrgMembershipCreateWithoutUserInput,
      OrgMembershipUncheckedCreateWithoutUserInput
    >;
  };

  export type OrgMembershipCreateManyUserInputEnvelope = {
    data: OrgMembershipCreateManyUserInput | OrgMembershipCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type EventParticipantCreateWithoutUserInput = {
    id?: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutParticipantsInput;
  };

  export type EventParticipantUncheckedCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventParticipantCreateOrConnectWithoutUserInput = {
    where: EventParticipantWhereUniqueInput;
    create: XOR<
      EventParticipantCreateWithoutUserInput,
      EventParticipantUncheckedCreateWithoutUserInput
    >;
  };

  export type EventParticipantCreateManyUserInputEnvelope = {
    data:
      | EventParticipantCreateManyUserInput
      | EventParticipantCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TeamMemberCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    role?: $Enums.TeamRole;
    team: TeamCreateNestedOneWithoutMembersInput;
  };

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    role?: $Enums.TeamRole;
  };

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<
      TeamMemberCreateWithoutUserInput,
      TeamMemberUncheckedCreateWithoutUserInput
    >;
  };

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SubmissionCreateWithoutAuthorInput = {
    id?: string;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    event: EventCreateNestedOneWithoutSubmissionsInput;
    team?: TeamCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutAuthorInput = {
    id?: string;
    eventId: string;
    teamId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutAuthorInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<
      SubmissionCreateWithoutAuthorInput,
      SubmissionUncheckedCreateWithoutAuthorInput
    >;
  };

  export type SubmissionCreateManyAuthorInputEnvelope = {
    data: SubmissionCreateManyAuthorInput | SubmissionCreateManyAuthorInput[];
    skipDuplicates?: boolean;
  };

  export type JudgeAssignmentCreateWithoutUserInput = {
    id?: string;
    role?: $Enums.JudgeRole;
    event: EventCreateNestedOneWithoutJudgeAssignmentsInput;
  };

  export type JudgeAssignmentUncheckedCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    role?: $Enums.JudgeRole;
  };

  export type JudgeAssignmentCreateOrConnectWithoutUserInput = {
    where: JudgeAssignmentWhereUniqueInput;
    create: XOR<
      JudgeAssignmentCreateWithoutUserInput,
      JudgeAssignmentUncheckedCreateWithoutUserInput
    >;
  };

  export type JudgeAssignmentCreateManyUserInputEnvelope = {
    data:
      | JudgeAssignmentCreateManyUserInput
      | JudgeAssignmentCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TeamInviteCreateWithoutCreatorInput = {
    id?: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
    event: EventCreateNestedOneWithoutTeamInvitesInput;
    team: TeamCreateNestedOneWithoutInvitesInput;
  };

  export type TeamInviteUncheckedCreateWithoutCreatorInput = {
    id?: string;
    eventId: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamInviteCreateOrConnectWithoutCreatorInput = {
    where: TeamInviteWhereUniqueInput;
    create: XOR<
      TeamInviteCreateWithoutCreatorInput,
      TeamInviteUncheckedCreateWithoutCreatorInput
    >;
  };

  export type TeamInviteCreateManyCreatorInputEnvelope = {
    data: TeamInviteCreateManyCreatorInput | TeamInviteCreateManyCreatorInput[];
    skipDuplicates?: boolean;
  };

  export type TeamJoinRequestCreateWithoutUserInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutJoinRequestsInput;
    team: TeamCreateNestedOneWithoutJoinRequestsInput;
  };

  export type TeamJoinRequestUncheckedCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamJoinRequestCreateOrConnectWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput;
    create: XOR<
      TeamJoinRequestCreateWithoutUserInput,
      TeamJoinRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type TeamJoinRequestCreateManyUserInputEnvelope = {
    data:
      | TeamJoinRequestCreateManyUserInput
      | TeamJoinRequestCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type TeamAuditLogCreateWithoutActorInput = {
    id?: string;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamAuditLogsInput;
    team: TeamCreateNestedOneWithoutAuditLogsInput;
    targetUser?: UserCreateNestedOneWithoutTeamAuditTargetInput;
  };

  export type TeamAuditLogUncheckedCreateWithoutActorInput = {
    id?: string;
    eventId: string;
    teamId: string;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogCreateOrConnectWithoutActorInput = {
    where: TeamAuditLogWhereUniqueInput;
    create: XOR<
      TeamAuditLogCreateWithoutActorInput,
      TeamAuditLogUncheckedCreateWithoutActorInput
    >;
  };

  export type TeamAuditLogCreateManyActorInputEnvelope = {
    data: TeamAuditLogCreateManyActorInput | TeamAuditLogCreateManyActorInput[];
    skipDuplicates?: boolean;
  };

  export type TeamAuditLogCreateWithoutTargetUserInput = {
    id?: string;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamAuditLogsInput;
    team: TeamCreateNestedOneWithoutAuditLogsInput;
    actor?: UserCreateNestedOneWithoutTeamAuditActorInput;
  };

  export type TeamAuditLogUncheckedCreateWithoutTargetUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    actorId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogCreateOrConnectWithoutTargetUserInput = {
    where: TeamAuditLogWhereUniqueInput;
    create: XOR<
      TeamAuditLogCreateWithoutTargetUserInput,
      TeamAuditLogUncheckedCreateWithoutTargetUserInput
    >;
  };

  export type TeamAuditLogCreateManyTargetUserInputEnvelope = {
    data:
      | TeamAuditLogCreateManyTargetUserInput
      | TeamAuditLogCreateManyTargetUserInput[];
    skipDuplicates?: boolean;
  };

  export type ScoreCreateWithoutJudgeInput = {
    id?: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submission: SubmissionCreateNestedOneWithoutScoresInput;
  };

  export type ScoreUncheckedCreateWithoutJudgeInput = {
    id?: string;
    submissionId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreCreateOrConnectWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    create: XOR<
      ScoreCreateWithoutJudgeInput,
      ScoreUncheckedCreateWithoutJudgeInput
    >;
  };

  export type ScoreCreateManyJudgeInputEnvelope = {
    data: ScoreCreateManyJudgeInput | ScoreCreateManyJudgeInput[];
    skipDuplicates?: boolean;
  };

  export type EventRegistrationRequestCreateWithoutUserInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
    event: EventCreateNestedOneWithoutRegistrationRequestsInput;
  };

  export type EventRegistrationRequestUncheckedCreateWithoutUserInput = {
    id?: string;
    eventId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type EventRegistrationRequestCreateOrConnectWithoutUserInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    create: XOR<
      EventRegistrationRequestCreateWithoutUserInput,
      EventRegistrationRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type EventRegistrationRequestCreateManyUserInputEnvelope = {
    data:
      | EventRegistrationRequestCreateManyUserInput
      | EventRegistrationRequestCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type OrgMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput;
    update: XOR<
      OrgMembershipUpdateWithoutUserInput,
      OrgMembershipUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      OrgMembershipCreateWithoutUserInput,
      OrgMembershipUncheckedCreateWithoutUserInput
    >;
  };

  export type OrgMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: OrgMembershipWhereUniqueInput;
    data: XOR<
      OrgMembershipUpdateWithoutUserInput,
      OrgMembershipUncheckedUpdateWithoutUserInput
    >;
  };

  export type OrgMembershipUpdateManyWithWhereWithoutUserInput = {
    where: OrgMembershipScalarWhereInput;
    data: XOR<
      OrgMembershipUpdateManyMutationInput,
      OrgMembershipUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type OrgMembershipScalarWhereInput = {
    AND?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[];
    OR?: OrgMembershipScalarWhereInput[];
    NOT?: OrgMembershipScalarWhereInput | OrgMembershipScalarWhereInput[];
    id?: StringFilter<"OrgMembership"> | string;
    orgId?: StringFilter<"OrgMembership"> | string;
    userId?: StringFilter<"OrgMembership"> | string;
    role?: EnumOrgRoleFilter<"OrgMembership"> | $Enums.OrgRole;
    createdAt?: DateTimeFilter<"OrgMembership"> | Date | string;
  };

  export type EventParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: EventParticipantWhereUniqueInput;
    update: XOR<
      EventParticipantUpdateWithoutUserInput,
      EventParticipantUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      EventParticipantCreateWithoutUserInput,
      EventParticipantUncheckedCreateWithoutUserInput
    >;
  };

  export type EventParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: EventParticipantWhereUniqueInput;
    data: XOR<
      EventParticipantUpdateWithoutUserInput,
      EventParticipantUncheckedUpdateWithoutUserInput
    >;
  };

  export type EventParticipantUpdateManyWithWhereWithoutUserInput = {
    where: EventParticipantScalarWhereInput;
    data: XOR<
      EventParticipantUpdateManyMutationInput,
      EventParticipantUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type EventParticipantScalarWhereInput = {
    AND?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[];
    OR?: EventParticipantScalarWhereInput[];
    NOT?: EventParticipantScalarWhereInput | EventParticipantScalarWhereInput[];
    id?: StringFilter<"EventParticipant"> | string;
    eventId?: StringFilter<"EventParticipant"> | string;
    userId?: StringFilter<"EventParticipant"> | string;
    status?:
      | EnumParticipantStatusFilter<"EventParticipant">
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFilter<"EventParticipant"> | boolean;
    contactEmail?: StringNullableFilter<"EventParticipant"> | string | null;
    lookingForTeam?: BoolFilter<"EventParticipant"> | boolean;
    trackPreference?: StringNullableFilter<"EventParticipant"> | string | null;
    skills?: JsonNullableFilter<"EventParticipant">;
    interests?: JsonNullableFilter<"EventParticipant">;
    experienceLevel?: StringNullableFilter<"EventParticipant"> | string | null;
    createdAt?: DateTimeFilter<"EventParticipant"> | Date | string;
    updatedAt?: DateTimeFilter<"EventParticipant"> | Date | string;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<
      TeamMemberUpdateWithoutUserInput,
      TeamMemberUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TeamMemberCreateWithoutUserInput,
      TeamMemberUncheckedCreateWithoutUserInput
    >;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<
      TeamMemberUpdateWithoutUserInput,
      TeamMemberUncheckedUpdateWithoutUserInput
    >;
  };

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<
      TeamMemberUpdateManyMutationInput,
      TeamMemberUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    OR?: TeamMemberScalarWhereInput[];
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    id?: StringFilter<"TeamMember"> | string;
    eventId?: StringFilter<"TeamMember"> | string;
    teamId?: StringFilter<"TeamMember"> | string;
    userId?: StringFilter<"TeamMember"> | string;
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<
      SubmissionUpdateWithoutAuthorInput,
      SubmissionUncheckedUpdateWithoutAuthorInput
    >;
    create: XOR<
      SubmissionCreateWithoutAuthorInput,
      SubmissionUncheckedCreateWithoutAuthorInput
    >;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<
      SubmissionUpdateWithoutAuthorInput,
      SubmissionUncheckedUpdateWithoutAuthorInput
    >;
  };

  export type SubmissionUpdateManyWithWhereWithoutAuthorInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<
      SubmissionUpdateManyMutationInput,
      SubmissionUncheckedUpdateManyWithoutAuthorInput
    >;
  };

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
    OR?: SubmissionScalarWhereInput[];
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
    id?: StringFilter<"Submission"> | string;
    eventId?: StringFilter<"Submission"> | string;
    teamId?: StringNullableFilter<"Submission"> | string | null;
    authorId?: StringNullableFilter<"Submission"> | string | null;
    status?: EnumSubmissionStatusFilter<"Submission"> | $Enums.SubmissionStatus;
    title?: StringFilter<"Submission"> | string;
    description?: StringNullableFilter<"Submission"> | string | null;
    content?: JsonNullableFilter<"Submission">;
    imageUrls?: JsonNullableFilter<"Submission">;
    videoUrl?: StringNullableFilter<"Submission"> | string | null;
    createdAt?: DateTimeFilter<"Submission"> | Date | string;
    updatedAt?: DateTimeFilter<"Submission"> | Date | string;
    submittedAt?: DateTimeNullableFilter<"Submission"> | Date | string | null;
  };

  export type JudgeAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: JudgeAssignmentWhereUniqueInput;
    update: XOR<
      JudgeAssignmentUpdateWithoutUserInput,
      JudgeAssignmentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      JudgeAssignmentCreateWithoutUserInput,
      JudgeAssignmentUncheckedCreateWithoutUserInput
    >;
  };

  export type JudgeAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: JudgeAssignmentWhereUniqueInput;
    data: XOR<
      JudgeAssignmentUpdateWithoutUserInput,
      JudgeAssignmentUncheckedUpdateWithoutUserInput
    >;
  };

  export type JudgeAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: JudgeAssignmentScalarWhereInput;
    data: XOR<
      JudgeAssignmentUpdateManyMutationInput,
      JudgeAssignmentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type JudgeAssignmentScalarWhereInput = {
    AND?: JudgeAssignmentScalarWhereInput | JudgeAssignmentScalarWhereInput[];
    OR?: JudgeAssignmentScalarWhereInput[];
    NOT?: JudgeAssignmentScalarWhereInput | JudgeAssignmentScalarWhereInput[];
    id?: StringFilter<"JudgeAssignment"> | string;
    eventId?: StringFilter<"JudgeAssignment"> | string;
    userId?: StringFilter<"JudgeAssignment"> | string;
    role?: EnumJudgeRoleFilter<"JudgeAssignment"> | $Enums.JudgeRole;
  };

  export type TeamInviteUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TeamInviteWhereUniqueInput;
    update: XOR<
      TeamInviteUpdateWithoutCreatorInput,
      TeamInviteUncheckedUpdateWithoutCreatorInput
    >;
    create: XOR<
      TeamInviteCreateWithoutCreatorInput,
      TeamInviteUncheckedCreateWithoutCreatorInput
    >;
  };

  export type TeamInviteUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TeamInviteWhereUniqueInput;
    data: XOR<
      TeamInviteUpdateWithoutCreatorInput,
      TeamInviteUncheckedUpdateWithoutCreatorInput
    >;
  };

  export type TeamInviteUpdateManyWithWhereWithoutCreatorInput = {
    where: TeamInviteScalarWhereInput;
    data: XOR<
      TeamInviteUpdateManyMutationInput,
      TeamInviteUncheckedUpdateManyWithoutCreatorInput
    >;
  };

  export type TeamInviteScalarWhereInput = {
    AND?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
    OR?: TeamInviteScalarWhereInput[];
    NOT?: TeamInviteScalarWhereInput | TeamInviteScalarWhereInput[];
    id?: StringFilter<"TeamInvite"> | string;
    eventId?: StringFilter<"TeamInvite"> | string;
    teamId?: StringFilter<"TeamInvite"> | string;
    email?: StringFilter<"TeamInvite"> | string;
    token?: StringFilter<"TeamInvite"> | string;
    status?: EnumInviteStatusFilter<"TeamInvite"> | $Enums.InviteStatus;
    message?: StringNullableFilter<"TeamInvite"> | string | null;
    createdByUserId?: StringFilter<"TeamInvite"> | string;
    createdAt?: DateTimeFilter<"TeamInvite"> | Date | string;
    expiresAt?: DateTimeNullableFilter<"TeamInvite"> | Date | string | null;
  };

  export type TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput;
    update: XOR<
      TeamJoinRequestUpdateWithoutUserInput,
      TeamJoinRequestUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      TeamJoinRequestCreateWithoutUserInput,
      TeamJoinRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput;
    data: XOR<
      TeamJoinRequestUpdateWithoutUserInput,
      TeamJoinRequestUncheckedUpdateWithoutUserInput
    >;
  };

  export type TeamJoinRequestUpdateManyWithWhereWithoutUserInput = {
    where: TeamJoinRequestScalarWhereInput;
    data: XOR<
      TeamJoinRequestUpdateManyMutationInput,
      TeamJoinRequestUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type TeamJoinRequestScalarWhereInput = {
    AND?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[];
    OR?: TeamJoinRequestScalarWhereInput[];
    NOT?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[];
    id?: StringFilter<"TeamJoinRequest"> | string;
    eventId?: StringFilter<"TeamJoinRequest"> | string;
    teamId?: StringFilter<"TeamJoinRequest"> | string;
    userId?: StringFilter<"TeamJoinRequest"> | string;
    message?: StringNullableFilter<"TeamJoinRequest"> | string | null;
    status?:
      | EnumJoinRequestStatusFilter<"TeamJoinRequest">
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
    updatedAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string;
  };

  export type TeamAuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: TeamAuditLogWhereUniqueInput;
    update: XOR<
      TeamAuditLogUpdateWithoutActorInput,
      TeamAuditLogUncheckedUpdateWithoutActorInput
    >;
    create: XOR<
      TeamAuditLogCreateWithoutActorInput,
      TeamAuditLogUncheckedCreateWithoutActorInput
    >;
  };

  export type TeamAuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: TeamAuditLogWhereUniqueInput;
    data: XOR<
      TeamAuditLogUpdateWithoutActorInput,
      TeamAuditLogUncheckedUpdateWithoutActorInput
    >;
  };

  export type TeamAuditLogUpdateManyWithWhereWithoutActorInput = {
    where: TeamAuditLogScalarWhereInput;
    data: XOR<
      TeamAuditLogUpdateManyMutationInput,
      TeamAuditLogUncheckedUpdateManyWithoutActorInput
    >;
  };

  export type TeamAuditLogScalarWhereInput = {
    AND?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
    OR?: TeamAuditLogScalarWhereInput[];
    NOT?: TeamAuditLogScalarWhereInput | TeamAuditLogScalarWhereInput[];
    id?: StringFilter<"TeamAuditLog"> | string;
    eventId?: StringFilter<"TeamAuditLog"> | string;
    teamId?: StringFilter<"TeamAuditLog"> | string;
    actorId?: StringNullableFilter<"TeamAuditLog"> | string | null;
    targetUserId?: StringNullableFilter<"TeamAuditLog"> | string | null;
    action?: EnumTeamAuditActionFilter<"TeamAuditLog"> | $Enums.TeamAuditAction;
    meta?: JsonNullableFilter<"TeamAuditLog">;
    createdAt?: DateTimeFilter<"TeamAuditLog"> | Date | string;
  };

  export type TeamAuditLogUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: TeamAuditLogWhereUniqueInput;
    update: XOR<
      TeamAuditLogUpdateWithoutTargetUserInput,
      TeamAuditLogUncheckedUpdateWithoutTargetUserInput
    >;
    create: XOR<
      TeamAuditLogCreateWithoutTargetUserInput,
      TeamAuditLogUncheckedCreateWithoutTargetUserInput
    >;
  };

  export type TeamAuditLogUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: TeamAuditLogWhereUniqueInput;
    data: XOR<
      TeamAuditLogUpdateWithoutTargetUserInput,
      TeamAuditLogUncheckedUpdateWithoutTargetUserInput
    >;
  };

  export type TeamAuditLogUpdateManyWithWhereWithoutTargetUserInput = {
    where: TeamAuditLogScalarWhereInput;
    data: XOR<
      TeamAuditLogUpdateManyMutationInput,
      TeamAuditLogUncheckedUpdateManyWithoutTargetUserInput
    >;
  };

  export type ScoreUpsertWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    update: XOR<
      ScoreUpdateWithoutJudgeInput,
      ScoreUncheckedUpdateWithoutJudgeInput
    >;
    create: XOR<
      ScoreCreateWithoutJudgeInput,
      ScoreUncheckedCreateWithoutJudgeInput
    >;
  };

  export type ScoreUpdateWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    data: XOR<
      ScoreUpdateWithoutJudgeInput,
      ScoreUncheckedUpdateWithoutJudgeInput
    >;
  };

  export type ScoreUpdateManyWithWhereWithoutJudgeInput = {
    where: ScoreScalarWhereInput;
    data: XOR<
      ScoreUpdateManyMutationInput,
      ScoreUncheckedUpdateManyWithoutJudgeInput
    >;
  };

  export type ScoreScalarWhereInput = {
    AND?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
    OR?: ScoreScalarWhereInput[];
    NOT?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
    id?: StringFilter<"Score"> | string;
    submissionId?: StringFilter<"Score"> | string;
    judgeId?: StringFilter<"Score"> | string;
    total?: FloatNullableFilter<"Score"> | number | null;
    breakdown?: JsonNullableFilter<"Score">;
    feedback?: StringNullableFilter<"Score"> | string | null;
    createdAt?: DateTimeFilter<"Score"> | Date | string;
    updatedAt?: DateTimeFilter<"Score"> | Date | string;
  };

  export type EventRegistrationRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    update: XOR<
      EventRegistrationRequestUpdateWithoutUserInput,
      EventRegistrationRequestUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      EventRegistrationRequestCreateWithoutUserInput,
      EventRegistrationRequestUncheckedCreateWithoutUserInput
    >;
  };

  export type EventRegistrationRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    data: XOR<
      EventRegistrationRequestUpdateWithoutUserInput,
      EventRegistrationRequestUncheckedUpdateWithoutUserInput
    >;
  };

  export type EventRegistrationRequestUpdateManyWithWhereWithoutUserInput = {
    where: EventRegistrationRequestScalarWhereInput;
    data: XOR<
      EventRegistrationRequestUpdateManyMutationInput,
      EventRegistrationRequestUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type EventRegistrationRequestScalarWhereInput = {
    AND?:
      | EventRegistrationRequestScalarWhereInput
      | EventRegistrationRequestScalarWhereInput[];
    OR?: EventRegistrationRequestScalarWhereInput[];
    NOT?:
      | EventRegistrationRequestScalarWhereInput
      | EventRegistrationRequestScalarWhereInput[];
    id?: StringFilter<"EventRegistrationRequest"> | string;
    eventId?: StringFilter<"EventRegistrationRequest"> | string;
    userId?: StringFilter<"EventRegistrationRequest"> | string;
    message?: StringNullableFilter<"EventRegistrationRequest"> | string | null;
    status?:
      | EnumRegistrationRequestStatusFilter<"EventRegistrationRequest">
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFilter<"EventRegistrationRequest"> | Date | string;
    reviewedAt?:
      | DateTimeNullableFilter<"EventRegistrationRequest">
      | Date
      | string
      | null;
    reviewedByUserId?:
      | StringNullableFilter<"EventRegistrationRequest">
      | string
      | null;
  };

  export type OrgMembershipCreateWithoutOrgInput = {
    id?: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutMembershipsInput;
  };

  export type OrgMembershipUncheckedCreateWithoutOrgInput = {
    id?: string;
    userId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type OrgMembershipCreateOrConnectWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput;
    create: XOR<
      OrgMembershipCreateWithoutOrgInput,
      OrgMembershipUncheckedCreateWithoutOrgInput
    >;
  };

  export type OrgMembershipCreateManyOrgInputEnvelope = {
    data: OrgMembershipCreateManyOrgInput | OrgMembershipCreateManyOrgInput[];
    skipDuplicates?: boolean;
  };

  export type EventCreateWithoutOrgInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutOrgInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutOrgInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutOrgInput,
      EventUncheckedCreateWithoutOrgInput
    >;
  };

  export type EventCreateManyOrgInputEnvelope = {
    data: EventCreateManyOrgInput | EventCreateManyOrgInput[];
    skipDuplicates?: boolean;
  };

  export type OrgMembershipUpsertWithWhereUniqueWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput;
    update: XOR<
      OrgMembershipUpdateWithoutOrgInput,
      OrgMembershipUncheckedUpdateWithoutOrgInput
    >;
    create: XOR<
      OrgMembershipCreateWithoutOrgInput,
      OrgMembershipUncheckedCreateWithoutOrgInput
    >;
  };

  export type OrgMembershipUpdateWithWhereUniqueWithoutOrgInput = {
    where: OrgMembershipWhereUniqueInput;
    data: XOR<
      OrgMembershipUpdateWithoutOrgInput,
      OrgMembershipUncheckedUpdateWithoutOrgInput
    >;
  };

  export type OrgMembershipUpdateManyWithWhereWithoutOrgInput = {
    where: OrgMembershipScalarWhereInput;
    data: XOR<
      OrgMembershipUpdateManyMutationInput,
      OrgMembershipUncheckedUpdateManyWithoutOrgInput
    >;
  };

  export type EventUpsertWithWhereUniqueWithoutOrgInput = {
    where: EventWhereUniqueInput;
    update: XOR<
      EventUpdateWithoutOrgInput,
      EventUncheckedUpdateWithoutOrgInput
    >;
    create: XOR<
      EventCreateWithoutOrgInput,
      EventUncheckedCreateWithoutOrgInput
    >;
  };

  export type EventUpdateWithWhereUniqueWithoutOrgInput = {
    where: EventWhereUniqueInput;
    data: XOR<EventUpdateWithoutOrgInput, EventUncheckedUpdateWithoutOrgInput>;
  };

  export type EventUpdateManyWithWhereWithoutOrgInput = {
    where: EventScalarWhereInput;
    data: XOR<
      EventUpdateManyMutationInput,
      EventUncheckedUpdateManyWithoutOrgInput
    >;
  };

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[];
    OR?: EventScalarWhereInput[];
    NOT?: EventScalarWhereInput | EventScalarWhereInput[];
    id?: StringFilter<"Event"> | string;
    orgId?: StringFilter<"Event"> | string;
    name?: StringFilter<"Event"> | string;
    slug?: StringFilter<"Event"> | string;
    type?: EnumEventTypeFilter<"Event"> | $Enums.EventType;
    status?: EnumEventStatusFilter<"Event"> | $Enums.EventStatus;
    heroTitle?: StringFilter<"Event"> | string;
    heroSubtitle?: StringNullableFilter<"Event"> | string | null;
    rulesRich?: JsonNullableFilter<"Event">;
    rubricRich?: JsonNullableFilter<"Event">;
    startAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    endAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    submitDueAt?: DateTimeNullableFilter<"Event"> | Date | string | null;
    requireImages?: BoolFilter<"Event"> | boolean;
    requireVideoDemo?: BoolFilter<"Event"> | boolean;
    visibility?: EnumEventVisibilityFilter<"Event"> | $Enums.EventVisibility;
    joinMode?: EnumEventJoinModeFilter<"Event"> | $Enums.EventJoinMode;
    registrationOpensAt?:
      | DateTimeNullableFilter<"Event">
      | Date
      | string
      | null;
    registrationClosesAt?:
      | DateTimeNullableFilter<"Event">
      | Date
      | string
      | null;
    maxTeamSize?: IntFilter<"Event"> | number;
    lockTeamChangesAtStart?: BoolFilter<"Event"> | boolean;
    allowSelfJoinRequests?: BoolFilter<"Event"> | boolean;
    createdAt?: DateTimeFilter<"Event"> | Date | string;
    updatedAt?: DateTimeFilter<"Event"> | Date | string;
  };

  export type OrganizationCreateWithoutMembershipsInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    events?: EventCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationUncheckedCreateWithoutMembershipsInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    events?: EventUncheckedCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationCreateOrConnectWithoutMembershipsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
  };

  export type UserCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
  };

  export type OrganizationUpsertWithoutMembershipsInput = {
    update: XOR<
      OrganizationUpdateWithoutMembershipsInput,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
    create: XOR<
      OrganizationCreateWithoutMembershipsInput,
      OrganizationUncheckedCreateWithoutMembershipsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutMembershipsInput,
      OrganizationUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type OrganizationUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    events?: EventUpdateManyWithoutOrgNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    events?: EventUncheckedUpdateManyWithoutOrgNestedInput;
  };

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<
      UserUpdateWithoutMembershipsInput,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
    create: XOR<
      UserCreateWithoutMembershipsInput,
      UserUncheckedCreateWithoutMembershipsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutMembershipsInput,
      UserUncheckedUpdateWithoutMembershipsInput
    >;
  };

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type OrganizationCreateWithoutEventsInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationUncheckedCreateWithoutEventsInput = {
    id?: string;
    name: string;
    slug: string;
    logoUrl?: string | null;
    description?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutOrgInput;
  };

  export type OrganizationCreateOrConnectWithoutEventsInput = {
    where: OrganizationWhereUniqueInput;
    create: XOR<
      OrganizationCreateWithoutEventsInput,
      OrganizationUncheckedCreateWithoutEventsInput
    >;
  };

  export type SubmissionSchemaCreateWithoutEventInput = {
    id?: string;
    fields: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaUncheckedCreateWithoutEventInput = {
    id?: string;
    fields: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaCreateOrConnectWithoutEventInput = {
    where: SubmissionSchemaWhereUniqueInput;
    create: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
  };

  export type EventParticipantCreateWithoutEventInput = {
    id?: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutEventParticipantsInput;
  };

  export type EventParticipantUncheckedCreateWithoutEventInput = {
    id?: string;
    userId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventParticipantCreateOrConnectWithoutEventInput = {
    where: EventParticipantWhereUniqueInput;
    create: XOR<
      EventParticipantCreateWithoutEventInput,
      EventParticipantUncheckedCreateWithoutEventInput
    >;
  };

  export type EventParticipantCreateManyEventInputEnvelope = {
    data:
      | EventParticipantCreateManyEventInput
      | EventParticipantCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type TeamCreateWithoutEventInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutEventInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutEventInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutEventInput,
      TeamUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamCreateManyEventInputEnvelope = {
    data: TeamCreateManyEventInput | TeamCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type TeamInviteCreateWithoutEventInput = {
    id?: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
    team: TeamCreateNestedOneWithoutInvitesInput;
    creator: UserCreateNestedOneWithoutTeamInvitesCreatedInput;
  };

  export type TeamInviteUncheckedCreateWithoutEventInput = {
    id?: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamInviteCreateOrConnectWithoutEventInput = {
    where: TeamInviteWhereUniqueInput;
    create: XOR<
      TeamInviteCreateWithoutEventInput,
      TeamInviteUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamInviteCreateManyEventInputEnvelope = {
    data: TeamInviteCreateManyEventInput | TeamInviteCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type TeamJoinRequestCreateWithoutEventInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    team: TeamCreateNestedOneWithoutJoinRequestsInput;
    user: UserCreateNestedOneWithoutTeamJoinRequestsInput;
  };

  export type TeamJoinRequestUncheckedCreateWithoutEventInput = {
    id?: string;
    teamId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamJoinRequestCreateOrConnectWithoutEventInput = {
    where: TeamJoinRequestWhereUniqueInput;
    create: XOR<
      TeamJoinRequestCreateWithoutEventInput,
      TeamJoinRequestUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamJoinRequestCreateManyEventInputEnvelope = {
    data:
      | TeamJoinRequestCreateManyEventInput
      | TeamJoinRequestCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type TeamAuditLogCreateWithoutEventInput = {
    id?: string;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    team: TeamCreateNestedOneWithoutAuditLogsInput;
    actor?: UserCreateNestedOneWithoutTeamAuditActorInput;
    targetUser?: UserCreateNestedOneWithoutTeamAuditTargetInput;
  };

  export type TeamAuditLogUncheckedCreateWithoutEventInput = {
    id?: string;
    teamId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogCreateOrConnectWithoutEventInput = {
    where: TeamAuditLogWhereUniqueInput;
    create: XOR<
      TeamAuditLogCreateWithoutEventInput,
      TeamAuditLogUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamAuditLogCreateManyEventInputEnvelope = {
    data: TeamAuditLogCreateManyEventInput | TeamAuditLogCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type SubmissionCreateWithoutEventInput = {
    id?: string;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    team?: TeamCreateNestedOneWithoutSubmissionsInput;
    author?: UserCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutEventInput = {
    id?: string;
    teamId?: string | null;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutEventInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<
      SubmissionCreateWithoutEventInput,
      SubmissionUncheckedCreateWithoutEventInput
    >;
  };

  export type SubmissionCreateManyEventInputEnvelope = {
    data: SubmissionCreateManyEventInput | SubmissionCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type AnnouncementCreateWithoutEventInput = {
    id?: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AnnouncementUncheckedCreateWithoutEventInput = {
    id?: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type AnnouncementCreateOrConnectWithoutEventInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutEventInput,
      AnnouncementUncheckedCreateWithoutEventInput
    >;
  };

  export type AnnouncementCreateManyEventInputEnvelope = {
    data: AnnouncementCreateManyEventInput | AnnouncementCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type JudgeAssignmentCreateWithoutEventInput = {
    id?: string;
    role?: $Enums.JudgeRole;
    user: UserCreateNestedOneWithoutJudgeLinksInput;
  };

  export type JudgeAssignmentUncheckedCreateWithoutEventInput = {
    id?: string;
    userId: string;
    role?: $Enums.JudgeRole;
  };

  export type JudgeAssignmentCreateOrConnectWithoutEventInput = {
    where: JudgeAssignmentWhereUniqueInput;
    create: XOR<
      JudgeAssignmentCreateWithoutEventInput,
      JudgeAssignmentUncheckedCreateWithoutEventInput
    >;
  };

  export type JudgeAssignmentCreateManyEventInputEnvelope = {
    data:
      | JudgeAssignmentCreateManyEventInput
      | JudgeAssignmentCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type EventRegistrationRequestCreateWithoutEventInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
    user: UserCreateNestedOneWithoutRegistrationRequestsInput;
  };

  export type EventRegistrationRequestUncheckedCreateWithoutEventInput = {
    id?: string;
    userId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type EventRegistrationRequestCreateOrConnectWithoutEventInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    create: XOR<
      EventRegistrationRequestCreateWithoutEventInput,
      EventRegistrationRequestUncheckedCreateWithoutEventInput
    >;
  };

  export type EventRegistrationRequestCreateManyEventInputEnvelope = {
    data:
      | EventRegistrationRequestCreateManyEventInput
      | EventRegistrationRequestCreateManyEventInput[];
    skipDuplicates?: boolean;
  };

  export type OrganizationUpsertWithoutEventsInput = {
    update: XOR<
      OrganizationUpdateWithoutEventsInput,
      OrganizationUncheckedUpdateWithoutEventsInput
    >;
    create: XOR<
      OrganizationCreateWithoutEventsInput,
      OrganizationUncheckedCreateWithoutEventsInput
    >;
    where?: OrganizationWhereInput;
  };

  export type OrganizationUpdateToOneWithWhereWithoutEventsInput = {
    where?: OrganizationWhereInput;
    data: XOR<
      OrganizationUpdateWithoutEventsInput,
      OrganizationUncheckedUpdateWithoutEventsInput
    >;
  };

  export type OrganizationUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutOrgNestedInput;
  };

  export type OrganizationUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutOrgNestedInput;
  };

  export type SubmissionSchemaUpsertWithoutEventInput = {
    update: XOR<
      SubmissionSchemaUpdateWithoutEventInput,
      SubmissionSchemaUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      SubmissionSchemaCreateWithoutEventInput,
      SubmissionSchemaUncheckedCreateWithoutEventInput
    >;
    where?: SubmissionSchemaWhereInput;
  };

  export type SubmissionSchemaUpdateToOneWithWhereWithoutEventInput = {
    where?: SubmissionSchemaWhereInput;
    data: XOR<
      SubmissionSchemaUpdateWithoutEventInput,
      SubmissionSchemaUncheckedUpdateWithoutEventInput
    >;
  };

  export type SubmissionSchemaUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
  };

  export type SubmissionSchemaUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fields?: JsonNullValueInput | InputJsonValue;
  };

  export type EventParticipantUpsertWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput;
    update: XOR<
      EventParticipantUpdateWithoutEventInput,
      EventParticipantUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      EventParticipantCreateWithoutEventInput,
      EventParticipantUncheckedCreateWithoutEventInput
    >;
  };

  export type EventParticipantUpdateWithWhereUniqueWithoutEventInput = {
    where: EventParticipantWhereUniqueInput;
    data: XOR<
      EventParticipantUpdateWithoutEventInput,
      EventParticipantUncheckedUpdateWithoutEventInput
    >;
  };

  export type EventParticipantUpdateManyWithWhereWithoutEventInput = {
    where: EventParticipantScalarWhereInput;
    data: XOR<
      EventParticipantUpdateManyMutationInput,
      EventParticipantUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type TeamUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput;
    update: XOR<
      TeamUpdateWithoutEventInput,
      TeamUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      TeamCreateWithoutEventInput,
      TeamUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput;
    data: XOR<
      TeamUpdateWithoutEventInput,
      TeamUncheckedUpdateWithoutEventInput
    >;
  };

  export type TeamUpdateManyWithWhereWithoutEventInput = {
    where: TeamScalarWhereInput;
    data: XOR<
      TeamUpdateManyMutationInput,
      TeamUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[];
    OR?: TeamScalarWhereInput[];
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[];
    id?: StringFilter<"Team"> | string;
    eventId?: StringFilter<"Team"> | string;
    name?: StringFilter<"Team"> | string;
    blurb?: StringNullableFilter<"Team"> | string | null;
    track?: StringNullableFilter<"Team"> | string | null;
    lookingForMembers?: BoolFilter<"Team"> | boolean;
    createdAt?: DateTimeFilter<"Team"> | Date | string;
    updatedAt?: DateTimeFilter<"Team"> | Date | string;
  };

  export type TeamInviteUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamInviteWhereUniqueInput;
    update: XOR<
      TeamInviteUpdateWithoutEventInput,
      TeamInviteUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      TeamInviteCreateWithoutEventInput,
      TeamInviteUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamInviteUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamInviteWhereUniqueInput;
    data: XOR<
      TeamInviteUpdateWithoutEventInput,
      TeamInviteUncheckedUpdateWithoutEventInput
    >;
  };

  export type TeamInviteUpdateManyWithWhereWithoutEventInput = {
    where: TeamInviteScalarWhereInput;
    data: XOR<
      TeamInviteUpdateManyMutationInput,
      TeamInviteUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type TeamJoinRequestUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamJoinRequestWhereUniqueInput;
    update: XOR<
      TeamJoinRequestUpdateWithoutEventInput,
      TeamJoinRequestUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      TeamJoinRequestCreateWithoutEventInput,
      TeamJoinRequestUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamJoinRequestUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamJoinRequestWhereUniqueInput;
    data: XOR<
      TeamJoinRequestUpdateWithoutEventInput,
      TeamJoinRequestUncheckedUpdateWithoutEventInput
    >;
  };

  export type TeamJoinRequestUpdateManyWithWhereWithoutEventInput = {
    where: TeamJoinRequestScalarWhereInput;
    data: XOR<
      TeamJoinRequestUpdateManyMutationInput,
      TeamJoinRequestUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type TeamAuditLogUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamAuditLogWhereUniqueInput;
    update: XOR<
      TeamAuditLogUpdateWithoutEventInput,
      TeamAuditLogUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      TeamAuditLogCreateWithoutEventInput,
      TeamAuditLogUncheckedCreateWithoutEventInput
    >;
  };

  export type TeamAuditLogUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamAuditLogWhereUniqueInput;
    data: XOR<
      TeamAuditLogUpdateWithoutEventInput,
      TeamAuditLogUncheckedUpdateWithoutEventInput
    >;
  };

  export type TeamAuditLogUpdateManyWithWhereWithoutEventInput = {
    where: TeamAuditLogScalarWhereInput;
    data: XOR<
      TeamAuditLogUpdateManyMutationInput,
      TeamAuditLogUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutEventInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<
      SubmissionUpdateWithoutEventInput,
      SubmissionUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      SubmissionCreateWithoutEventInput,
      SubmissionUncheckedCreateWithoutEventInput
    >;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutEventInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<
      SubmissionUpdateWithoutEventInput,
      SubmissionUncheckedUpdateWithoutEventInput
    >;
  };

  export type SubmissionUpdateManyWithWhereWithoutEventInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<
      SubmissionUpdateManyMutationInput,
      SubmissionUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type AnnouncementUpsertWithWhereUniqueWithoutEventInput = {
    where: AnnouncementWhereUniqueInput;
    update: XOR<
      AnnouncementUpdateWithoutEventInput,
      AnnouncementUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      AnnouncementCreateWithoutEventInput,
      AnnouncementUncheckedCreateWithoutEventInput
    >;
  };

  export type AnnouncementUpdateWithWhereUniqueWithoutEventInput = {
    where: AnnouncementWhereUniqueInput;
    data: XOR<
      AnnouncementUpdateWithoutEventInput,
      AnnouncementUncheckedUpdateWithoutEventInput
    >;
  };

  export type AnnouncementUpdateManyWithWhereWithoutEventInput = {
    where: AnnouncementScalarWhereInput;
    data: XOR<
      AnnouncementUpdateManyMutationInput,
      AnnouncementUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    OR?: AnnouncementScalarWhereInput[];
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    id?: StringFilter<"Announcement"> | string;
    eventId?: StringFilter<"Announcement"> | string;
    title?: StringFilter<"Announcement"> | string;
    bodyRich?: JsonNullableFilter<"Announcement">;
    createdAt?: DateTimeFilter<"Announcement"> | Date | string;
  };

  export type JudgeAssignmentUpsertWithWhereUniqueWithoutEventInput = {
    where: JudgeAssignmentWhereUniqueInput;
    update: XOR<
      JudgeAssignmentUpdateWithoutEventInput,
      JudgeAssignmentUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      JudgeAssignmentCreateWithoutEventInput,
      JudgeAssignmentUncheckedCreateWithoutEventInput
    >;
  };

  export type JudgeAssignmentUpdateWithWhereUniqueWithoutEventInput = {
    where: JudgeAssignmentWhereUniqueInput;
    data: XOR<
      JudgeAssignmentUpdateWithoutEventInput,
      JudgeAssignmentUncheckedUpdateWithoutEventInput
    >;
  };

  export type JudgeAssignmentUpdateManyWithWhereWithoutEventInput = {
    where: JudgeAssignmentScalarWhereInput;
    data: XOR<
      JudgeAssignmentUpdateManyMutationInput,
      JudgeAssignmentUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type EventRegistrationRequestUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    update: XOR<
      EventRegistrationRequestUpdateWithoutEventInput,
      EventRegistrationRequestUncheckedUpdateWithoutEventInput
    >;
    create: XOR<
      EventRegistrationRequestCreateWithoutEventInput,
      EventRegistrationRequestUncheckedCreateWithoutEventInput
    >;
  };

  export type EventRegistrationRequestUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationRequestWhereUniqueInput;
    data: XOR<
      EventRegistrationRequestUpdateWithoutEventInput,
      EventRegistrationRequestUncheckedUpdateWithoutEventInput
    >;
  };

  export type EventRegistrationRequestUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationRequestScalarWhereInput;
    data: XOR<
      EventRegistrationRequestUpdateManyMutationInput,
      EventRegistrationRequestUncheckedUpdateManyWithoutEventInput
    >;
  };

  export type EventCreateWithoutRegistrationRequestsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutRegistrationRequestsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutRegistrationRequestsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutRegistrationRequestsInput,
      EventUncheckedCreateWithoutRegistrationRequestsInput
    >;
  };

  export type UserCreateWithoutRegistrationRequestsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
  };

  export type UserUncheckedCreateWithoutRegistrationRequestsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
  };

  export type UserCreateOrConnectWithoutRegistrationRequestsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRegistrationRequestsInput,
      UserUncheckedCreateWithoutRegistrationRequestsInput
    >;
  };

  export type EventUpsertWithoutRegistrationRequestsInput = {
    update: XOR<
      EventUpdateWithoutRegistrationRequestsInput,
      EventUncheckedUpdateWithoutRegistrationRequestsInput
    >;
    create: XOR<
      EventCreateWithoutRegistrationRequestsInput,
      EventUncheckedCreateWithoutRegistrationRequestsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutRegistrationRequestsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutRegistrationRequestsInput,
      EventUncheckedUpdateWithoutRegistrationRequestsInput
    >;
  };

  export type EventUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type UserUpsertWithoutRegistrationRequestsInput = {
    update: XOR<
      UserUpdateWithoutRegistrationRequestsInput,
      UserUncheckedUpdateWithoutRegistrationRequestsInput
    >;
    create: XOR<
      UserCreateWithoutRegistrationRequestsInput,
      UserUncheckedCreateWithoutRegistrationRequestsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRegistrationRequestsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRegistrationRequestsInput,
      UserUncheckedUpdateWithoutRegistrationRequestsInput
    >;
  };

  export type UserUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
  };

  export type UserUncheckedUpdateWithoutRegistrationRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
  };

  export type EventCreateWithoutParticipantsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutParticipantsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutParticipantsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
  };

  export type UserCreateWithoutEventParticipantsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutEventParticipantsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutEventParticipantsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutEventParticipantsInput,
      UserUncheckedCreateWithoutEventParticipantsInput
    >;
  };

  export type EventUpsertWithoutParticipantsInput = {
    update: XOR<
      EventUpdateWithoutParticipantsInput,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
    create: XOR<
      EventCreateWithoutParticipantsInput,
      EventUncheckedCreateWithoutParticipantsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutParticipantsInput,
      EventUncheckedUpdateWithoutParticipantsInput
    >;
  };

  export type EventUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type UserUpsertWithoutEventParticipantsInput = {
    update: XOR<
      UserUpdateWithoutEventParticipantsInput,
      UserUncheckedUpdateWithoutEventParticipantsInput
    >;
    create: XOR<
      UserCreateWithoutEventParticipantsInput,
      UserUncheckedCreateWithoutEventParticipantsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEventParticipantsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutEventParticipantsInput,
      UserUncheckedUpdateWithoutEventParticipantsInput
    >;
  };

  export type UserUpdateWithoutEventParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutEventParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutSubmissionSchemaInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutSubmissionSchemaInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutSubmissionSchemaInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutSubmissionSchemaInput,
      EventUncheckedCreateWithoutSubmissionSchemaInput
    >;
  };

  export type EventUpsertWithoutSubmissionSchemaInput = {
    update: XOR<
      EventUpdateWithoutSubmissionSchemaInput,
      EventUncheckedUpdateWithoutSubmissionSchemaInput
    >;
    create: XOR<
      EventCreateWithoutSubmissionSchemaInput,
      EventUncheckedCreateWithoutSubmissionSchemaInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutSubmissionSchemaInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutSubmissionSchemaInput,
      EventUncheckedUpdateWithoutSubmissionSchemaInput
    >;
  };

  export type EventUpdateWithoutSubmissionSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutSubmissionSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type EventCreateWithoutTeamsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutTeamsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutTeamsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutTeamsInput,
      EventUncheckedCreateWithoutTeamsInput
    >;
  };

  export type TeamAuditLogCreateWithoutTeamInput = {
    id?: string;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamAuditLogsInput;
    actor?: UserCreateNestedOneWithoutTeamAuditActorInput;
    targetUser?: UserCreateNestedOneWithoutTeamAuditTargetInput;
  };

  export type TeamAuditLogUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogCreateOrConnectWithoutTeamInput = {
    where: TeamAuditLogWhereUniqueInput;
    create: XOR<
      TeamAuditLogCreateWithoutTeamInput,
      TeamAuditLogUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamAuditLogCreateManyTeamInputEnvelope = {
    data: TeamAuditLogCreateManyTeamInput | TeamAuditLogCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    role?: $Enums.TeamRole;
    user: UserCreateNestedOneWithoutTeamsInput;
  };

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    userId: string;
    role?: $Enums.TeamRole;
  };

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<
      TeamMemberCreateWithoutTeamInput,
      TeamMemberUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type TeamInviteCreateWithoutTeamInput = {
    id?: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
    event: EventCreateNestedOneWithoutTeamInvitesInput;
    creator: UserCreateNestedOneWithoutTeamInvitesCreatedInput;
  };

  export type TeamInviteUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamInviteCreateOrConnectWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput;
    create: XOR<
      TeamInviteCreateWithoutTeamInput,
      TeamInviteUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamInviteCreateManyTeamInputEnvelope = {
    data: TeamInviteCreateManyTeamInput | TeamInviteCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type TeamJoinRequestCreateWithoutTeamInput = {
    id?: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutJoinRequestsInput;
    user: UserCreateNestedOneWithoutTeamJoinRequestsInput;
  };

  export type TeamJoinRequestUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamJoinRequestCreateOrConnectWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput;
    create: XOR<
      TeamJoinRequestCreateWithoutTeamInput,
      TeamJoinRequestUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamJoinRequestCreateManyTeamInputEnvelope = {
    data:
      | TeamJoinRequestCreateManyTeamInput
      | TeamJoinRequestCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type SubmissionCreateWithoutTeamInput = {
    id?: string;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    event: EventCreateNestedOneWithoutSubmissionsInput;
    author?: UserCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutTeamInput = {
    id?: string;
    eventId: string;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<
      SubmissionCreateWithoutTeamInput,
      SubmissionUncheckedCreateWithoutTeamInput
    >;
  };

  export type SubmissionCreateManyTeamInputEnvelope = {
    data: SubmissionCreateManyTeamInput | SubmissionCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type EventUpsertWithoutTeamsInput = {
    update: XOR<
      EventUpdateWithoutTeamsInput,
      EventUncheckedUpdateWithoutTeamsInput
    >;
    create: XOR<
      EventCreateWithoutTeamsInput,
      EventUncheckedCreateWithoutTeamsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutTeamsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutTeamsInput,
      EventUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type EventUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type TeamAuditLogUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamAuditLogWhereUniqueInput;
    update: XOR<
      TeamAuditLogUpdateWithoutTeamInput,
      TeamAuditLogUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      TeamAuditLogCreateWithoutTeamInput,
      TeamAuditLogUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamAuditLogUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamAuditLogWhereUniqueInput;
    data: XOR<
      TeamAuditLogUpdateWithoutTeamInput,
      TeamAuditLogUncheckedUpdateWithoutTeamInput
    >;
  };

  export type TeamAuditLogUpdateManyWithWhereWithoutTeamInput = {
    where: TeamAuditLogScalarWhereInput;
    data: XOR<
      TeamAuditLogUpdateManyMutationInput,
      TeamAuditLogUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<
      TeamMemberUpdateWithoutTeamInput,
      TeamMemberUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      TeamMemberCreateWithoutTeamInput,
      TeamMemberUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<
      TeamMemberUpdateWithoutTeamInput,
      TeamMemberUncheckedUpdateWithoutTeamInput
    >;
  };

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<
      TeamMemberUpdateManyMutationInput,
      TeamMemberUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type TeamInviteUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput;
    update: XOR<
      TeamInviteUpdateWithoutTeamInput,
      TeamInviteUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      TeamInviteCreateWithoutTeamInput,
      TeamInviteUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamInviteUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamInviteWhereUniqueInput;
    data: XOR<
      TeamInviteUpdateWithoutTeamInput,
      TeamInviteUncheckedUpdateWithoutTeamInput
    >;
  };

  export type TeamInviteUpdateManyWithWhereWithoutTeamInput = {
    where: TeamInviteScalarWhereInput;
    data: XOR<
      TeamInviteUpdateManyMutationInput,
      TeamInviteUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput;
    update: XOR<
      TeamJoinRequestUpdateWithoutTeamInput,
      TeamJoinRequestUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      TeamJoinRequestCreateWithoutTeamInput,
      TeamJoinRequestUncheckedCreateWithoutTeamInput
    >;
  };

  export type TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput;
    data: XOR<
      TeamJoinRequestUpdateWithoutTeamInput,
      TeamJoinRequestUncheckedUpdateWithoutTeamInput
    >;
  };

  export type TeamJoinRequestUpdateManyWithWhereWithoutTeamInput = {
    where: TeamJoinRequestScalarWhereInput;
    data: XOR<
      TeamJoinRequestUpdateManyMutationInput,
      TeamJoinRequestUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<
      SubmissionUpdateWithoutTeamInput,
      SubmissionUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      SubmissionCreateWithoutTeamInput,
      SubmissionUncheckedCreateWithoutTeamInput
    >;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<
      SubmissionUpdateWithoutTeamInput,
      SubmissionUncheckedUpdateWithoutTeamInput
    >;
  };

  export type SubmissionUpdateManyWithWhereWithoutTeamInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<
      SubmissionUpdateManyMutationInput,
      SubmissionUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type TeamCreateWithoutMembersInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutMembersInput,
      TeamUncheckedCreateWithoutMembersInput
    >;
  };

  export type UserCreateWithoutTeamsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamsInput,
      UserUncheckedCreateWithoutTeamsInput
    >;
  };

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<
      TeamUpdateWithoutMembersInput,
      TeamUncheckedUpdateWithoutMembersInput
    >;
    create: XOR<
      TeamCreateWithoutMembersInput,
      TeamUncheckedCreateWithoutMembersInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutMembersInput,
      TeamUncheckedUpdateWithoutMembersInput
    >;
  };

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<
      UserUpdateWithoutTeamsInput,
      UserUncheckedUpdateWithoutTeamsInput
    >;
    create: XOR<
      UserCreateWithoutTeamsInput,
      UserUncheckedCreateWithoutTeamsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamsInput,
      UserUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutTeamInvitesInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutTeamInvitesInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutTeamInvitesInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutTeamInvitesInput,
      EventUncheckedCreateWithoutTeamInvitesInput
    >;
  };

  export type TeamCreateWithoutInvitesInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutInvitesInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutInvitesInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutInvitesInput,
      TeamUncheckedCreateWithoutInvitesInput
    >;
  };

  export type UserCreateWithoutTeamInvitesCreatedInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamInvitesCreatedInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamInvitesCreatedInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamInvitesCreatedInput,
      UserUncheckedCreateWithoutTeamInvitesCreatedInput
    >;
  };

  export type EventUpsertWithoutTeamInvitesInput = {
    update: XOR<
      EventUpdateWithoutTeamInvitesInput,
      EventUncheckedUpdateWithoutTeamInvitesInput
    >;
    create: XOR<
      EventCreateWithoutTeamInvitesInput,
      EventUncheckedCreateWithoutTeamInvitesInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutTeamInvitesInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutTeamInvitesInput,
      EventUncheckedUpdateWithoutTeamInvitesInput
    >;
  };

  export type EventUpdateWithoutTeamInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutTeamInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type TeamUpsertWithoutInvitesInput = {
    update: XOR<
      TeamUpdateWithoutInvitesInput,
      TeamUncheckedUpdateWithoutInvitesInput
    >;
    create: XOR<
      TeamCreateWithoutInvitesInput,
      TeamUncheckedCreateWithoutInvitesInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutInvitesInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutInvitesInput,
      TeamUncheckedUpdateWithoutInvitesInput
    >;
  };

  export type TeamUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutTeamInvitesCreatedInput = {
    update: XOR<
      UserUpdateWithoutTeamInvitesCreatedInput,
      UserUncheckedUpdateWithoutTeamInvitesCreatedInput
    >;
    create: XOR<
      UserCreateWithoutTeamInvitesCreatedInput,
      UserUncheckedCreateWithoutTeamInvitesCreatedInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamInvitesCreatedInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamInvitesCreatedInput,
      UserUncheckedUpdateWithoutTeamInvitesCreatedInput
    >;
  };

  export type UserUpdateWithoutTeamInvitesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamInvitesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutJoinRequestsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutJoinRequestsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutJoinRequestsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutJoinRequestsInput,
      EventUncheckedCreateWithoutJoinRequestsInput
    >;
  };

  export type TeamCreateWithoutJoinRequestsInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutJoinRequestsInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutJoinRequestsInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutJoinRequestsInput,
      TeamUncheckedCreateWithoutJoinRequestsInput
    >;
  };

  export type UserCreateWithoutTeamJoinRequestsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamJoinRequestsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamJoinRequestsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamJoinRequestsInput,
      UserUncheckedCreateWithoutTeamJoinRequestsInput
    >;
  };

  export type EventUpsertWithoutJoinRequestsInput = {
    update: XOR<
      EventUpdateWithoutJoinRequestsInput,
      EventUncheckedUpdateWithoutJoinRequestsInput
    >;
    create: XOR<
      EventCreateWithoutJoinRequestsInput,
      EventUncheckedCreateWithoutJoinRequestsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutJoinRequestsInput,
      EventUncheckedUpdateWithoutJoinRequestsInput
    >;
  };

  export type EventUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type TeamUpsertWithoutJoinRequestsInput = {
    update: XOR<
      TeamUpdateWithoutJoinRequestsInput,
      TeamUncheckedUpdateWithoutJoinRequestsInput
    >;
    create: XOR<
      TeamCreateWithoutJoinRequestsInput,
      TeamUncheckedCreateWithoutJoinRequestsInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutJoinRequestsInput,
      TeamUncheckedUpdateWithoutJoinRequestsInput
    >;
  };

  export type TeamUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutTeamJoinRequestsInput = {
    update: XOR<
      UserUpdateWithoutTeamJoinRequestsInput,
      UserUncheckedUpdateWithoutTeamJoinRequestsInput
    >;
    create: XOR<
      UserCreateWithoutTeamJoinRequestsInput,
      UserUncheckedCreateWithoutTeamJoinRequestsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamJoinRequestsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamJoinRequestsInput,
      UserUncheckedUpdateWithoutTeamJoinRequestsInput
    >;
  };

  export type UserUpdateWithoutTeamJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutTeamAuditLogsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutTeamAuditLogsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutTeamAuditLogsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutTeamAuditLogsInput,
      EventUncheckedCreateWithoutTeamAuditLogsInput
    >;
  };

  export type TeamCreateWithoutAuditLogsInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutAuditLogsInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutAuditLogsInput,
      TeamUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type UserCreateWithoutTeamAuditActorInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamAuditActorInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamAuditActorInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamAuditActorInput,
      UserUncheckedCreateWithoutTeamAuditActorInput
    >;
  };

  export type UserCreateWithoutTeamAuditTargetInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutTeamAuditTargetInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutTeamAuditTargetInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamAuditTargetInput,
      UserUncheckedCreateWithoutTeamAuditTargetInput
    >;
  };

  export type EventUpsertWithoutTeamAuditLogsInput = {
    update: XOR<
      EventUpdateWithoutTeamAuditLogsInput,
      EventUncheckedUpdateWithoutTeamAuditLogsInput
    >;
    create: XOR<
      EventCreateWithoutTeamAuditLogsInput,
      EventUncheckedCreateWithoutTeamAuditLogsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutTeamAuditLogsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutTeamAuditLogsInput,
      EventUncheckedUpdateWithoutTeamAuditLogsInput
    >;
  };

  export type EventUpdateWithoutTeamAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutTeamAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type TeamUpsertWithoutAuditLogsInput = {
    update: XOR<
      TeamUpdateWithoutAuditLogsInput,
      TeamUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      TeamCreateWithoutAuditLogsInput,
      TeamUncheckedCreateWithoutAuditLogsInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutAuditLogsInput,
      TeamUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type TeamUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutTeamAuditActorInput = {
    update: XOR<
      UserUpdateWithoutTeamAuditActorInput,
      UserUncheckedUpdateWithoutTeamAuditActorInput
    >;
    create: XOR<
      UserCreateWithoutTeamAuditActorInput,
      UserUncheckedCreateWithoutTeamAuditActorInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamAuditActorInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamAuditActorInput,
      UserUncheckedUpdateWithoutTeamAuditActorInput
    >;
  };

  export type UserUpdateWithoutTeamAuditActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamAuditActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUpsertWithoutTeamAuditTargetInput = {
    update: XOR<
      UserUpdateWithoutTeamAuditTargetInput,
      UserUncheckedUpdateWithoutTeamAuditTargetInput
    >;
    create: XOR<
      UserCreateWithoutTeamAuditTargetInput,
      UserUncheckedCreateWithoutTeamAuditTargetInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamAuditTargetInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamAuditTargetInput,
      UserUncheckedUpdateWithoutTeamAuditTargetInput
    >;
  };

  export type UserUpdateWithoutTeamAuditTargetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamAuditTargetInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutSubmissionsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutSubmissionsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutSubmissionsInput,
      EventUncheckedCreateWithoutSubmissionsInput
    >;
  };

  export type TeamCreateWithoutSubmissionsInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    event: EventCreateNestedOneWithoutTeamsInput;
    auditLogs?: TeamAuditLogCreateNestedManyWithoutTeamInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    eventId: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    auditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutTeamInput;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    invites?: TeamInviteUncheckedCreateNestedManyWithoutTeamInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutSubmissionsInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutSubmissionsInput,
      TeamUncheckedCreateWithoutSubmissionsInput
    >;
  };

  export type UserCreateWithoutSubmissionsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSubmissionsInput,
      UserUncheckedCreateWithoutSubmissionsInput
    >;
  };

  export type ScoreCreateWithoutSubmissionInput = {
    id?: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    judge: UserCreateNestedOneWithoutScoresGivenInput;
  };

  export type ScoreUncheckedCreateWithoutSubmissionInput = {
    id?: string;
    judgeId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreCreateOrConnectWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    create: XOR<
      ScoreCreateWithoutSubmissionInput,
      ScoreUncheckedCreateWithoutSubmissionInput
    >;
  };

  export type ScoreCreateManySubmissionInputEnvelope = {
    data: ScoreCreateManySubmissionInput | ScoreCreateManySubmissionInput[];
    skipDuplicates?: boolean;
  };

  export type EventUpsertWithoutSubmissionsInput = {
    update: XOR<
      EventUpdateWithoutSubmissionsInput,
      EventUncheckedUpdateWithoutSubmissionsInput
    >;
    create: XOR<
      EventCreateWithoutSubmissionsInput,
      EventUncheckedCreateWithoutSubmissionsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutSubmissionsInput,
      EventUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type EventUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type TeamUpsertWithoutSubmissionsInput = {
    update: XOR<
      TeamUpdateWithoutSubmissionsInput,
      TeamUncheckedUpdateWithoutSubmissionsInput
    >;
    create: XOR<
      TeamCreateWithoutSubmissionsInput,
      TeamUncheckedCreateWithoutSubmissionsInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutSubmissionsInput,
      TeamUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type TeamUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<
      UserUpdateWithoutSubmissionsInput,
      UserUncheckedUpdateWithoutSubmissionsInput
    >;
    create: XOR<
      UserCreateWithoutSubmissionsInput,
      UserUncheckedCreateWithoutSubmissionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSubmissionsInput,
      UserUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type ScoreUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    update: XOR<
      ScoreUpdateWithoutSubmissionInput,
      ScoreUncheckedUpdateWithoutSubmissionInput
    >;
    create: XOR<
      ScoreCreateWithoutSubmissionInput,
      ScoreUncheckedCreateWithoutSubmissionInput
    >;
  };

  export type ScoreUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    data: XOR<
      ScoreUpdateWithoutSubmissionInput,
      ScoreUncheckedUpdateWithoutSubmissionInput
    >;
  };

  export type ScoreUpdateManyWithWhereWithoutSubmissionInput = {
    where: ScoreScalarWhereInput;
    data: XOR<
      ScoreUpdateManyMutationInput,
      ScoreUncheckedUpdateManyWithoutSubmissionInput
    >;
  };

  export type EventCreateWithoutJudgeAssignmentsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutJudgeAssignmentsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutJudgeAssignmentsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutJudgeAssignmentsInput,
      EventUncheckedCreateWithoutJudgeAssignmentsInput
    >;
  };

  export type UserCreateWithoutJudgeLinksInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutJudgeLinksInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    scoresGiven?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutJudgeLinksInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutJudgeLinksInput,
      UserUncheckedCreateWithoutJudgeLinksInput
    >;
  };

  export type EventUpsertWithoutJudgeAssignmentsInput = {
    update: XOR<
      EventUpdateWithoutJudgeAssignmentsInput,
      EventUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
    create: XOR<
      EventCreateWithoutJudgeAssignmentsInput,
      EventUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutJudgeAssignmentsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutJudgeAssignmentsInput,
      EventUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
  };

  export type EventUpdateWithoutJudgeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutJudgeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type UserUpsertWithoutJudgeLinksInput = {
    update: XOR<
      UserUpdateWithoutJudgeLinksInput,
      UserUncheckedUpdateWithoutJudgeLinksInput
    >;
    create: XOR<
      UserCreateWithoutJudgeLinksInput,
      UserUncheckedCreateWithoutJudgeLinksInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutJudgeLinksInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutJudgeLinksInput,
      UserUncheckedUpdateWithoutJudgeLinksInput
    >;
  };

  export type UserUpdateWithoutJudgeLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutJudgeLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    scoresGiven?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type SubmissionCreateWithoutScoresInput = {
    id?: string;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
    event: EventCreateNestedOneWithoutSubmissionsInput;
    team?: TeamCreateNestedOneWithoutSubmissionsInput;
    author?: UserCreateNestedOneWithoutSubmissionsInput;
  };

  export type SubmissionUncheckedCreateWithoutScoresInput = {
    id?: string;
    eventId: string;
    teamId?: string | null;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
  };

  export type SubmissionCreateOrConnectWithoutScoresInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<
      SubmissionCreateWithoutScoresInput,
      SubmissionUncheckedCreateWithoutScoresInput
    >;
  };

  export type UserCreateWithoutScoresGivenInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantCreateNestedManyWithoutUserInput;
    teams?: TeamMemberCreateNestedManyWithoutUserInput;
    submissions?: SubmissionCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogCreateNestedManyWithoutTargetUserInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutScoresGivenInput = {
    id?: string;
    email: string;
    name?: string | null;
    imageUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    memberships?: OrgMembershipUncheckedCreateNestedManyWithoutUserInput;
    eventParticipants?: EventParticipantUncheckedCreateNestedManyWithoutUserInput;
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAuthorInput;
    judgeLinks?: JudgeAssignmentUncheckedCreateNestedManyWithoutUserInput;
    teamInvitesCreated?: TeamInviteUncheckedCreateNestedManyWithoutCreatorInput;
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput;
    teamAuditActor?: TeamAuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamAuditTarget?: TeamAuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutScoresGivenInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutScoresGivenInput,
      UserUncheckedCreateWithoutScoresGivenInput
    >;
  };

  export type SubmissionUpsertWithoutScoresInput = {
    update: XOR<
      SubmissionUpdateWithoutScoresInput,
      SubmissionUncheckedUpdateWithoutScoresInput
    >;
    create: XOR<
      SubmissionCreateWithoutScoresInput,
      SubmissionUncheckedCreateWithoutScoresInput
    >;
    where?: SubmissionWhereInput;
  };

  export type SubmissionUpdateToOneWithWhereWithoutScoresInput = {
    where?: SubmissionWhereInput;
    data: XOR<
      SubmissionUpdateWithoutScoresInput,
      SubmissionUncheckedUpdateWithoutScoresInput
    >;
  };

  export type SubmissionUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutSubmissionsNestedInput;
    author?: UserUpdateOneWithoutSubmissionsNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserUpsertWithoutScoresGivenInput = {
    update: XOR<
      UserUpdateWithoutScoresGivenInput,
      UserUncheckedUpdateWithoutScoresGivenInput
    >;
    create: XOR<
      UserCreateWithoutScoresGivenInput,
      UserUncheckedCreateWithoutScoresGivenInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutScoresGivenInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutScoresGivenInput,
      UserUncheckedUpdateWithoutScoresGivenInput
    >;
  };

  export type UserUpdateWithoutScoresGivenInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUpdateManyWithoutTargetUserNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutScoresGivenInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    memberships?: OrgMembershipUncheckedUpdateManyWithoutUserNestedInput;
    eventParticipants?: EventParticipantUncheckedUpdateManyWithoutUserNestedInput;
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutAuthorNestedInput;
    judgeLinks?: JudgeAssignmentUncheckedUpdateManyWithoutUserNestedInput;
    teamInvitesCreated?: TeamInviteUncheckedUpdateManyWithoutCreatorNestedInput;
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput;
    teamAuditActor?: TeamAuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamAuditTarget?: TeamAuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type EventCreateWithoutAnnouncementsInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    org: OrganizationCreateNestedOneWithoutEventsInput;
    submissionSchema?: SubmissionSchemaCreateNestedOneWithoutEventInput;
    participants?: EventParticipantCreateNestedManyWithoutEventInput;
    teams?: TeamCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogCreateNestedManyWithoutEventInput;
    submissions?: SubmissionCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestCreateNestedManyWithoutEventInput;
  };

  export type EventUncheckedCreateWithoutAnnouncementsInput = {
    id?: string;
    orgId: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissionSchema?: SubmissionSchemaUncheckedCreateNestedOneWithoutEventInput;
    participants?: EventParticipantUncheckedCreateNestedManyWithoutEventInput;
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput;
    teamInvites?: TeamInviteUncheckedCreateNestedManyWithoutEventInput;
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutEventInput;
    teamAuditLogs?: TeamAuditLogUncheckedCreateNestedManyWithoutEventInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutEventInput;
    judgeAssignments?: JudgeAssignmentUncheckedCreateNestedManyWithoutEventInput;
    registrationRequests?: EventRegistrationRequestUncheckedCreateNestedManyWithoutEventInput;
  };

  export type EventCreateOrConnectWithoutAnnouncementsInput = {
    where: EventWhereUniqueInput;
    create: XOR<
      EventCreateWithoutAnnouncementsInput,
      EventUncheckedCreateWithoutAnnouncementsInput
    >;
  };

  export type EventUpsertWithoutAnnouncementsInput = {
    update: XOR<
      EventUpdateWithoutAnnouncementsInput,
      EventUncheckedUpdateWithoutAnnouncementsInput
    >;
    create: XOR<
      EventCreateWithoutAnnouncementsInput,
      EventUncheckedCreateWithoutAnnouncementsInput
    >;
    where?: EventWhereInput;
  };

  export type EventUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: EventWhereInput;
    data: XOR<
      EventUpdateWithoutAnnouncementsInput,
      EventUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type EventUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutEventsNestedInput;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type OrgMembershipCreateManyUserInput = {
    id?: string;
    orgId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type EventParticipantCreateManyUserInput = {
    id?: string;
    eventId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberCreateManyUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    role?: $Enums.TeamRole;
  };

  export type SubmissionCreateManyAuthorInput = {
    id?: string;
    eventId: string;
    teamId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
  };

  export type JudgeAssignmentCreateManyUserInput = {
    id?: string;
    eventId: string;
    role?: $Enums.JudgeRole;
  };

  export type TeamInviteCreateManyCreatorInput = {
    id?: string;
    eventId: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamJoinRequestCreateManyUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamAuditLogCreateManyActorInput = {
    id?: string;
    eventId: string;
    teamId: string;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamAuditLogCreateManyTargetUserInput = {
    id?: string;
    eventId: string;
    teamId: string;
    actorId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type ScoreCreateManyJudgeInput = {
    id?: string;
    submissionId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type EventRegistrationRequestCreateManyUserInput = {
    id?: string;
    eventId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type OrgMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    org?: OrganizationUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type OrgMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orgId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutParticipantsNestedInput;
  };

  export type EventParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type SubmissionUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type JudgeAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
    event?: EventUpdateOneRequiredWithoutJudgeAssignmentsNestedInput;
  };

  export type JudgeAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type JudgeAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type TeamInviteUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutTeamInvitesNestedInput;
    team?: TeamUpdateOneRequiredWithoutInvitesNestedInput;
  };

  export type TeamInviteUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamInviteUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamJoinRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutJoinRequestsNestedInput;
    team?: TeamUpdateOneRequiredWithoutJoinRequestsNestedInput;
  };

  export type TeamJoinRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamAuditLogsNestedInput;
    team?: TeamUpdateOneRequiredWithoutAuditLogsNestedInput;
    targetUser?: UserUpdateOneWithoutTeamAuditTargetNestedInput;
  };

  export type TeamAuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamAuditLogsNestedInput;
    team?: TeamUpdateOneRequiredWithoutAuditLogsNestedInput;
    actor?: UserUpdateOneWithoutTeamAuditActorNestedInput;
  };

  export type TeamAuditLogUncheckedUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUpdateWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submission?: SubmissionUpdateOneRequiredWithoutScoresNestedInput;
  };

  export type ScoreUncheckedUpdateWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventRegistrationRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    event?: EventUpdateOneRequiredWithoutRegistrationRequestsNestedInput;
  };

  export type EventRegistrationRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventRegistrationRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrgMembershipCreateManyOrgInput = {
    id?: string;
    userId: string;
    role?: $Enums.OrgRole;
    createdAt?: Date | string;
  };

  export type EventCreateManyOrgInput = {
    id?: string;
    name: string;
    slug: string;
    type: $Enums.EventType;
    status?: $Enums.EventStatus;
    heroTitle: string;
    heroSubtitle?: string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: Date | string | null;
    endAt?: Date | string | null;
    submitDueAt?: Date | string | null;
    requireImages?: boolean;
    requireVideoDemo?: boolean;
    visibility?: $Enums.EventVisibility;
    joinMode?: $Enums.EventJoinMode;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    maxTeamSize?: number;
    lockTeamChangesAtStart?: boolean;
    allowSelfJoinRequests?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrgMembershipUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput;
  };

  export type OrgMembershipUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrgMembershipUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUpdateManyWithoutEventNestedInput;
    teams?: TeamUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissionSchema?: SubmissionSchemaUncheckedUpdateOneWithoutEventNestedInput;
    participants?: EventParticipantUncheckedUpdateManyWithoutEventNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput;
    teamInvites?: TeamInviteUncheckedUpdateManyWithoutEventNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutEventNestedInput;
    teamAuditLogs?: TeamAuditLogUncheckedUpdateManyWithoutEventNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutEventNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutEventNestedInput;
    judgeAssignments?: JudgeAssignmentUncheckedUpdateManyWithoutEventNestedInput;
    registrationRequests?: EventRegistrationRequestUncheckedUpdateManyWithoutEventNestedInput;
  };

  export type EventUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    type?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType;
    status?: EnumEventStatusFieldUpdateOperationsInput | $Enums.EventStatus;
    heroTitle?: StringFieldUpdateOperationsInput | string;
    heroSubtitle?: NullableStringFieldUpdateOperationsInput | string | null;
    rulesRich?: NullableJsonNullValueInput | InputJsonValue;
    rubricRich?: NullableJsonNullValueInput | InputJsonValue;
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    submitDueAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    requireImages?: BoolFieldUpdateOperationsInput | boolean;
    requireVideoDemo?: BoolFieldUpdateOperationsInput | boolean;
    visibility?:
      | EnumEventVisibilityFieldUpdateOperationsInput
      | $Enums.EventVisibility;
    joinMode?:
      | EnumEventJoinModeFieldUpdateOperationsInput
      | $Enums.EventJoinMode;
    registrationOpensAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    registrationClosesAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    lockTeamChangesAtStart?: BoolFieldUpdateOperationsInput | boolean;
    allowSelfJoinRequests?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantCreateManyEventInput = {
    id?: string;
    userId: string;
    status?: $Enums.ParticipantStatus;
    newsletterOptIn?: boolean;
    contactEmail?: string | null;
    lookingForTeam?: boolean;
    trackPreference?: string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamCreateManyEventInput = {
    id?: string;
    name: string;
    blurb?: string | null;
    track?: string | null;
    lookingForMembers?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamInviteCreateManyEventInput = {
    id?: string;
    teamId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamJoinRequestCreateManyEventInput = {
    id?: string;
    teamId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamAuditLogCreateManyEventInput = {
    id?: string;
    teamId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type SubmissionCreateManyEventInput = {
    id?: string;
    teamId?: string | null;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
  };

  export type AnnouncementCreateManyEventInput = {
    id?: string;
    title: string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type JudgeAssignmentCreateManyEventInput = {
    id?: string;
    userId: string;
    role?: $Enums.JudgeRole;
  };

  export type EventRegistrationRequestCreateManyEventInput = {
    id?: string;
    userId: string;
    message?: string | null;
    status?: $Enums.RegistrationRequestStatus;
    createdAt?: Date | string;
    reviewedAt?: Date | string | null;
    reviewedByUserId?: string | null;
  };

  export type EventParticipantUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutEventParticipantsNestedInput;
  };

  export type EventParticipantUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EventParticipantUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumParticipantStatusFieldUpdateOperationsInput
      | $Enums.ParticipantStatus;
    newsletterOptIn?: BoolFieldUpdateOperationsInput | boolean;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForTeam?: BoolFieldUpdateOperationsInput | boolean;
    trackPreference?: NullableStringFieldUpdateOperationsInput | string | null;
    skills?: NullableJsonNullValueInput | InputJsonValue;
    interests?: NullableJsonNullValueInput | InputJsonValue;
    experienceLevel?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    auditLogs?: TeamAuditLogUncheckedUpdateManyWithoutTeamNestedInput;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    invites?: TeamInviteUncheckedUpdateManyWithoutTeamNestedInput;
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    blurb?: NullableStringFieldUpdateOperationsInput | string | null;
    track?: NullableStringFieldUpdateOperationsInput | string | null;
    lookingForMembers?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamInviteUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    team?: TeamUpdateOneRequiredWithoutInvitesNestedInput;
    creator?: UserUpdateOneRequiredWithoutTeamInvitesCreatedNestedInput;
  };

  export type TeamInviteUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamInviteUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamJoinRequestUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    team?: TeamUpdateOneRequiredWithoutJoinRequestsNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput;
  };

  export type TeamJoinRequestUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    team?: TeamUpdateOneRequiredWithoutAuditLogsNestedInput;
    actor?: UserUpdateOneWithoutTeamAuditActorNestedInput;
    targetUser?: UserUpdateOneWithoutTeamAuditTargetNestedInput;
  };

  export type TeamAuditLogUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    team?: TeamUpdateOneWithoutSubmissionsNestedInput;
    author?: UserUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type AnnouncementUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    bodyRich?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeAssignmentUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
    user?: UserUpdateOneRequiredWithoutJudgeLinksNestedInput;
  };

  export type JudgeAssignmentUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type JudgeAssignmentUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumJudgeRoleFieldUpdateOperationsInput | $Enums.JudgeRole;
  };

  export type EventRegistrationRequestUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutRegistrationRequestsNestedInput;
  };

  export type EventRegistrationRequestUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type EventRegistrationRequestUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumRegistrationRequestStatusFieldUpdateOperationsInput
      | $Enums.RegistrationRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reviewedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type TeamAuditLogCreateManyTeamInput = {
    id?: string;
    eventId: string;
    actorId?: string | null;
    targetUserId?: string | null;
    action: $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type TeamMemberCreateManyTeamInput = {
    id?: string;
    eventId: string;
    userId: string;
    role?: $Enums.TeamRole;
  };

  export type TeamInviteCreateManyTeamInput = {
    id?: string;
    eventId: string;
    email: string;
    token: string;
    status?: $Enums.InviteStatus;
    message?: string | null;
    createdByUserId: string;
    createdAt?: Date | string;
    expiresAt?: Date | string | null;
  };

  export type TeamJoinRequestCreateManyTeamInput = {
    id?: string;
    eventId: string;
    userId: string;
    message?: string | null;
    status?: $Enums.JoinRequestStatus;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubmissionCreateManyTeamInput = {
    id?: string;
    eventId: string;
    authorId?: string | null;
    status?: $Enums.SubmissionStatus;
    title: string;
    description?: string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submittedAt?: Date | string | null;
  };

  export type TeamAuditLogUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutTeamAuditLogsNestedInput;
    actor?: UserUpdateOneWithoutTeamAuditActorNestedInput;
    targetUser?: UserUpdateOneWithoutTeamAuditTargetNestedInput;
  };

  export type TeamAuditLogUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamAuditLogUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?:
      | EnumTeamAuditActionFieldUpdateOperationsInput
      | $Enums.TeamAuditAction;
    meta?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole;
  };

  export type TeamInviteUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutTeamInvitesNestedInput;
    creator?: UserUpdateOneRequiredWithoutTeamInvitesCreatedNestedInput;
  };

  export type TeamInviteUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamInviteUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByUserId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type TeamJoinRequestUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    event?: EventUpdateOneRequiredWithoutJoinRequestsNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput;
  };

  export type TeamJoinRequestUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamJoinRequestUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    message?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumJoinRequestStatusFieldUpdateOperationsInput
      | $Enums.JoinRequestStatus;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput;
    author?: UserUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventId?: StringFieldUpdateOperationsInput | string;
    authorId?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumSubmissionStatusFieldUpdateOperationsInput
      | $Enums.SubmissionStatus;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: NullableJsonNullValueInput | InputJsonValue;
    imageUrls?: NullableJsonNullValueInput | InputJsonValue;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submittedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ScoreCreateManySubmissionInput = {
    id?: string;
    judgeId: string;
    total?: number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judge?: UserUpdateOneRequiredWithoutScoresGivenNestedInput;
  };

  export type ScoreUncheckedUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    total?: NullableFloatFieldUpdateOperationsInput | number | null;
    breakdown?: NullableJsonNullValueInput | InputJsonValue;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}

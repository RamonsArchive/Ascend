/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
// biome-ignore-all lint: generated file

Object.defineProperty(exports, "__esModule", { value: true });

const {
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  getPrismaClient,
  sqltag,
  empty,
  join,
  raw,
  skip,
  Decimal,
  Debug,
  DbNull,
  JsonNull,
  AnyNull,
  NullTypes,
  makeStrictEnum,
  Extensions,
  warnOnce,
  defineDmmfProperty,
  Public,
  getRuntime,
  createParam,
} = require("./runtime/client.js");

const Prisma = {};

exports.Prisma = Prisma;
exports.$Enums = {};

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
Prisma.prismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
};

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError;
Prisma.PrismaClientInitializationError = PrismaClientInitializationError;
Prisma.PrismaClientValidationError = PrismaClientValidationError;
Prisma.Decimal = Decimal;

/**
 * Re-export of sql-template-tag
 */
Prisma.sql = sqltag;
Prisma.empty = empty;
Prisma.join = join;
Prisma.raw = raw;
Prisma.validator = Public.validator;

/**
 * Extensions
 */
Prisma.getExtensionContext = Extensions.getExtensionContext;
Prisma.defineExtension = Extensions.defineExtension;

/**
 * Shorthand utilities for JSON filtering
 */
Prisma.DbNull = DbNull;
Prisma.JsonNull = JsonNull;
Prisma.AnyNull = AnyNull;

Prisma.NullTypes = NullTypes;

const path = require("path");

/**
 * Enums
 */
exports.Prisma.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
});

exports.Prisma.UserScalarFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  imageUrl: "imageUrl",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.OrganizationScalarFieldEnum = {
  id: "id",
  name: "name",
  slug: "slug",
  logoUrl: "logoUrl",
  description: "description",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.OrgMembershipScalarFieldEnum = {
  id: "id",
  orgId: "orgId",
  userId: "userId",
  role: "role",
  createdAt: "createdAt",
};

exports.Prisma.EventScalarFieldEnum = {
  id: "id",
  orgId: "orgId",
  name: "name",
  slug: "slug",
  type: "type",
  status: "status",
  heroTitle: "heroTitle",
  heroSubtitle: "heroSubtitle",
  rulesRich: "rulesRich",
  rubricRich: "rubricRich",
  startAt: "startAt",
  endAt: "endAt",
  submitDueAt: "submitDueAt",
  requireImages: "requireImages",
  requireVideoDemo: "requireVideoDemo",
  visibility: "visibility",
  joinMode: "joinMode",
  registrationOpensAt: "registrationOpensAt",
  registrationClosesAt: "registrationClosesAt",
  maxTeamSize: "maxTeamSize",
  lockTeamChangesAtStart: "lockTeamChangesAtStart",
  allowSelfJoinRequests: "allowSelfJoinRequests",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.EventRegistrationRequestScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  message: "message",
  status: "status",
  createdAt: "createdAt",
  reviewedAt: "reviewedAt",
  reviewedByUserId: "reviewedByUserId",
};

exports.Prisma.EventParticipantScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  status: "status",
  newsletterOptIn: "newsletterOptIn",
  contactEmail: "contactEmail",
  lookingForTeam: "lookingForTeam",
  trackPreference: "trackPreference",
  skills: "skills",
  interests: "interests",
  experienceLevel: "experienceLevel",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.SubmissionSchemaScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  fields: "fields",
};

exports.Prisma.TeamScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  name: "name",
  blurb: "blurb",
  track: "track",
  lookingForMembers: "lookingForMembers",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.TeamMemberScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  role: "role",
};

exports.Prisma.TeamInviteScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  email: "email",
  token: "token",
  status: "status",
  message: "message",
  createdByUserId: "createdByUserId",
  createdAt: "createdAt",
  expiresAt: "expiresAt",
};

exports.Prisma.TeamJoinRequestScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  message: "message",
  status: "status",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.TeamAuditLogScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  actorId: "actorId",
  targetUserId: "targetUserId",
  action: "action",
  meta: "meta",
  createdAt: "createdAt",
};

exports.Prisma.SubmissionScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  authorId: "authorId",
  status: "status",
  title: "title",
  description: "description",
  content: "content",
  imageUrls: "imageUrls",
  videoUrl: "videoUrl",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
  submittedAt: "submittedAt",
};

exports.Prisma.JudgeAssignmentScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  role: "role",
};

exports.Prisma.ScoreScalarFieldEnum = {
  id: "id",
  submissionId: "submissionId",
  judgeId: "judgeId",
  total: "total",
  breakdown: "breakdown",
  feedback: "feedback",
  createdAt: "createdAt",
  updatedAt: "updatedAt",
};

exports.Prisma.AnnouncementScalarFieldEnum = {
  id: "id",
  eventId: "eventId",
  title: "title",
  bodyRich: "bodyRich",
  createdAt: "createdAt",
};

exports.Prisma.ContactMessageScalarFieldEnum = {
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email",
  phone: "phone",
  organization: "organization",
  message: "message",
  createdAt: "createdAt",
  readAt: "readAt",
};

exports.Prisma.SortOrder = {
  asc: "asc",
  desc: "desc",
};

exports.Prisma.NullableJsonNullValueInput = {
  DbNull: Prisma.DbNull,
  JsonNull: Prisma.JsonNull,
};

exports.Prisma.JsonNullValueInput = {
  JsonNull: Prisma.JsonNull,
};

exports.Prisma.NullsOrder = {
  first: "first",
  last: "last",
};

exports.Prisma.UserOrderByRelevanceFieldEnum = {
  id: "id",
  email: "email",
  name: "name",
  imageUrl: "imageUrl",
};

exports.Prisma.OrganizationOrderByRelevanceFieldEnum = {
  id: "id",
  name: "name",
  slug: "slug",
  logoUrl: "logoUrl",
  description: "description",
};

exports.Prisma.OrgMembershipOrderByRelevanceFieldEnum = {
  id: "id",
  orgId: "orgId",
  userId: "userId",
};

exports.Prisma.JsonNullValueFilter = {
  DbNull: Prisma.DbNull,
  JsonNull: Prisma.JsonNull,
  AnyNull: Prisma.AnyNull,
};

exports.Prisma.QueryMode = {
  default: "default",
  insensitive: "insensitive",
};

exports.Prisma.EventOrderByRelevanceFieldEnum = {
  id: "id",
  orgId: "orgId",
  name: "name",
  slug: "slug",
  heroTitle: "heroTitle",
  heroSubtitle: "heroSubtitle",
};

exports.Prisma.EventRegistrationRequestOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  message: "message",
  reviewedByUserId: "reviewedByUserId",
};

exports.Prisma.EventParticipantOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
  contactEmail: "contactEmail",
  trackPreference: "trackPreference",
  experienceLevel: "experienceLevel",
};

exports.Prisma.SubmissionSchemaOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
};

exports.Prisma.TeamOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  name: "name",
  blurb: "blurb",
  track: "track",
};

exports.Prisma.TeamMemberOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
};

exports.Prisma.TeamInviteOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  email: "email",
  token: "token",
  message: "message",
  createdByUserId: "createdByUserId",
};

exports.Prisma.TeamJoinRequestOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  userId: "userId",
  message: "message",
};

exports.Prisma.TeamAuditLogOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  actorId: "actorId",
  targetUserId: "targetUserId",
};

exports.Prisma.SubmissionOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  teamId: "teamId",
  authorId: "authorId",
  title: "title",
  description: "description",
  videoUrl: "videoUrl",
};

exports.Prisma.JudgeAssignmentOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  userId: "userId",
};

exports.Prisma.ScoreOrderByRelevanceFieldEnum = {
  id: "id",
  submissionId: "submissionId",
  judgeId: "judgeId",
  feedback: "feedback",
};

exports.Prisma.AnnouncementOrderByRelevanceFieldEnum = {
  id: "id",
  eventId: "eventId",
  title: "title",
};

exports.Prisma.ContactMessageOrderByRelevanceFieldEnum = {
  id: "id",
  firstName: "firstName",
  lastName: "lastName",
  email: "email",
  phone: "phone",
  organization: "organization",
  message: "message",
};
exports.OrgRole = exports.$Enums.OrgRole = {
  OWNER: "OWNER",
  ADMIN: "ADMIN",
  MEMBER: "MEMBER",
};

exports.EventType = exports.$Enums.EventType = {
  IDEATHON: "IDEATHON",
  HACKATHON: "HACKATHON",
};

exports.EventStatus = exports.$Enums.EventStatus = {
  DRAFT: "DRAFT",
  PUBLISHED: "PUBLISHED",
  ARCHIVED: "ARCHIVED",
};

exports.TeamRole = exports.$Enums.TeamRole = {
  LEADER: "LEADER",
  MEMBER: "MEMBER",
};

exports.SubmissionStatus = exports.$Enums.SubmissionStatus = {
  DRAFT: "DRAFT",
  SUBMITTED: "SUBMITTED",
};

exports.JudgeRole = exports.$Enums.JudgeRole = {
  JUDGE: "JUDGE",
  ADMIN_JUDGE: "ADMIN_JUDGE",
};

exports.ParticipantStatus = exports.$Enums.ParticipantStatus = {
  REGISTERED: "REGISTERED",
  WITHDRAWN: "WITHDRAWN",
};

exports.InviteStatus = exports.$Enums.InviteStatus = {
  PENDING: "PENDING",
  ACCEPTED: "ACCEPTED",
  DECLINED: "DECLINED",
  REVOKED: "REVOKED",
  EXPIRED: "EXPIRED",
};

exports.JoinRequestStatus = exports.$Enums.JoinRequestStatus = {
  PENDING: "PENDING",
  ACCEPTED: "ACCEPTED",
  DECLINED: "DECLINED",
  CANCELLED: "CANCELLED",
};

exports.TeamAuditAction = exports.$Enums.TeamAuditAction = {
  TEAM_CREATED: "TEAM_CREATED",
  TEAM_UPDATED: "TEAM_UPDATED",
  TEAM_DELETED: "TEAM_DELETED",
  INVITE_SENT: "INVITE_SENT",
  INVITE_REVOKED: "INVITE_REVOKED",
  INVITE_ACCEPTED: "INVITE_ACCEPTED",
  INVITE_DECLINED: "INVITE_DECLINED",
  JOIN_REQUEST_SENT: "JOIN_REQUEST_SENT",
  JOIN_REQUEST_ACCEPTED: "JOIN_REQUEST_ACCEPTED",
  JOIN_REQUEST_DECLINED: "JOIN_REQUEST_DECLINED",
  JOIN_REQUEST_CANCELLED: "JOIN_REQUEST_CANCELLED",
  MEMBER_LEFT: "MEMBER_LEFT",
  MEMBER_KICKED: "MEMBER_KICKED",
  LEADER_TRANSFERRED: "LEADER_TRANSFERRED",
};

exports.RegistrationRequestStatus = exports.$Enums.RegistrationRequestStatus = {
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  CANCELLED: "CANCELLED",
};

exports.EventVisibility = exports.$Enums.EventVisibility = {
  PUBLIC_LISTED: "PUBLIC_LISTED",
  PUBLIC_UNLISTED: "PUBLIC_UNLISTED",
  PRIVATE: "PRIVATE",
};

exports.EventJoinMode = exports.$Enums.EventJoinMode = {
  OPEN: "OPEN",
  REQUEST: "REQUEST",
  INVITE_ONLY: "INVITE_ONLY",
};

exports.Prisma.ModelName = {
  User: "User",
  Organization: "Organization",
  OrgMembership: "OrgMembership",
  Event: "Event",
  EventRegistrationRequest: "EventRegistrationRequest",
  EventParticipant: "EventParticipant",
  SubmissionSchema: "SubmissionSchema",
  Team: "Team",
  TeamMember: "TeamMember",
  TeamInvite: "TeamInvite",
  TeamJoinRequest: "TeamJoinRequest",
  TeamAuditLog: "TeamAuditLog",
  Submission: "Submission",
  JudgeAssignment: "JudgeAssignment",
  Score: "Score",
  Announcement: "Announcement",
  ContactMessage: "ContactMessage",
};
/**
 * Create the Client
 */
const config = {
  previewFeatures: [],
  clientVersion: "7.2.0",
  engineVersion: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
  activeProvider: "mysql",
  inlineSchema:
    '// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\n//\n// Ascend — Unified Prisma Schema (Multi-Org + Multi-Event + Teams/Invites/Matchmaking)\n//\n// Goals supported:\n// - Multi-tenant orgs (Organization + OrgMembership + role-based access)\n// - Public event pages (rules/dates/sponsors/etc live on Event, rendered at /:orgSlug/:eventSlug)\n// - Participant registration + newsletter opt-in + matchmaking profile (EventParticipant)\n// - Teams with:\n//   - max team size enforcement (Event.maxTeamSize — enforced in server actions/transactions)\n//   - one-team-per-user-per-event (TeamMember @@unique([eventId, userId]))\n//   - email-only invites (TeamInvite + token acceptance link)\n//   - join requests (TeamJoinRequest) from a Find Teams page\n//   - audit history (TeamAuditLog) to prevent repudiation\n// - Submissions + judging + scoring\n//\n// Notes:\n// - The database constraints here prevent many bad states,\n//   but capacity checks (maxTeamSize) MUST be enforced in server actions with transactions.\n// - Email invite acceptance should require signed-in user whose User.email matches invite email.\n//\n\ngenerator client {\n  provider = "prisma-client-js"\n  output   = "../src/app/generated/prisma"\n}\n\ndatasource db {\n  provider = "mysql"\n}\n\n/**\n * =========================\n * Enums\n * =========================\n */\n\nenum OrgRole {\n  OWNER\n  ADMIN\n  MEMBER\n}\n\nenum EventType {\n  IDEATHON\n  HACKATHON\n}\n\nenum EventStatus {\n  DRAFT\n  PUBLISHED\n  ARCHIVED\n}\n\nenum TeamRole {\n  LEADER\n  MEMBER\n}\n\nenum SubmissionStatus {\n  DRAFT\n  SUBMITTED\n}\n\nenum JudgeRole {\n  JUDGE\n  ADMIN_JUDGE\n}\n\nenum ParticipantStatus {\n  REGISTERED\n  WITHDRAWN\n}\n\nenum InviteStatus {\n  PENDING\n  ACCEPTED\n  DECLINED\n  REVOKED\n  EXPIRED\n}\n\nenum JoinRequestStatus {\n  PENDING\n  ACCEPTED\n  DECLINED\n  CANCELLED\n}\n\nenum TeamAuditAction {\n  TEAM_CREATED\n  TEAM_UPDATED\n  TEAM_DELETED\n\n  INVITE_SENT\n  INVITE_REVOKED\n  INVITE_ACCEPTED\n  INVITE_DECLINED\n\n  JOIN_REQUEST_SENT\n  JOIN_REQUEST_ACCEPTED\n  JOIN_REQUEST_DECLINED\n  JOIN_REQUEST_CANCELLED\n\n  MEMBER_LEFT\n  MEMBER_KICKED\n  LEADER_TRANSFERRED\n}\n\nenum RegistrationRequestStatus {\n  PENDING\n  APPROVED\n  REJECTED\n  CANCELLED\n}\n\n/**\n * =========================\n * Core Identity\n * =========================\n */\n\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  name      String?\n  imageUrl  String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  // Multi-org membership\n  memberships OrgMembership[]\n\n  // Event participation (registration + newsletter + matchmaking profile)\n  eventParticipants EventParticipant[]\n\n  // Team membership (per event)\n  teams TeamMember[]\n\n  // Submissions (as author; teams can also own submissions)\n  submissions Submission[] @relation("SubmissionAuthor")\n\n  // Judging (user assigned as judge for event)\n  judgeLinks JudgeAssignment[]\n\n  // Team invites: created-by + optional target user when accepted\n  teamInvitesCreated TeamInvite[] @relation("TeamInviteCreator")\n\n  // Join requests made by a user to teams\n  teamJoinRequests TeamJoinRequest[]\n\n  // Audit logs (actor vs target user)\n  teamAuditActor  TeamAuditLog[] @relation("TeamAuditActor")\n  teamAuditTarget TeamAuditLog[] @relation("TeamAuditTarget")\n\n  // Scoring as judge\n  scoresGiven          Score[]                    @relation("ScoreJudge")\n  registrationRequests EventRegistrationRequest[]\n}\n\n/**\n * =========================\n * Multi-Org / Tenancy\n * =========================\n */\n\nmodel Organization {\n  id          String   @id @default(cuid())\n  name        String\n  slug        String   @unique\n  logoUrl     String?\n  description String?\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  memberships OrgMembership[]\n  events      Event[]\n}\n\nmodel OrgMembership {\n  id        String   @id @default(cuid())\n  orgId     String\n  userId    String\n  role      OrgRole  @default(MEMBER)\n  createdAt DateTime @default(now())\n\n  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)\n  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([orgId, userId])\n  @@index([userId])\n  @@index([orgId])\n}\n\nenum EventVisibility {\n  PUBLIC_LISTED // appears on /events\n  PUBLIC_UNLISTED // public page, but not shown on /events\n  PRIVATE // requires approval/invite to register\n}\n\nenum EventJoinMode {\n  OPEN // anyone can register (until cutoff)\n  REQUEST // user requests registration (organizer approves)\n  INVITE_ONLY // only invited users can register\n}\n\n/**\n * =========================\n * Events (Public config lives here)\n * =========================\n */\n\nmodel Event {\n  id     String      @id @default(cuid())\n  orgId  String\n  name   String\n  slug   String\n  type   EventType\n  status EventStatus @default(DRAFT)\n\n  // Public-facing content (rendered on /:orgSlug/:eventSlug)\n  heroTitle    String\n  heroSubtitle String?\n  rulesRich    Json? // markdown AST / editor JSON\n  rubricRich   Json? // optional\n\n  // Dates / deadlines\n  startAt     DateTime?\n  endAt       DateTime?\n  submitDueAt DateTime?\n\n  // Config toggles\n  requireImages    Boolean @default(false)\n  requireVideoDemo Boolean @default(false)\n\n  // ✅ Global directory /events controls\n  visibility EventVisibility @default(PUBLIC_LISTED)\n  joinMode   EventJoinMode   @default(OPEN)\n\n  // ✅ Registration windows (controls “no joining after start”)\n  registrationOpensAt  DateTime?\n  registrationClosesAt DateTime? // recommended: set to startAt (or earlier)\n  // If you want strict “no joining after start”, enforce:\n  // now <= min(startAt, registrationClosesAt)\n\n  // Team size cap (enforce in server actions + tx)\n  maxTeamSize Int @default(5)\n\n  // Policy knobs\n  // If true: after startAt, disallow leader transfer / kicking / leaving (except organizer override in code).\n  lockTeamChangesAtStart Boolean @default(true)\n\n  // If false: disable self-service join requests; only invites/admin assignment.\n  allowSelfJoinRequests Boolean @default(true)\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  org              Organization      @relation(fields: [orgId], references: [id], onDelete: Cascade)\n  submissionSchema SubmissionSchema?\n\n  // Participation + teams + workflows\n  participants  EventParticipant[]\n  teams         Team[]\n  teamInvites   TeamInvite[]\n  joinRequests  TeamJoinRequest[]\n  teamAuditLogs TeamAuditLog[]\n\n  // Submissions + announcements + judging\n  submissions          Submission[]\n  announcements        Announcement[]\n  judgeAssignments     JudgeAssignment[]\n  registrationRequests EventRegistrationRequest[]\n\n  @@unique([orgId, slug])\n  @@index([orgId])\n}\n\nmodel EventRegistrationRequest {\n  id               String                    @id @default(cuid())\n  eventId          String\n  userId           String\n  message          String?\n  status           RegistrationRequestStatus @default(PENDING)\n  createdAt        DateTime                  @default(now())\n  reviewedAt       DateTime?\n  reviewedByUserId String?\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([eventId, userId])\n  @@index([eventId])\n  @@index([userId])\n  @@index([status])\n}\n\n/**\n * =========================\n * Registration + Newsletter + Matchmaking Profile\n * =========================\n */\n\nmodel EventParticipant {\n  id      String            @id @default(cuid())\n  eventId String\n  userId  String\n  status  ParticipantStatus @default(REGISTERED)\n\n  // Newsletter / contact\n  newsletterOptIn Boolean @default(false)\n\n  // Optional override for contact (defaults to User.email in UI; store only if user edits)\n  contactEmail String?\n\n  // Matchmaking / preferences\n  lookingForTeam  Boolean @default(true)\n  trackPreference String? // e.g. "Beginner" | "Intermediate" | "Advanced" (or make enum later)\n  skills          Json? // e.g. ["react", "ml", "uiux"]\n  interests       Json? // e.g. ["hardware", "coastal tech", "design"]\n  experienceLevel String? // e.g. "Beginner" | "Intermediate" | "Advanced"\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([eventId, userId])\n  @@index([eventId])\n  @@index([userId])\n}\n\n/**\n * =========================\n * Submission Schema (dynamic form definition)\n * =========================\n */\n\nmodel SubmissionSchema {\n  id      String @id @default(cuid())\n  eventId String @unique\n\n  // Defines what fields appear on the submission form\n  // Example:\n  // [{ key:"repoUrl", label:"Repo URL", type:"url", required:true }, ...]\n  fields Json\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n}\n\n/**\n * =========================\n * Teams (Find Teams + Invites + Requests)\n * =========================\n */\n\nmodel Team {\n  id      String @id @default(cuid())\n  eventId String\n  name    String\n\n  // Shown on Find Teams page\n  blurb String? // short description / what you\'re looking for\n  track String? // team’s chosen track/category label\n\n  // If true, team is discoverable on Find Teams page\n  lookingForMembers Boolean @default(true)\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  event     Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  auditLogs TeamAuditLog[]\n\n  members      TeamMember[]\n  invites      TeamInvite[]\n  joinRequests TeamJoinRequest[]\n  submissions  Submission[]\n\n  @@index([eventId])\n}\n\n/**\n * TeamMember design notes:\n * - eventId is stored directly to enforce:\n * one-team-per-user-per-event via @@unique([eventId, userId])\n * - LEADER transfer and kicking must be audited and optionally locked after event start.\n */\nmodel TeamMember {\n  id      String   @id @default(cuid())\n  eventId String\n  teamId  String\n  userId  String\n  role    TeamRole @default(MEMBER)\n\n  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([teamId, userId])\n  @@unique([eventId, userId]) // user can only belong to one team per event\n  @@index([eventId])\n  @@index([userId])\n}\n\n/**\n * Email-only invites:\n * - Leader enters an email -> invite created with token\n * - Recipient signs in -> must match User.email -> accept via /.../team/invites/:token\n * - Acceptance must check:\n * - Event.maxTeamSize capacity\n * - TeamMember @@unique([eventId, userId]) (not already on a team)\n * - Optional lockTeamChangesAtStart policy if event has started\n */\nmodel TeamInvite {\n  id      String       @id @default(cuid())\n  eventId String\n  teamId  String\n  email   String\n  token   String       @unique\n  status  InviteStatus @default(PENDING)\n  message String?\n\n  createdByUserId String\n  createdAt       DateTime  @default(now())\n  expiresAt       DateTime?\n\n  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  team    Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)\n  creator User  @relation("TeamInviteCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)\n\n  @@index([eventId])\n  @@index([teamId])\n  @@index([email])\n}\n\n/**\n * Join requests:\n * - A user sees a team on Find Teams -> sends request with message\n * - Team leader accepts/declines\n * - Acceptance must check:\n * - Event.maxTeamSize capacity\n * - TeamMember @@unique([eventId, userId]) (not already on a team)\n * - allowSelfJoinRequests policy\n */\nmodel TeamJoinRequest {\n  id      String            @id @default(cuid())\n  eventId String\n  teamId  String\n  userId  String\n  message String?\n  status  JoinRequestStatus @default(PENDING)\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  team  Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)\n  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([teamId, userId])\n  @@index([eventId])\n  @@index([teamId])\n  @@index([userId])\n}\n\n/**\n * Audit log:\n * - Write a row for sensitive actions:\n * - kicking\n * - leader transfer\n * - invite send/revoke/accept/decline\n * - join request lifecycle\n * - Helps prevent repudiation and enables organizer review.\n */\nmodel TeamAuditLog {\n  id           String          @id @default(cuid())\n  eventId      String\n  teamId       String\n  actorId      String? // who performed the action (nullable for system actions)\n  targetUserId String? // optional target (kicked user / new leader / etc)\n  action       TeamAuditAction\n  meta         Json? // { reason, emailInvited, previousLeaderId, newLeaderId, etc }\n  createdAt    DateTime        @default(now())\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  team  Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)\n\n  actor      User? @relation("TeamAuditActor", fields: [actorId], references: [id], onDelete: SetNull)\n  targetUser User? @relation("TeamAuditTarget", fields: [targetUserId], references: [id], onDelete: SetNull)\n\n  @@index([eventId])\n  @@index([teamId])\n  @@index([actorId])\n  @@index([targetUserId])\n}\n\n/**\n * =========================\n * Submissions + Judging\n * =========================\n */\n\nmodel Submission {\n  id       String           @id @default(cuid())\n  eventId  String\n  teamId   String?\n  authorId String?\n  status   SubmissionStatus @default(DRAFT)\n\n  title       String\n  description String?\n  content     Json? // full submission payload from schema\n  imageUrls   Json? // array of URLs\n  videoUrl    String?\n\n  createdAt   DateTime  @default(now())\n  updatedAt   DateTime  @updatedAt\n  submittedAt DateTime?\n\n  event  Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  team   Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)\n  author User? @relation("SubmissionAuthor", fields: [authorId], references: [id], onDelete: SetNull)\n\n  scores Score[]\n\n  @@index([eventId])\n  @@index([teamId])\n  @@index([authorId])\n}\n\nmodel JudgeAssignment {\n  id      String    @id @default(cuid())\n  eventId String\n  userId  String\n  role    JudgeRole @default(JUDGE)\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([eventId, userId])\n  @@index([userId])\n  @@index([eventId])\n}\n\nmodel Score {\n  id           String @id @default(cuid())\n  submissionId String\n  judgeId      String // links to User.id (judge)\n\n  total     Float?\n  breakdown Json? // e.g. { "impact": 8, "tech": 7, "design": 9 }\n  feedback  String?\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)\n  judge      User       @relation("ScoreJudge", fields: [judgeId], references: [id], onDelete: Cascade)\n\n  @@unique([submissionId, judgeId])\n  @@index([submissionId])\n  @@index([judgeId])\n}\n\n/**\n * =========================\n * Announcements\n * =========================\n */\n\nmodel Announcement {\n  id        String   @id @default(cuid())\n  eventId   String\n  title     String\n  bodyRich  Json? // markdown AST / editor JSON\n  createdAt DateTime @default(now())\n\n  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)\n\n  @@index([eventId])\n}\n\n/**\n * =========================\n * Contact Messages (Global)\n * =========================\n * Stores submissions from the public Contact page.\n * These are not tied to an org or event by default,\n * but can optionally reference an organization name.\n */\n\nmodel ContactMessage {\n  id String @id @default(cuid())\n\n  // Sender identity\n  firstName String\n  lastName  String\n  email     String\n  phone     String? // optional\n\n  // Optional context\n  organization String?\n\n  // Message body\n  message String @db.Text\n\n  // Metadata\n  createdAt DateTime  @default(now())\n  readAt    DateTime? // nullable; set when an admin reviews it\n\n  @@index([email])\n  @@index([createdAt])\n}\n',
};

config.runtimeDataModel = JSON.parse(
  '{"models":{"User":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"imageUrl","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"memberships","kind":"object","type":"OrgMembership","relationName":"OrgMembershipToUser"},{"name":"eventParticipants","kind":"object","type":"EventParticipant","relationName":"EventParticipantToUser"},{"name":"teams","kind":"object","type":"TeamMember","relationName":"TeamMemberToUser"},{"name":"submissions","kind":"object","type":"Submission","relationName":"SubmissionAuthor"},{"name":"judgeLinks","kind":"object","type":"JudgeAssignment","relationName":"JudgeAssignmentToUser"},{"name":"teamInvitesCreated","kind":"object","type":"TeamInvite","relationName":"TeamInviteCreator"},{"name":"teamJoinRequests","kind":"object","type":"TeamJoinRequest","relationName":"TeamJoinRequestToUser"},{"name":"teamAuditActor","kind":"object","type":"TeamAuditLog","relationName":"TeamAuditActor"},{"name":"teamAuditTarget","kind":"object","type":"TeamAuditLog","relationName":"TeamAuditTarget"},{"name":"scoresGiven","kind":"object","type":"Score","relationName":"ScoreJudge"},{"name":"registrationRequests","kind":"object","type":"EventRegistrationRequest","relationName":"EventRegistrationRequestToUser"}],"dbName":null},"Organization":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"slug","kind":"scalar","type":"String"},{"name":"logoUrl","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"memberships","kind":"object","type":"OrgMembership","relationName":"OrgMembershipToOrganization"},{"name":"events","kind":"object","type":"Event","relationName":"EventToOrganization"}],"dbName":null},"OrgMembership":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"orgId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"role","kind":"enum","type":"OrgRole"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"org","kind":"object","type":"Organization","relationName":"OrgMembershipToOrganization"},{"name":"user","kind":"object","type":"User","relationName":"OrgMembershipToUser"}],"dbName":null},"Event":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"orgId","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"slug","kind":"scalar","type":"String"},{"name":"type","kind":"enum","type":"EventType"},{"name":"status","kind":"enum","type":"EventStatus"},{"name":"heroTitle","kind":"scalar","type":"String"},{"name":"heroSubtitle","kind":"scalar","type":"String"},{"name":"rulesRich","kind":"scalar","type":"Json"},{"name":"rubricRich","kind":"scalar","type":"Json"},{"name":"startAt","kind":"scalar","type":"DateTime"},{"name":"endAt","kind":"scalar","type":"DateTime"},{"name":"submitDueAt","kind":"scalar","type":"DateTime"},{"name":"requireImages","kind":"scalar","type":"Boolean"},{"name":"requireVideoDemo","kind":"scalar","type":"Boolean"},{"name":"visibility","kind":"enum","type":"EventVisibility"},{"name":"joinMode","kind":"enum","type":"EventJoinMode"},{"name":"registrationOpensAt","kind":"scalar","type":"DateTime"},{"name":"registrationClosesAt","kind":"scalar","type":"DateTime"},{"name":"maxTeamSize","kind":"scalar","type":"Int"},{"name":"lockTeamChangesAtStart","kind":"scalar","type":"Boolean"},{"name":"allowSelfJoinRequests","kind":"scalar","type":"Boolean"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"org","kind":"object","type":"Organization","relationName":"EventToOrganization"},{"name":"submissionSchema","kind":"object","type":"SubmissionSchema","relationName":"EventToSubmissionSchema"},{"name":"participants","kind":"object","type":"EventParticipant","relationName":"EventToEventParticipant"},{"name":"teams","kind":"object","type":"Team","relationName":"EventToTeam"},{"name":"teamInvites","kind":"object","type":"TeamInvite","relationName":"EventToTeamInvite"},{"name":"joinRequests","kind":"object","type":"TeamJoinRequest","relationName":"EventToTeamJoinRequest"},{"name":"teamAuditLogs","kind":"object","type":"TeamAuditLog","relationName":"EventToTeamAuditLog"},{"name":"submissions","kind":"object","type":"Submission","relationName":"EventToSubmission"},{"name":"announcements","kind":"object","type":"Announcement","relationName":"AnnouncementToEvent"},{"name":"judgeAssignments","kind":"object","type":"JudgeAssignment","relationName":"EventToJudgeAssignment"},{"name":"registrationRequests","kind":"object","type":"EventRegistrationRequest","relationName":"EventToEventRegistrationRequest"}],"dbName":null},"EventRegistrationRequest":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"message","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"RegistrationRequestStatus"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"reviewedAt","kind":"scalar","type":"DateTime"},{"name":"reviewedByUserId","kind":"scalar","type":"String"},{"name":"event","kind":"object","type":"Event","relationName":"EventToEventRegistrationRequest"},{"name":"user","kind":"object","type":"User","relationName":"EventRegistrationRequestToUser"}],"dbName":null},"EventParticipant":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"ParticipantStatus"},{"name":"newsletterOptIn","kind":"scalar","type":"Boolean"},{"name":"contactEmail","kind":"scalar","type":"String"},{"name":"lookingForTeam","kind":"scalar","type":"Boolean"},{"name":"trackPreference","kind":"scalar","type":"String"},{"name":"skills","kind":"scalar","type":"Json"},{"name":"interests","kind":"scalar","type":"Json"},{"name":"experienceLevel","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToEventParticipant"},{"name":"user","kind":"object","type":"User","relationName":"EventParticipantToUser"}],"dbName":null},"SubmissionSchema":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"fields","kind":"scalar","type":"Json"},{"name":"event","kind":"object","type":"Event","relationName":"EventToSubmissionSchema"}],"dbName":null},"Team":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"blurb","kind":"scalar","type":"String"},{"name":"track","kind":"scalar","type":"String"},{"name":"lookingForMembers","kind":"scalar","type":"Boolean"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToTeam"},{"name":"auditLogs","kind":"object","type":"TeamAuditLog","relationName":"TeamToTeamAuditLog"},{"name":"members","kind":"object","type":"TeamMember","relationName":"TeamToTeamMember"},{"name":"invites","kind":"object","type":"TeamInvite","relationName":"TeamToTeamInvite"},{"name":"joinRequests","kind":"object","type":"TeamJoinRequest","relationName":"TeamToTeamJoinRequest"},{"name":"submissions","kind":"object","type":"Submission","relationName":"SubmissionToTeam"}],"dbName":null},"TeamMember":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"teamId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"role","kind":"enum","type":"TeamRole"},{"name":"team","kind":"object","type":"Team","relationName":"TeamToTeamMember"},{"name":"user","kind":"object","type":"User","relationName":"TeamMemberToUser"}],"dbName":null},"TeamInvite":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"teamId","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"token","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"InviteStatus"},{"name":"message","kind":"scalar","type":"String"},{"name":"createdByUserId","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"expiresAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToTeamInvite"},{"name":"team","kind":"object","type":"Team","relationName":"TeamToTeamInvite"},{"name":"creator","kind":"object","type":"User","relationName":"TeamInviteCreator"}],"dbName":null},"TeamJoinRequest":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"teamId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"message","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"JoinRequestStatus"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToTeamJoinRequest"},{"name":"team","kind":"object","type":"Team","relationName":"TeamToTeamJoinRequest"},{"name":"user","kind":"object","type":"User","relationName":"TeamJoinRequestToUser"}],"dbName":null},"TeamAuditLog":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"teamId","kind":"scalar","type":"String"},{"name":"actorId","kind":"scalar","type":"String"},{"name":"targetUserId","kind":"scalar","type":"String"},{"name":"action","kind":"enum","type":"TeamAuditAction"},{"name":"meta","kind":"scalar","type":"Json"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToTeamAuditLog"},{"name":"team","kind":"object","type":"Team","relationName":"TeamToTeamAuditLog"},{"name":"actor","kind":"object","type":"User","relationName":"TeamAuditActor"},{"name":"targetUser","kind":"object","type":"User","relationName":"TeamAuditTarget"}],"dbName":null},"Submission":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"teamId","kind":"scalar","type":"String"},{"name":"authorId","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"SubmissionStatus"},{"name":"title","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"Json"},{"name":"imageUrls","kind":"scalar","type":"Json"},{"name":"videoUrl","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"submittedAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"EventToSubmission"},{"name":"team","kind":"object","type":"Team","relationName":"SubmissionToTeam"},{"name":"author","kind":"object","type":"User","relationName":"SubmissionAuthor"},{"name":"scores","kind":"object","type":"Score","relationName":"ScoreToSubmission"}],"dbName":null},"JudgeAssignment":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"role","kind":"enum","type":"JudgeRole"},{"name":"event","kind":"object","type":"Event","relationName":"EventToJudgeAssignment"},{"name":"user","kind":"object","type":"User","relationName":"JudgeAssignmentToUser"}],"dbName":null},"Score":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"submissionId","kind":"scalar","type":"String"},{"name":"judgeId","kind":"scalar","type":"String"},{"name":"total","kind":"scalar","type":"Float"},{"name":"breakdown","kind":"scalar","type":"Json"},{"name":"feedback","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"submission","kind":"object","type":"Submission","relationName":"ScoreToSubmission"},{"name":"judge","kind":"object","type":"User","relationName":"ScoreJudge"}],"dbName":null},"Announcement":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"eventId","kind":"scalar","type":"String"},{"name":"title","kind":"scalar","type":"String"},{"name":"bodyRich","kind":"scalar","type":"Json"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"event","kind":"object","type":"Event","relationName":"AnnouncementToEvent"}],"dbName":null},"ContactMessage":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"firstName","kind":"scalar","type":"String"},{"name":"lastName","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"phone","kind":"scalar","type":"String"},{"name":"organization","kind":"scalar","type":"String"},{"name":"message","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"readAt","kind":"scalar","type":"DateTime"}],"dbName":null}},"enums":{},"types":{}}',
);
defineDmmfProperty(exports.Prisma, config.runtimeDataModel);
config.compilerWasm = {
  getRuntime: async () => require("./query_compiler_bg.js"),
  getQueryCompilerWasmModule: async () => {
    const { Buffer } = require("node:buffer");
    const { wasm } = require("./query_compiler_bg.wasm-base64.js");
    const queryCompilerWasmFileBytes = Buffer.from(wasm, "base64");

    return new WebAssembly.Module(queryCompilerWasmFileBytes);
  },
};

const PrismaClient = getPrismaClient(config);
exports.PrismaClient = PrismaClient;
Object.assign(exports, Prisma);

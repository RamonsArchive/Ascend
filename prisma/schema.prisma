generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL") // This is the connection URL for the database
}

model User {
  id            String    @id
  name          String    @db.Text
  email         String
  emailVerified Boolean   @default(false)
  image         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  eventParticipants    EventParticipant[]
  registrationRequests EventRegistrationRequest[]
  judgeLinks           JudgeAssignment[]
  memberships          OrgMembership[]
  scoresGiven          Score[]                    @relation("ScoreJudge")
  submissions          Submission[]               @relation("SubmissionAuthor")
  teamAuditActor       TeamAuditLog[]             @relation("TeamAuditActor")
  teamAuditTarget      TeamAuditLog[]             @relation("TeamAuditTarget")
  teamInvitesCreated   TeamInvite[]               @relation("TeamInviteCreator")
  teamJoinRequests     TeamJoinRequest[]
  teams                TeamMember[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?  @db.Text
  userAgent String?  @db.Text
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  // Note: MySQL typically creates an index for FK columns; keeping an explicit
  // index here can cause name conflicts if the DB already created one.
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Note: MySQL requires the FK column to be indexed; an index is typically
  // created implicitly. Keeping an explicit index here can cause conflicts
  // when the DB already has an index with the same name.
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String   @db.Text
  value      String   @db.Text
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier(length: 191)])
  @@map("verification")
}


model Organization {
  id          String          @id @default(cuid())
  name        String
  slug        String          @unique
  logoKey    String?
  coverKey    String?
  description String?
  publicEmail String?   // e.g. hello@org.com
  publicPhone String?   // optional, international format
  websiteUrl  String?
  contactNote String?   // “Email us for sponsorships”
  moderationStatus            ModerationStatus @default(ACTIVE)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  events      Event[]
  memberships OrgMembership[]
  sponsors OrganizationSponsor[]
}

model OrgMembership {
  id        String       @id @default(cuid())
  orgId     String
  userId    String
  role      OrgRole      @default(MEMBER)
  createdAt DateTime     @default(now())
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([userId])
  @@index([orgId])
}

model Event {
  id                     String                     @id @default(cuid())
  orgId                  String
  name                   String
  slug                   String
  coverKey               String?
  type                   EventType
  status                 EventStatus                @default(DRAFT)
  heroTitle              String
  heroSubtitle           String?
  rulesRich              Json?
  rubricRich             Json?
  startAt                DateTime?
  endAt                  DateTime?
  submitDueAt            DateTime?
  requireImages          Boolean                    @default(false)
  requireVideoDemo       Boolean                    @default(false)
  visibility             EventVisibility            @default(PUBLIC_LISTED)
  joinMode               EventJoinMode              @default(OPEN)
  registrationOpensAt    DateTime?
  registrationClosesAt   DateTime?
  maxTeamSize            Int                        @default(5)
  lockTeamChangesAtStart Boolean                    @default(true)
  allowSelfJoinRequests  Boolean                    @default(true)
  createdAt              DateTime                   @default(now())
  updatedAt              DateTime                   @updatedAt
  announcements          Announcement[]
  org                    Organization               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  participants           EventParticipant[]
  registrationRequests   EventRegistrationRequest[]
  judgeAssignments       JudgeAssignment[]
  submissions            Submission[]
  submissionSchema       SubmissionSchema?
  teams                  Team[]
  teamAuditLogs          TeamAuditLog[]
  teamInvites            TeamInvite[]
  joinRequests           TeamJoinRequest[]
  moderationStatus       ModerationStatus @default(ACTIVE)
  sponsors EventSponsor[]

  @@unique([orgId, slug])
  @@index([orgId])
}

model EventRegistrationRequest {
  id               String                    @id @default(cuid())
  eventId          String
  userId           String
  message          String?
  status           RegistrationRequestStatus @default(PENDING)
  createdAt        DateTime                  @default(now())
  reviewedAt       DateTime?
  reviewedByUserId String?
  event            Event                     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user             User                      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

model EventParticipant {
  id              String            @id @default(cuid())
  eventId         String
  userId          String
  status          ParticipantStatus @default(REGISTERED)
  newsletterOptIn Boolean           @default(false)
  contactEmail    String?
  lookingForTeam  Boolean           @default(true)
  trackPreference String?
  skills          Json?
  interests       Json?
  experienceLevel String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  event           Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

model SubmissionSchema {
  id      String @id @default(cuid())
  eventId String @unique
  fields  Json
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
}

model Team {
  id                String            @id @default(cuid())
  eventId           String
  name              String
  blurb             String?
  track             String?
  lookingForMembers Boolean           @default(true)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  submissions       Submission[]
  event             Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  auditLogs         TeamAuditLog[]
  invites           TeamInvite[]
  joinRequests      TeamJoinRequest[]
  members           TeamMember[]
  moderationStatus  ModerationStatus @default(ACTIVE)

  @@index([eventId])
}

/// TeamMember design notes:
///   - eventId is stored directly to enforce:
///       one-team-per-user-per-event via @@unique([eventId, userId])
///   - LEADER transfer and kicking must be audited and optionally locked after event start.
model TeamMember {
  id      String   @id @default(cuid())
  eventId String
  teamId  String
  userId  String
  role    TeamRole @default(MEMBER)
  team    Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
}

/// Email-only invites:
///   - Leader enters an email -> invite created with token
///   - Recipient signs in -> must match User.email -> accept via /.../team/invites/:token
///   - Acceptance must check:
///       - Event.maxTeamSize capacity
///       - TeamMember @@unique([eventId, userId]) (not already on a team)
///       - Optional lockTeamChangesAtStart policy if event has started
model TeamInvite {
  id              String       @id @default(cuid())
  eventId         String
  teamId          String
  email           String
  token           String       @unique
  status          InviteStatus @default(PENDING)
  message         String?
  createdByUserId String
  createdAt       DateTime     @default(now())
  expiresAt       DateTime?
  creator         User         @relation("TeamInviteCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)
  event           Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  team            Team         @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([teamId])
  @@index([email])
  @@index([createdByUserId], map: "TeamInvite_createdByUserId_fkey")
}

/// Join requests:
///   - A user sees a team on Find Teams -> sends request with message
///   - Team leader accepts/declines
///   - Acceptance must check:
///       - Event.maxTeamSize capacity
///       - TeamMember @@unique([eventId, userId]) (not already on a team)
///       - allowSelfJoinRequests policy
model TeamJoinRequest {
  id        String            @id @default(cuid())
  eventId   String
  teamId    String
  userId    String
  message   String?
  status    JoinRequestStatus @default(PENDING)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  event     Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  team      Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([eventId])
  @@index([teamId])
  @@index([userId])
}

/// Audit log:
///   - Write a row for sensitive actions:
///       - kicking
///       - leader transfer
///       - invite send/revoke/accept/decline
///       - join request lifecycle
///   - Helps prevent repudiation and enables organizer review.
model TeamAuditLog {
  id           String          @id @default(cuid())
  eventId      String
  teamId       String
  actorId      String?
  targetUserId String?
  action       TeamAuditAction
  meta         Json?
  createdAt    DateTime        @default(now())
  actor        User?           @relation("TeamAuditActor", fields: [actorId], references: [id])
  event        Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  targetUser   User?           @relation("TeamAuditTarget", fields: [targetUserId], references: [id])
  team         Team            @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([teamId])
  @@index([actorId])
  @@index([targetUserId])
}

model Submission {
  id          String           @id @default(cuid())
  eventId     String
  teamId      String?
  authorId    String?
  status      SubmissionStatus @default(DRAFT)
  title       String
  description String?
  content     Json?
  imageKeys   Json?
  videoKey    String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  submittedAt DateTime?
  scores      Score[]
  author      User?            @relation("SubmissionAuthor", fields: [authorId], references: [id])
  event       Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  team        Team?            @relation(fields: [teamId], references: [id])
  moderationStatus             ModerationStatus @default(ACTIVE)

  @@index([eventId])
  @@index([teamId])
  @@index([authorId])
}

model JudgeAssignment {
  id      String    @id @default(cuid())
  eventId String
  userId  String
  role    JudgeRole @default(JUDGE)
  event   Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId])
  @@index([eventId])
}

model Score {
  id           String     @id @default(cuid())
  submissionId String
  judgeId      String
  total        Float?
  breakdown    Json?
  feedback     String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  judge        User       @relation("ScoreJudge", fields: [judgeId], references: [id], onDelete: Cascade)
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@unique([submissionId, judgeId])
  @@index([submissionId])
  @@index([judgeId])
}

model Announcement {
  id        String   @id @default(cuid())
  eventId   String
  title     String
  bodyRich  Json?
  createdAt DateTime @default(now())
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
}

model ContactMessage {
  id           String    @id @default(cuid())
  firstName    String
  lastName     String
  email        String
  phone        String?
  organization String?
  message      String
  createdAt    DateTime  @default(now())
  readAt       DateTime?

  @@index([email])
  @@index([createdAt])
}


model Sponsor {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  websiteKey  String?
  description String?
  logoKey     String?  @db.Text   // S3 key (recommended) e.g. public/sponsors/{id}/logo/v1/...
  coverKey    String?  @db.Text   // optional

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orgLinks    OrganizationSponsor[]
  eventLinks  EventSponsor[]
}

model OrganizationSponsor {
  id          String      @id @default(cuid())
  orgId       String
  sponsorId   String
  tier        SponsorTier @default(COMMUNITY)
  isActive    Boolean     @default(true)
  displayName String?
  blurb       String?
  order       Int         @default(0)

  // optional: custom logo for this org relationship (override global)
  logoKey     String?     @db.Text

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  org         Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  sponsor     Sponsor      @relation(fields: [sponsorId], references: [id], onDelete: Cascade)

  @@unique([orgId, sponsorId])
  @@index([orgId])
  @@index([sponsorId])
  @@index([tier])
}

model EventSponsor {
  id          String      @id @default(cuid())
  eventId     String
  sponsorId   String
  tier        SponsorTier @default(COMMUNITY)
  isActive    Boolean     @default(true)
  displayName String?
  blurb       String?
  order       Int         @default(0)

  // optional overrides for this specific event
  logoKey     String?     @db.Text
  websiteKey  String?

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  event       Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sponsor     Sponsor @relation(fields: [sponsorId], references: [id], onDelete: Cascade)

  @@unique([eventId, sponsorId])
  @@index([eventId])
  @@index([sponsorId])
  @@index([tier])
}

enum OrgRole {
  OWNER
  ADMIN
  MEMBER
}

enum EventType {
  IDEATHON
  HACKATHON
}

enum EventStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum TeamRole {
  LEADER
  MEMBER
}

enum SubmissionStatus {
  DRAFT
  SUBMITTED
}

enum JudgeRole {
  JUDGE
  ADMIN_JUDGE
}

enum ParticipantStatus {
  REGISTERED
  WITHDRAWN
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  REVOKED
  EXPIRED
}

enum JoinRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

enum TeamAuditAction {
  TEAM_CREATED
  TEAM_UPDATED
  TEAM_DELETED
  INVITE_SENT
  INVITE_REVOKED
  INVITE_ACCEPTED
  INVITE_DECLINED
  JOIN_REQUEST_SENT
  JOIN_REQUEST_ACCEPTED
  JOIN_REQUEST_DECLINED
  JOIN_REQUEST_CANCELLED
  MEMBER_LEFT
  MEMBER_KICKED
  LEADER_TRANSFERRED
}

enum RegistrationRequestStatus { 
  PENDING 
  APPROVED 
  REJECTED 
  CANCELLED 
}

enum EventVisibility {
  PUBLIC_LISTED
  PUBLIC_UNLISTED
  PRIVATE
}

enum EventJoinMode {
  OPEN
  REQUEST
  INVITE_ONLY
}

enum ModerationStatus {
  ACTIVE
  FLAGGED
  HIDDEN
}

enum SponsorTier {
  TITLE
  PLATINUM
  GOLD
  SILVER
  BRONZE
  COMMUNITY
}